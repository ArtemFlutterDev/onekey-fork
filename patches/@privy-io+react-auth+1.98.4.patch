diff --git a/node_modules/@privy-io/react-auth/dist/cjs/privy-provider-zFh8lpI0.js b/node_modules/@privy-io/react-auth/dist/cjs/privy-provider-zFh8lpI0.js
index 2a1898a..c4357cd 100644
--- a/node_modules/@privy-io/react-auth/dist/cjs/privy-provider-zFh8lpI0.js
+++ b/node_modules/@privy-io/react-auth/dist/cjs/privy-provider-zFh8lpI0.js
@@ -1,2 +1,2 @@
 "use strict";var e=require("react/jsx-runtime"),t=require("@ethersproject/address"),r=require("@ethersproject/providers"),a=require("mipd"),n=require("react"),i=require("react-device-detect"),o=require("@privy-io/js-sdk-core"),s=require("./auth-flows/custom-jwt-account.js"),l=require("./auth-flows/email.js"),c=require("./auth-flows/farcaster.js"),d=require("./auth-flows/guest.js"),u=require("./auth-flows/passkey.js"),h=require("./auth-flows/siwe.js"),y=require("./auth-flows/siws.js"),p=require("./auth-flows/sms.js"),w=require("./auth-flows/telegram.js"),E=require("uuid"),v=require("./accessToken.js"),m=require("./client/user.js"),g=require("eventemitter3"),f=require("./constants.js"),C=require("./storage.js"),P=require("./utils/index.js"),A=require("./connectors/coinbase.js"),_=require("./connectors/embedded.js"),T=require("./embedded-wallets/rpc/types.js"),W=require("./components/Captcha.js"),I=require("./components/LoginModal.js"),S=require("./components/TelegramLoginButton.js"),N=require("./configuration/context.js"),k=require("./connectors/areWalletArraysEqual.js"),U=require("./connectors/errors.js"),b=require("./connectors/is-wallet-installed.js"),O=require("./connectors/isBaseConnectedEthereumWallet.js"),R=require("./connectors/privyProxyProvider.js"),D=require("./connectors/solana/index.js"),M=require("./connectors/walletconnect-v2.js"),L=require("./embedded-wallets/EmbeddedWalletIframe.js"),F=require("./embedded-wallets/delegated-actions.js"),x=require("./embedded-wallets/errors.js"),q=require("./embedded-wallets/rpc/index.js"),j=require("./errors.js"),B=require("./embedded-wallets/solana/transaction.js"),H=require("./lib/caip2.js"),K=require("./lib/cross-app/index.js"),V=require("./lib/cross-app/authFlow.js"),G=require("./lib/cross-app/popupCrossAppAuthFlow.js"),z=require("./lib/cross-app/sendCrossAppRequest.js"),Y=require("./lib/embeddedWalletRecovery.js"),$=require("./lib/funding/index.js"),X=require("./lib/funding/isFundingEnabled.js"),J=require("./lib/isEmbeddedWebview.js"),Q=require("./lib/popup/triggerPopup.js"),Z=require("./lib/popupOAuthFlow.js"),ee=require("./lib/siwe.js"),te=require("./lib/solana/transaction.js"),re=require("./lib/toDisplayFromAccountType.js"),ae=require("./passkeys/transformResponseToSnakeCase.js"),ne=require("./plugins/context/PrivyPluginContext.js"),ie=require("./plugins/solana-funding/id.js"),oe=require("./recent-login/context.js"),se=require("./screens/index.js"),le=require("./screens/LandingScreen/styles.js"),ce=require("./styles.js"),de=require("./hooks/index.js"),ue=require("./hooks/captcha-context.js"),he=require("./hooks/events-context.js"),ye=require("./hooks/internal-context.js"),pe=require("./hooks/modal-context.js"),we=require("./hooks/privy-context.js"),Ee=require("./hooks/useWallets.js"),ve=require("./lib/funding/prepareFundingModalData.js"),me=require("./auth-flows/oauth/detectCompletingOAuthFlow.js"),ge=require("./auth-flows/oauth/OAuthFlow.js"),fe=require("./connectors/getRpcTimeout.js"),Ce=require("./connectors/providerTypes.js"),Pe=require("./connectors/ethereum/index.js"),Ae=require("./connectors/injected.js"),_e=require("./connectors/metamask.js"),Te=require("./connectors/phantom.js"),We=require("./connectors/phantom-solana.js"),Ie=require("./http.js"),Se=require("./lib/smart-wallet-helpers.js"),Ne=require("./passkeys/transformOptionsToCamelCase.js"),ke=require("./paths.js"),Ue=require("./session.js");function be(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var Oe=/*#__PURE__*/be(g);class Re extends Oe.default{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new Ce.EmbeddedProviderError(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Xe()||!this.address)throw new Ce.EmbeddedProviderError("Disconnected",4900);return(await Ze(t,void 0,void 0,this.address)).hash}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new Ce.EmbeddedProviderError(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new Ce.EmbeddedProviderError(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.provider=P.getJsonRpcProvider(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],r=e.params[1];return await Je(t,void 0,r)}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],r="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1];return await Qe(P.generateTypedDataWithDomainType(r),void 0,t)}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:P.toHex(this.chainId)};try{return await this.provider.send("eth_estimateGas",[t])}catch(e){console.warn(`Gas estimation failed with error: ${e}. Retrying gas estimation by omitting the 'from' address`);try{return delete t.from,await this.provider.send("eth_estimateGas",[t])}catch(t){throw console.warn(`Gas estimation failed with error: ${t} when omitting the 'from' address`),e}}}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return P.toHex(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!T.isSupportedEthereumRpcMethod(e.method))return this.provider.send(e.method,e.params);{let t=await Xe();if(await et(),!t||!this.address)throw new Ce.EmbeddedProviderError("Disconnected",4900);try{return(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:{method:e.method,params:e.params}})).response.data}catch(e){throw console.error(e),new Ce.EmbeddedProviderError("Disconnected",4900)}}}constructor({walletProxy:e,address:t,entropyId:r,entropyIdVerifier:a,rpcConfig:n,chains:i,appId:o,chainId:s=1,walletIndex:l}){super(),this.walletProxy=e,this.address=t,this.entropyId=r,this.entropyIdVerifier=a,this.chainId=s,this.rpcConfig=n,this.chains=i,this.provider=P.getJsonRpcProvider(s,this.chains,n,{appId:o}),this.rpcTimeoutDuration=fe.getRpcTimeout(n,"privy"),this.appId=o,this.walletIndex=l}}class De extends Oe.default{get wallets(){let e=new Set,t=this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let r=`${t.address}${t.walletClientType}${t.connectorType}`;return!e.has(r)&&(e.add(r),!0)})),r=t.findIndex((e=>e.address===(this.activeWallet?this.activeWallet:"unknown")));return r>=0&&t.unshift(t.splice(r,1)[0]),t}async initialize(){if(this.initialized)return;C.default.get(f.CONNECTORS_STATE_KEY)&&(C.default.getKeys().forEach((e=>{e.startsWith("walletconnect")&&C.default.del(e)})),C.default.del(f.CONNECTORS_STATE_KEY));let e=P.detectInjectedConnectors({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:r})=>{this.createEthereumWalletConnector("injected",e,{eip6963InjectedProvider:t,legacyInjectedProvider:r})}))}));this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector("coinbase_wallet","coinbase_wallet"),!b.isPhantomInstalled()&&this.walletList.includes("phantom")&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&this.createEthereumWalletConnector("phantom","phantom"),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&this.addWalletConnector(new We.PhantomSolanaNullWalletConnector)),this.externalWalletConfig.walletConnect.enabled&&this.createEthereumWalletConnector("wallet_connect_v2","unknown"),this.externalWalletConfig.solana.connectors?.get().forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{e?.forEach(this.addSolanaWalletConnector)})),await e,this.initialized=!0}findWalletConnector(e,t){return"wallet_connect_v2"===e?this.walletConnectors.filter(Pe.isEthereumWalletConnector).find((t=>t.connectorType===e))??null:this.walletConnectors.filter(Pe.isEthereumWalletConnector).find((r=>r.connectorType===e&&r.walletClientType===t))??null}findSolanaWalletConnector(e,t){return this.walletConnectors.filter(D.isSolanaWalletConnector).find((r=>r.connectorType===e&&r.walletClientType===t))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&t.walletClientType===e.walletClientType));t&&(e.connectedAt=t.connectedAt)})),this.saveConnectionHistory(),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&(this.saveConnectionHistory(),this.emit("walletsUpdated"))}addEmbeddedWalletConnectors({walletProxy:e,rootWallet:t,embeddedWallets:r,defaultChain:a,appId:n}){for(let i of r){let r=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===i.walletIndex));if(r&&Pe.isEthereumWalletConnector(r))r.proxyProvider.walletProxy=e;else{let{entropyId:r,entropyIdVerifier:o}=m.getEntropyDetailsFromAccount(t),s=new _.EmbeddedWalletConnector({provider:new Re({walletProxy:e,address:i.address,entropyId:r,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:n,chainId:a.id,walletIndex:i.walletIndex}),chains:this.chains,defaultChain:a,rpcConfig:this.rpcConfig,imported:!1,walletIndex:i.walletIndex});this.addWalletConnector(s)}}}addImportedWalletConnector(e,t,r,a){let n=this.findWalletConnector("embedded_imported","privy");if(n&&Pe.isEthereumWalletConnector(n))n.proxyProvider.walletProxy=e;else{let n=new _.EmbeddedWalletConnector({provider:new Re({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:a,chainId:r.id}),chains:this.chains,walletIndex:0,defaultChain:r,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(n)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.saveConnectionHistory(),this.storedConnections=Me(),this.emit("walletsUpdated")}removeImportedWalletConnector(){let e=this.findWalletConnector("embedded_imported","privy");if(e){let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1),this.saveConnectionHistory(),this.storedConnections=Me(),this.emit("walletsUpdated")}}async createEthereumWalletConnector(e,t,r){let a=this.findWalletConnector(e,t);if(a&&Pe.isEthereumWalletConnector(a))return a instanceof M.WalletConnectV2WalletConnector&&a.resetConnection(t),a;let n=(()=>"injected"!==e?"coinbase_wallet"===e?new A.CoinbaseWalletConnector(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig,this.privyAppName,this.privyAppLogo):"phantom"===e?new Te.PhantomEthereumNullWalletConnector(this.defaultChain):new M.WalletConnectV2WalletConnector(this.walletConnectCloudProjectId,this.rpcConfig,this.chains,this.defaultChain,this.shouldEnforceDefaultChainOnConnect,this.privyAppId,this.privyAppName,t):"metamask"===t&&r?.eip6963InjectedProvider?new _e.MetamaskWalletConnector(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,"metamask"):"metamask"===t&&r?.legacyInjectedProvider?new Ae.LegacyInjectedWalletConnector(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"metamask"):"phantom"===t&&r?.legacyInjectedProvider?new Ae.LegacyInjectedWalletConnector(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"phantom"):r?.legacyInjectedProvider&&"unknown_browser_extension"===t?new Ae.LegacyInjectedWalletConnector(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider):r?.eip6963InjectedProvider?new Ae.Injected6963WalletConnector(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,t):void 0)();return n&&this.addWalletConnector(n),n||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}saveConnectionHistory(){let e=this.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt})));C.default.put(f.CONNECTIONS_HISTORY_KEY,e)}async activeWalletSign(e){let t=this.wallets,r=t.length>0?t[0]:null;return r&&O.isBaseConnectedEthereumWallet(r)?r.sign(e):null}setActiveWallet(e){this.activeWallet=t.getAddress(e),this.emit("walletsUpdated")}constructor(e,t,r,a,n,i,o,s,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{this.findSolanaWalletConnector("solana_adapter",e.walletClientType)||this.addWalletConnector(e)},this.getEthereumProvider=()=>{let e=this.wallets[0],t=this.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new R.PrivyProxyProvider},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=r,this.chains=a,this.defaultChain=n,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=o,this.shouldEnforceDefaultChainOnConnect=s,this.externalWalletConfig=l,this.privyAppName=c,this.privyAppLogo=d,this.walletChainType=u||"ethereum-only",this.storedConnections=Me()}}const Me=()=>{let e=C.default.get(f.CONNECTIONS_HISTORY_KEY);return e&&Array.isArray(e)&&e.map((e=>(e=>e&&"string"==typeof e.address&&"string"==typeof e.connectorType&&"string"==typeof e.walletClientType&&"number"==typeof e.connectedAt)(e))).every(Boolean)?e:[]};let Le;var Fe=0,xe="__private_"+Fe+++"__getOrGenerateClientAnalyticsId";class qe{initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:r,defaultChain:a,store:n,walletList:i,shouldEnforceDefaultChainOnConnect:o,externalWalletConfig:s,appName:l,walletChainType:c}){this.connectors||(this.connectors=new De(this.appId,e,t,r,a,n,i,o,s,l,void 0,c))}generateApi(){let e=new Ie.Http({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new j.PrivyClientError("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new j.PrivyClientError("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(ke.mfaPasswordlessSmsInitPath,{action:"verify"})}catch(e){throw j.formatApiError(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(ke.mfaPasskeyInitPath,{});return Ne.transformOptionsToCamelCase(e.options)}catch(e){throw j.formatApiError(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(ke.acceptTermsPath,{});return m.convertUserResponseToUser(e)}catch(e){throw j.formatPrivyError(e)}}async unlinkEmail(e){try{let t=await this.api.post(ke.unlinkEmailPath,{address:e});return await this.getAuthenticatedUser()??m.convertUserResponseToUser(t)}catch(e){throw j.formatPrivyError(e)}}async unlinkPhone(e){try{let t=await this.api.post(ke.unlinkPhonePath,{phoneNumber:e});return await this.getAuthenticatedUser()??m.convertUserResponseToUser(t)}catch(e){throw j.formatPrivyError(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(ke.unlinkWalletPath,{address:e});return await this.getAuthenticatedUser()??m.convertUserResponseToUser(t)}catch(e){throw j.formatPrivyError(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(ke.siwsUnlinkWalletPath,{address:e});return await this.getAuthenticatedUser()??m.convertUserResponseToUser(t)}catch(e){throw j.formatPrivyError(e)}}async unlinkOAuth(e,t){try{let r=await this.api.post(ke.unlinkOAuthPath,{provider:e,subject:t});return await this.getAuthenticatedUser()??m.convertUserResponseToUser(r)}catch(e){throw j.formatPrivyError(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(ke.unlinkFarcasterPath,{fid:e});return await this.getAuthenticatedUser()??m.convertUserResponseToUser(t)}catch(e){throw j.formatPrivyError(e)}}async unlinkTelegram(e){try{let t=await this.api.post(ke.telegramAccountUnlinkPath,{telegram_user_id:e});return await this.getAuthenticatedUser()??m.convertUserResponseToUser(t)}catch(e){throw j.formatPrivyError(e)}}async unlinkPasskey(e){try{let t=await this.api.post(ke.unlinkPasskeyPath,{credential_id:e});return await this.getAuthenticatedUser()??m.convertUserResponseToUser(t)}catch(e){throw j.formatPrivyError(e)}}async revokeDelegatedWallet(){try{await this.api.post(ke.delegatedActionsRevokePath,{})}catch(e){throw j.formatPrivyError(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:r,options:a}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(ke.analyticsEventsPath,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:r?r.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:a?.keepAlive??!1})}catch(e){}}async signMoonpayOnRampUrl(e){try{return this.api.post(ke.moonpayPluginOnRampPath,e)}catch(e){throw j.formatPrivyError(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(ke.coinbaseOnRampInitPath,e)}catch(e){throw j.formatPrivyError(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${ke.coinbaseOnRampStatusPath}?partnerUserId=${e}`)}catch(e){throw j.formatPrivyError(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()||this.session.hasRecoveryCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(Ue.AccessTokenTypes.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(Ue.AccessTokenTypes.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?v.AccessToken.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getSmartWalletsConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let r=await this.api.get(`/api/v1/apps/${this.appId}/smart_wallets`,{baseURL:this.fallbackApiUrl,headers:e});return r.enabled?{enabled:r.enabled,smartWalletType:r.smart_wallet_type,configuredNetworks:r.configured_networks.map((e=>({chainId:e.chain_id,bundlerUrl:e.bundler_url,paymasterUrl:e.paymaster_url,paymasterContext:Se.getPaymasterContext(e.paymaster_url,e.paymaster_context)})))}:{enabled:r.enabled}}catch(e){throw j.formatPrivyError(e)}}async getServerConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let r=await this.api.get(`/api/v1/apps/${this.appId}`,{baseURL:this.fallbackApiUrl,headers:e}),a=r.telegram_auth_config?{botId:r.telegram_auth_config.bot_id,botName:r.telegram_auth_config.bot_name,linkEnabled:r.telegram_auth_config.link_enabled,seamlessAuthEnabled:r.telegram_auth_config.seamless_auth_enabled}:void 0,n=r.funding_config?{methods:r.funding_config.methods,options:r.funding_config.options,defaultRecommendedAmount:r.funding_config.default_recommended_amount,defaultRecommendedCurrency:r.funding_config.default_recommended_currency,promptFundingOnWalletCreation:r.funding_config.prompt_funding_on_wallet_creation,crossChainBridgingEnabled:r.funding_config.cross_chain_bridging_enabled}:void 0;return{id:r.id,name:r.name,verificationKey:r.verification_key,logoUrl:r.logo_url||void 0,accentColor:r.accent_color||void 0,showWalletLoginFirst:r.show_wallet_login_first,allowlistConfig:{errorTitle:r.allowlist_config.error_title,errorDetail:r.allowlist_config.error_detail,errorCtaText:r.allowlist_config.cta_text,errorCtaLink:r.allowlist_config.cta_link},walletAuth:r.wallet_auth,solanaWalletAuth:r.solana_wallet_auth,emailAuth:r.email_auth,smsAuth:r.sms_auth,googleOAuth:r.google_oauth,twitterOAuth:r.twitter_oauth,discordOAuth:r.discord_oauth,githubOAuth:r.github_oauth,spotifyOAuth:r.spotify_oauth,instagramOAuth:r.instagram_oauth,tiktokOAuth:r.tiktok_oauth,linkedinOAuth:r.linkedin_oauth,appleOAuth:r.apple_oauth,farcasterAuth:r.farcaster_auth,passkeyAuth:r.passkey_auth,telegramAuth:r.telegram_auth,disablePlusEmails:r.disable_plus_emails,termsAndConditionsUrl:r.terms_and_conditions_url,embeddedWalletConfig:{createOnLogin:r.embedded_wallet_config?.create_on_login,userOwnedRecoveryOptions:r.embedded_wallet_config.user_owned_recovery_options,requireUserOwnedRecoveryOnCreate:r.embedded_wallet_config.require_user_owned_recovery_on_create},privacyPolicyUrl:r.privacy_policy_url,requireUsersAcceptTerms:r.require_users_accept_terms,customApiUrl:r.custom_api_url,walletConnectCloudProjectId:r.wallet_connect_cloud_project_id,fiatOnRampEnabled:r.fiat_on_ramp_enabled,captchaEnabled:r.captcha_enabled,captchaSiteKey:r.captcha_site_key,createdAt:new Date(1e3*r.created_at),updatedAt:new Date(1e3*r.updated_at),mfaMethods:r.mfa_methods,enforceWalletUis:r.enforce_wallet_uis,legacyWalletUiConfig:r.legacy_wallet_ui_config,telegramAuthConfiguration:a,fundingConfig:n}}catch(e){throw j.formatPrivyError(e)}}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async forkSession(){return await this.session.forkSession()}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(ke.siweInitPath,{address:e,token:t})).nonce}catch(e){throw j.formatPrivyError(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n,mode:i}){return await this.api.post(ke.siweAuthenticatePath,{message:e,signature:t,chainId:r,walletClientType:a,connectorType:n,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}){return await this.api.post(ke.siweLinkPath,{message:e,signature:t,chainId:r,walletClientType:a,connectorType:n})}async linkSmartWallet({message:e,signature:t,smartWalletType:r}){try{let a=await this.api.post(ke.smartWalletLinkPath,{message:e,signature:t,smart_wallet_type:r});return m.convertUserResponseToUser(a)}catch(e){throw j.formatPrivyError(e)}}async linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n});return m.convertUserResponseToUser(i)}catch(e){throw j.formatPrivyError(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(ke.siwsInitPath,{address:e,token:t})).nonce}catch(e){throw j.formatPrivyError(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a,mode:n}){return await this.api.post(ke.siwsAuthenticatePath,{message:e,signature:t,walletClientType:r,connectorType:a,mode:n})}async sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o}){try{let s,l;switch(r){case"email":s=ke.transferEmailPath,l={nonce:e,email:t};break;case"sms":s=ke.transferPhonePath,l={nonce:e,phoneNumber:t};break;case"siwe":if(s=ke.transferWalletPath,!a)throw Error("Wallet parameters must be defined");l={nonce:e,address:t,...a};break;case"farcaster":s=ke.transferFarcasterPath,l={nonce:e,farcaster_id:t,farcaster_embedded_address:i};break;case"telegram":s=ke.telegramAccountTransferPath,l={nonce:e,telegram_auth_result:n};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:s=ke.transferOAuthPath,l={nonce:e,userInfo:o}}let c=await this.api.post(s,l);return await this.getAuthenticatedUser()??m.convertUserResponseToUser(c)}catch(e){throw j.formatPrivyError(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a}){return await this.api.post(ke.siwsLinkPath,{message:e,signature:t,walletClientType:r,connectorType:a})}async linkWithSiws({message:e,signature:t,walletClientType:r,connectorType:a}){try{let n=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a});return m.convertUserResponseToUser(n)}catch(e){throw j.formatPrivyError(e)}}constructor({apiUrl:e=f.DEFAULT_PRIVY_API_URL,appId:t,appClientId:r,timeout:a=f.DEFAULT_API_TIMEOUT_MS}){Object.defineProperty(this,xe,{value:je}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==f.DEFAULT_PRIVY_API_URL&&e.startsWith("https://privy."),this.timeout=a,this.appId=t,this.appClientId=r,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,xe)[xe](),Le||(Le=new Ue.Session),this.session=Le,this.api=this.generateApi(),this.session.client=this}}function je(){if("undefined"==typeof window)return null;try{let e=C.default.get(f.CLIENT_ANALYTICS_ID_KEY);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=E.v4();try{return C.default.put(f.CLIENT_ANALYTICS_ID_KEY,e),e}catch(t){return e}}class Be{async handleSignMessage(e){if(!e.params||"string"!=typeof e.params.message)throw Error("Message must be provided as a string for Solana signMessage RPC");return await rt({message:e.params.message,address:this.address})}async request(e){if(console.debug("EmbeddedSolanaProvider.request() called with args",e),!await Xe())throw Error("User must be authenticated to use embedded Solana wallet");if(!await tt())throw new j.PrivyClientError("Unable to connect to Solana embedded wallet");if("signMessage"===e.method)return await this.handleSignMessage(e);throw Error("Embedded Solana provider does not yet support this RPC method.")}constructor(e,t){this.walletProxy=e,this.address=t}}let He,Ke,Ve,Ge,ze,Ye,$e;async function Xe(){return He?He.getAccessToken():Promise.resolve(C.default.get(f.PRIVY_ACCESS_TOKEN_STORAGE_KEY)||C.default.get(f.CUSTOMER_ACCESS_TOKEN_STORAGE_KEY)||null)}const Je=(e,t,r)=>Ke(e,t,r),Qe=(e,t,r)=>Ve(e,t,r),Ze=(e,t,r,a)=>Ge(e,t,r,a),et=()=>ze(),tt=()=>Ye(),rt=({message:e,address:t})=>$e({message:e,address:t});let at=E=>{let v=E.client,g=ne.usePlugins(),[A,_]=n.useState(!1),[T,fe]=n.useState(!1),[Ce,Pe]=n.useState(!1),[Ae,_e]=n.useState(null),[Te,We]=n.useState([]),[Ie,Se]=n.useState([]),[Ne,ke]=n.useState([]),Ue=n.useRef(Te),[be,Oe]=n.useState(!1),[Re,De]=n.useState(null),[Me,Le]=n.useState(!1),[Fe,xe]=n.useState({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:de.notImplemented}),[qe,je]=n.useState({status:"initial"}),[Je,Qe]=n.useState({status:"initial"}),[Ze,et]=n.useState({status:"initial"}),[tt,rt]=n.useState({status:"initial"}),[at,nt]=n.useState({status:"initial"}),[it,ot]=n.useState(null),st=N.useAppConfig(),lt=N.useIsServerConfigLoaded(),[ct,dt]=n.useState(!0),[ut,ht]=n.useState({}),[yt,pt]=n.useState(null),[wt,Et]=n.useState(null),[vt,mt]=n.useState(!1),[gt,ft]=n.useState(!1),[Ct,Pt]=n.useState(st.customAuth?.enabled?{status:"initial"}:{status:"not-enabled"}),At=n.useRef(null),_t=n.useRef(null),Tt=n.useRef(he.privyEventsDefault),[Wt,It]=n.useState(!1);v.onStoreCustomerAccessToken=e=>{e&&he.emitPrivyEvent(Tt,"accessToken","onAccessTokenGranted",e)},v.onDeleteCustomerAccessToken=()=>{_e(null),Pe(!1),he.emitPrivyEvent(Tt,"accessToken","onAccessTokenRemoved")};let St=n.useRef(null),Nt=n.useRef(null),kt=n.useRef(!1),Ut=({showWalletUIs:e,typedData:t})=>kt.current?kt.current:void 0!==e?!e:void 0!==st.embeddedWallets.showWalletUIs?!st.embeddedWallets.showWalletUIs:t?st.embeddedWallets.noPromptOnSignature||(st.legacyWalletUiConfig??!1):!!st.embeddedWallets.noPromptOnSignature,bt=e=>{De(e),setTimeout((()=>{_(!0)}),15),v.createAnalyticsEvent({eventName:"modal_open",payload:{initialScreen:e}})},Ot=e=>{"off"!==st.embeddedWallets.createOnLogin&&dt(!0),bt(e)};n.useEffect((()=>{let e=[...m.getPrivySolanaHDWallets(Ae),m.getImportedPrivySolanaWallet(Ae)].filter((e=>!!e));it&&ke(e.map((e=>({type:"solana",imported:e.imported,address:e.address,connectedAt:Date.now(),walletClientType:"privy",connectorType:"embedded",walletIndex:e.walletIndex??void 0,meta:{name:"Privy Wallet",icon:void 0,id:"io.privy.solana.wallet"},linked:!0,fund(){throw new j.PrivyClientError("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:()=>{throw new j.PrivyClientError("Cannot unlink an embedded Solana wallet")},getProvider:async()=>new Be(it,e.address),async signMessage(t){let r=await Xe();if(!r||!it)throw new j.PrivyClientError("Must have valid access token and Privy wallet to send transaction",j.PrivyErrorCode.MUST_BE_AUTHENTICATED);let a=e.imported?m.getImportedPrivySolanaWallet(Ae):m.getPrivyPrimaryWallet(Ae);if(!a)throw new j.PrivyClientError("Attempting to sign a transaction without a root wallet");let{entropyId:n,entropyIdVerifier:i}=m.getEntropyDetailsFromAccount(a);if(!await or.recoverPrimaryWallet().catch((()=>!1)))throw new j.PrivyClientError("Wallet couldn't be connected",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR);if(!Ae)throw new j.PrivyClientError("Attempting to sign a transaction with no user initialized");let{response:o}=await it.rpc({accessToken:r,entropyId:n,entropyIdVerifier:i,chainType:"solana",hdWalletIndex:this.walletIndex??0,request:{method:"signMessage",params:{message:Buffer.from(t).toString("base64")}}});return Buffer.from(o.data.signature,"base64")},async sendTransaction(e,t,r){let{signature:a}=await Zt({transaction:e,connection:t,transactionOptions:r,wallet:this});return a},async signTransaction(t){let r=await Xe();if(!r||!it)throw new j.PrivyClientError("Must have valid access token and Privy wallet to send transaction",j.PrivyErrorCode.MUST_BE_AUTHENTICATED);if(!await or.recoverPrimaryWallet().catch((()=>!1)))throw new j.PrivyClientError("Wallet couldn't be connected",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR);let{entropyId:a,entropyIdVerifier:n}=m.getEntropyDetailsFromAccount(e);return await B.signSolanaTransaction({tx:t,accessToken:r,walletProxy:it,entropyId:a,entropyIdVerifier:n,transactingWalletAddress:this.address,transactingWalletIndex:this.walletIndex??0}),t},loginOrLink:async()=>{throw new j.PrivyClientError("Cannot login or link with an embedded Solana wallet")},disconnect:()=>{},isConnected:async()=>!0}))))}),[it,Ae]),n.useEffect((()=>{if(!Ae)return void v.connectors?.removeEmbeddedWalletConnectors();let e=m.getPrivyEthereumWallet(Ae),t=m.getPrivyEthereumHDWallets(Ae),r=m.getImportedPrivyEthereumWallet(Ae);e&&t.length||v.connectors?.removeEmbeddedWalletConnectors(),r||v.connectors?.removeImportedWalletConnector(),v.connectors?it?(e&&v.connectors.addEmbeddedWalletConnectors({walletProxy:it,rootWallet:e,embeddedWallets:t,defaultChain:st.defaultChain,appId:E.appId}),r&&v.connectors.addImportedWalletConnector(it,r.address,st.defaultChain,E.appId)):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[it,Ae]),n.useEffect((()=>{it&&wt?.(it)}),[it]);let Rt=n.useRef();n.useEffect((()=>{(async()=>{if(!st.customAuth?.enabled)return void Pt({status:"not-enabled"});dt(!0);let{getCustomAccessToken:e,isLoading:t}=st.customAuth;if(T&&!t&&"loading"!==Ct.status){Pt({status:"loading"});try{let t=await e();if(t===Rt.current)return void Pt({status:"done"});if(!t&&Ce)return Rt.current=t,await ir.logout(),Pt({status:"done"}),void he.emitPrivyEvent(Tt,"customAuth","onUnauthenticated");if(!t)return Rt.current=t,void Pt({status:"done"});v.startAuthFlow(new s.CustomJwtAccountFlow(t));let{user:r,isNewUser:a}=await v.authenticate();if(!r)return await ir.logout(),Pt({status:"error",error:new j.PrivyClientError("Failed to sync with custom auth provider")}),void he.emitPrivyEvent(Tt,"customAuth","onUnauthenticated");void 0!==a&&he.emitPrivyEvent(Tt,"login","onComplete",r,a,!1,"custom",null),Rt.current=t,he.emitPrivyEvent(Tt,"customAuth","onAuthenticated",{user:r}),Pt({status:"done"}),_e(r||null),Oe(a||!1),Pe(!0),ft(!0)}catch(e){if(console.warn(e),await ir.logout(),he.emitPrivyEvent(Tt,"customAuth","onUnauthenticated"),"User already exists with provided custom JWT account."===e.message)return void Pt({status:"initial"});he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR),Pt({status:"error",error:e})}}})()}),["initial"===Ct.status,st.customAuth?.enabled,st.customAuth?.getCustomAccessToken,st.customAuth?.isLoading,T,Ce]),n.useEffect((()=>{gt&&it&&Ae&&m.shouldProceedtoEmbeddedWalletCreationFlow(Ae,st.embeddedWallets.createOnLogin)&&(ft(!1),zt(Ae,f.WALLET_PROXY_TIMEOUT).catch(console.error))}),[gt&&it&&Ae]),n.useEffect((()=>{if(st.externalWallets.solana.connectors)return st.externalWallets.solana.connectors.onMount(),()=>st.externalWallets.solana.connectors?.onUnmount()}),[st.externalWallets.solana.connectors]),n.useEffect((()=>{!T&&lt&&async function(){let e,t=Dt(),r=Mt();(()=>{let e=new URLSearchParams(window.location.search).get("privy_token");if(!e)return;C.default.put(f.FORKED_TOKEN_STORAGE_KEY,e);let t=new URL(window.location.href);t.searchParams.delete("privy_token"),window.history.pushState({},"",t)})();let n=a.createStore();v.initializeConnectorManager({walletConnectCloudProjectId:st.walletConnectCloudProjectId,rpcConfig:st.rpcConfig,chains:st.chains,defaultChain:st.defaultChain,store:n,walletList:st.appearance.walletList,shouldEnforceDefaultChainOnConnect:st.shouldEnforceDefaultChainOnConnect,externalWalletConfig:st.externalWallets,appName:st.name??"Privy",walletChainType:st.appearance.walletChainType}),v.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=v.connectors.walletConnectors.length,r=v.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);r===t?It(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:r,expected:t}),It(!0)}),1500)})),v.connectors?.initialize().then((()=>{jt()}));let i=await v.getAuthenticatedUser(),o=!!i;st.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await v.logout(),or.setReadyToTrue(!0),he.emitPrivyEvent(Tt,"logout","onSuccess")):(st.customAuth?.enabled||(Pe(!!i),i&&he.emitPrivyEvent(Tt,"login","onComplete",i,!1,!0,null,null),_e(i)),t?Nt.current=o?"link":"login":r&&!o?(Nt.current="login",ht({telegramAuthModalData:{seamlessAuth:!0}}),Ot(se.ModalScreen.TELEGRAM_AUTH_SCREEN)):or.setReadyToTrue(!!i))}()}),[v,yt,T,lt]),n.useEffect((()=>{if(T){if(!Ae||!Ae.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void mt(!0);mt(!!Te.find((e=>"privy"===e.walletClientType)))}}),[T,Ae,Te]);let Dt=()=>{let e=me.detectCompletingOAuthFlow();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&K.isPrivyTheOAuthProvider(e.provider)&&!e.popupFlow&&(new BroadcastChannel(K.CROSS_APP_BROADCAST_CHANNEL_NAME).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(v.startAuthFlow(new ge.OAuthFlow(e)),Ot(se.ModalScreen.AWAITING_OAUTH_SCREEN),!0))},Mt=()=>{let e=w.detectCompletingTelegramFlow();if(!e||!st.loginMethods.telegram||!st.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new w.TelegramAuthFlow;return v.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},Lt=async(e,t,r,a)=>{Ft(await(v.connectors?.createEthereumWalletConnector(e,t))||null,t,r,a)};async function Ft(e,t,r,a){if(!e)return xe({status:"disconnected",connectedWallet:null,connectError:new j.PrivyConnectorError("Unable to connect to wallet."),connector:null,connectRetry:de.notImplemented}),a?.(null,r);xe({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:de.notImplemented}),e instanceof M.WalletConnectV2WalletConnector&&t&&await e.resetConnection(t),xe({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>Ft(e,t,r,a)});try{let t=await e.connect({showPrompt:!0});if((!t||O.isBaseConnectedEthereumWallet(t))&&st.shouldEnforceDefaultChainOnConnect&&!st.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){xe((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:de.notImplemented})));try{await(t?.switchChain(st.defaultChain.id)),t&&(t.chainId=P.formatChainIdToCAIP2(P.toHex(st.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${st.defaultChain.id}`)}}return xe((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:de.notImplemented}))),t&&he.emitPrivyEvent(Tt,"connectWallet","onSuccess",(e.chainType,t)),a?.(t,r)}catch(e){return e instanceof j.PrivyError?(console.warn(e.cause?e.cause:e.message),he.emitPrivyEvent(Tt,"connectWallet","onError",e.privyErrorCode||j.PrivyErrorCode.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),he.emitPrivyEvent(Tt,"connectWallet","onError",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR)),xe((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),a?.(null,r)}}let xt=async(e,t,r)=>{if(null===e||!O.isBaseConnectedEthereumWallet(e))return;let a=new h.SiweFlow(e,v,t,r);v.startAuthFlow(a)},qt=async(e,t)=>{if(null===e||!D.isBaseConnectedSolanaWallet(e))return;let r=new y.SiwsFlow(e,v,t);v.startAuthFlow(r)},jt=()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),r=e.get("privy_wallet_client");if(!t||!r)return;if("phantom"!==r||b.isPhantomInstalled()||Ot(se.ModalScreen.LOGIN_FAILED_SCREEN),!v.connectors)throw new j.PrivyClientError("Connector not initialized");bt(se.ModalScreen.AWAITING_CONNECTION);let a=new URL(window.location.href);a.searchParams.delete("privy_connector"),a.searchParams.delete("privy_wallet_client"),window.history.pushState({},"",a),Lt(t,r,void 0,xt)};n.useEffect((()=>{T&&Ce&&null===Ae&&v.getAuthenticatedUser().then(_e)}),[T,Ce,Ae,v]);let Bt=e=>{if(!Ce)throw he.emitPrivyEvent(Tt,"linkAccount","onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:e}),new j.PrivyClientError("User must be authenticated before linking an account.")},Ht=()=>{Bt("siwe"),St.current="siwe",Nt.current="link",bt(se.ModalScreen.LINK_WALLET_SCREEN)},Kt=e=>{if(!Ce||!Ae)return!1;if("privy"===e.walletClientType)return!0;for(let t of Ae.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},Vt=async e=>{let t;if(!v.connectors)throw new j.PrivyClientError("Connector not initialized");t="ethereum"===e.type?v.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:v.connectors.findSolanaWalletConnector(e.connectorType,e.walletClientType)||null,xe((r=>({...r,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:de.notImplemented}))),st.captchaEnabled&&!Ce?(ht({captchaModalData:{callback:t=>O.isBaseConnectedEthereumWallet(e)?xt(e,t):qt(e,t),userIntentRequired:!1,onSuccessNavigateTo:se.ModalScreen.AWAITING_CONNECTION,onErrorNavigateTo:se.ModalScreen.ERROR_SCREEN}}),Ot(se.ModalScreen.CAPTCHA_SCREEN)):(O.isBaseConnectedEthereumWallet(e)?await xt(e):await qt(e),Ot(se.ModalScreen.AWAITING_CONNECTION))},Gt=()=>{We((e=>{let t=v.connectors?.wallets.filter(O.isBaseConnectedEthereumWallet).map((e=>({...e,linked:Kt(e),loginOrLink:async()=>{if(!await e.isConnected())throw new j.PrivyClientError("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new j.PrivyClientError("Cannot link or login with embedded wallet");Vt(e)},fund:async t=>{await or.fundWallet(e.address,t)},unlink:async()=>{if(!Ce)throw new j.PrivyClientError("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new j.PrivyClientError("Cannot unlink an embedded wallet");_e(await v.unlinkEthereumWallet(e.address))}})))||[];return k.areWalletArraysEqual(e,t)?e:t})),Se((e=>{let t=(v.connectors?.wallets??[]).concat(Ne).filter(D.isBaseConnectedSolanaWallet).map((e=>({...e,linked:Kt(e),loginOrLink:async()=>{if(!await e.isConnected())throw new j.PrivyClientError("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new j.PrivyClientError("Cannot link or login with embedded wallet");Vt(e)},fund:async()=>{throw new j.PrivyClientError("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:async()=>{if(!Ce)throw new j.PrivyClientError("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new j.PrivyClientError("Cannot unlink an embedded wallet");_e(await v.unlinkSolanaWallet(e.address))}})));return k.areWalletArraysEqual(e,t)?e:t}))};n.useEffect((()=>{Gt()}),[Ae?.linkedAccounts,Ce,T,Ne]),n.useEffect((()=>{if(T){if(!v.connectors)throw new j.PrivyClientError("Connector not initialized");Gt(),v.connectors.on("walletsUpdated",Gt)}}),[T]),n.useEffect((()=>{[...st.loginMethodsAndOrder?.primary??[],...st.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>v.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!v]),n.useEffect((()=>{let e;if(!Te[0])return;let t=Te[0],r=Ue.current.find((e=>e.address===t.address));if(e="privy"===t.walletClientType?Ae?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"===e.walletClientType)):Ae?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"!==e.walletClientType)),!r&&e){let t=Object.assign({},Ae);t.wallet=e&&{address:e.address,chainType:e.chainType,chainId:e.chainId,walletClient:e.walletClient,walletClientType:e.walletClientType,connectorType:e.connectorType,imported:e.imported,delegated:e.delegated,walletIndex:e.walletIndex},_e(t)}Ue.current=Te}),[Te]);let zt=async(e,t,r)=>{let a=m.getPrivyEthereumWallet(e),n=m.getPrivySolanaWallet(e);if(r&&"walletIndex"in r)return $t(e,t,r.walletIndex,a,n);let i=r&&"createAdditional"in r&&r.createAdditional;if(a&&!i)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");let[o,s]=await Promise.all([or.initializeWalletProxy(t),Xe()]);if(!o&&st.customAuth?.enabled)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!o||!s||st.embeddedWallets?.requireUserOwnedRecoveryOnCreate)return Yt();if(!a)return await o.create({accessToken:s,solanaAddress:n?.address}),Jt(0,"ethereum");{let t=(m.getLatestPrivyEthereumWallet(e)?.walletIndex??0)+1,{entropyId:r,entropyIdVerifier:a}=m.getEntropyDetailsFromAccount(m.getPrivyPrimaryWallet(e));return await or.recoverPrimaryWallet(),await o.addWallet({accessToken:s,entropyId:r,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:t}),Jt(t,"ethereum")}},Yt=async()=>new Promise(((e,t)=>{dt(!0),ht({createWallet:{onSuccess:t=>{he.emitPrivyEvent(Tt,"createWallet","onSuccess",t),e(t)},onFailure:e=>{he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),t(e)},callAuthOnSuccessOnClose:!1}}),bt(se.ModalScreen.EMBEDDED_WALLET_ON_ACCOUNT_CREATE_SCREEN)})),$t=async(e,t,r,a,n)=>{if(r<0)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${r}) is invalid.`);let[i,o]=await Promise.all([or.initializeWalletProxy(t),Xe()]);if(!i&&st.customAuth?.enabled)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!i||!o||st.embeddedWallets?.requireUserOwnedRecoveryOnCreate){if(0==r)return Yt();throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Create wallet UI can only be displayed when walletIndex is 0.")}if(0==r){if(a)return a;await i.create({accessToken:o,solanaAddress:n?.address})}else{if(!a)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.EMBEDDED_WALLET_CREATE_ERROR),Error("A user must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let t=m.getPrivyEthereumHDWallets(e).find((e=>e.walletIndex===r));if(t)return t;let{entropyId:n,entropyIdVerifier:s}=m.getEntropyDetailsFromAccount(m.getPrivyPrimaryWallet(e));await or.recoverPrimaryWallet(),await i.addWallet({accessToken:o,entropyId:n,entropyIdVerifier:s,chainType:"ethereum",hdWalletIndex:r})}return Jt(r,"ethereum")},Xt=async({user:e,wp:t,accessToken:r,walletIndex:a,ethereumWallet:n})=>{let i=m.getPrivySolanaHDWallets(e).find((e=>e.walletIndex===a));if(i)return i;if(0===a)await t.createSolana({accessToken:r,ethereumAddress:n?.address});else{let n=m.getPrivyPrimaryWallet(e);if(!n)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.EMBEDDED_WALLET_CREATE_ERROR),Error("User must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let{entropyId:i,entropyIdVerifier:o}=m.getEntropyDetailsFromAccount(n);await or.recoverPrimaryWallet(),await t.addWallet({accessToken:r,entropyId:i,entropyIdVerifier:o,chainType:"solana",hdWalletIndex:a})}return Jt(a,"solana")},Jt=async(e,t)=>{let r=await or.refreshUser(),a=("ethereum"===t?m.getPrivyEthereumHDWallets(r):m.getPrivySolanaHDWallets(r)).find((t=>t.walletIndex===e));if(!a)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");return he.emitPrivyEvent(Tt,"createWallet","onSuccess",a),a},Qt=(e,r,a,n)=>new Promise((async(i,s)=>{let{requesterAppId:l}=r||{};if(!Ce||!Ae)return he.emitPrivyEvent(Tt,"sendTransaction","onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED),void s(Error("User must be authenticated before signing with a Privy wallet"));let c=n??m.getPrivyEthereumWallet(Ae)?.address;if(!c)throw new j.PrivyClientError("User must have an embedded wallet to send a transaction.");let{signingWallet:d,rootWallet:u}=m.getEthereumSigningAndRootWallet(Ae,c);if(!u||!d)return he.emitPrivyEvent(Tt,"sendTransaction","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void s(Error("Must have a Privy wallet before signing"));dt(!0);let h=sr.wallets.find((e=>"privy"===e.walletClientType&&t.getAddress(e.address)===t.getAddress(d.address))),y=await(h?.getEthereumProvider());if(!h||!y)throw new j.PrivyClientError(`Cannot sendTransaction before embedded wallet ${d.address} is connected`);let p=e.chainId?Number(e.chainId):H.extractChainIdFromCAIP2(h.chainId);(e=>{if(!st.chains.map((e=>e.id)).includes(e))throw new j.PrivyConnectorError(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,j.PrivyErrorCode.UNSUPPORTED_CHAIN_ID)})(p);let w=Object.assign({},e,{chainId:p});if(Ut({showWalletUIs:r?.showWalletUIs}))(async()=>{let e=await Xe();if(!e||!it)return he.emitPrivyEvent(Tt,"sendTransaction","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void s(Error("Must have valid access token and Privy wallet to send transaction"));try{if(!await or.recoverPrimaryWallet())return he.emitPrivyEvent(Tt,"sendTransaction","onError",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),void s(Error("Unable to connect to wallet"));let t=P.getJsonRpcProvider(w.chainId,st.chains,st.rpcConfig,{appId:E.appId}),a=await o.populateTransactionRequest(d.address,w,t);if(Ut({showWalletUIs:r?.showWalletUIs})){let{totalGasEstimate:e}=await o.calculateTotalGasEstimate(a,t),{hasSufficientFunds:r}=await q.getAndCheckBalance(d.address,a,e,t);if(!r)throw new U.PrivyProviderRpcError(new U.ProviderRpcError("Wallet has insufficient funds for this transaction.",o.ProviderErrors.E32603_DEFAULT_INTERNAL_ERROR.eipCode))}let{entropyId:n,entropyIdVerifier:c}=m.getEntropyDetailsFromAccount(u),h=await q.sendTransaction({accessToken:e,entropyId:n,entropyIdVerifier:c,transactingWallet:d,walletProxy:it,transactionRequest:a,provider:t,requesterAppId:l});he.emitPrivyEvent(Tt,"sendTransaction","onSuccess",h),i(h)}catch(e){he.emitPrivyEvent(Tt,"sendTransaction","onError",j.PrivyErrorCode.TRANSACTION_FAILURE),s(e)}})();else{let{entropyId:e,entropyIdVerifier:t}=m.getEntropyDetailsFromAccount(u),n={entropyId:e,entropyIdVerifier:t,onCompleteNavigateTo:se.ModalScreen.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:e=>{he.emitPrivyEvent(Tt,"sendTransaction","onError",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}},o=X.isFundingEnabled(st)?ve.prepareFundingModalData({address:d.address,appConfig:st,fundWalletConfig:a,methodScreen:se.ModalScreen.FUNDING_METHOD_SELECTION_SCREEN,chainIdOverride:w.chainId,comingFromSendTransactionScreen:!0}):void 0;ht({connectWallet:n,sendTransaction:{transactionRequest:w,transactingWallet:d,entropyId:e,entropyIdVerifier:t,onSuccess:e=>{he.emitPrivyEvent(Tt,"sendTransaction","onSuccess",e),i(e)},onFailure:e=>{he.emitPrivyEvent(Tt,"sendTransaction","onError",j.PrivyErrorCode.TRANSACTION_FAILURE),s(e)},uiOptions:r||{},fundWalletConfig:a,requesterAppId:l},funding:o}),bt(se.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),Zt=({transaction:e,connection:t,transactionOptions:r,fundWalletConfig:a,uiOptions:n,wallet:i})=>new Promise((async(o,s)=>{let{requesterAppId:l}=n||{};if(!Ce||!Ae)return he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED),void s(new j.PrivyClientError("User must be authenticated before signing with a Privy wallet",j.PrivyErrorCode.MUST_BE_AUTHENTICATED));let c=i?Ae.linkedAccounts.find((e=>"wallet"===e.type&&e.address===i.address)):m.getPrivySolanaWallet(Ae);if(!c)return he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void s(new j.PrivyClientError("Must have a Privy wallet before signing",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND));dt(!0);let{rootWallet:d}=m.getSolanaSigningAndRootWallet(Ae,c.address);if(!await or.recoverPrimaryWallet().catch((()=>!1))||!d)throw he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),new j.PrivyClientError(`Cannot sendSolanaTransaction before embedded wallet ${c.address} is connected`,j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND);if(Ut({showWalletUIs:n?.showWalletUIs}))(async()=>{let a=await Xe();if(!a||!it)return he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void s(new j.PrivyClientError("Must have valid access token and Privy wallet to send transaction",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND));try{if(!await or.recoverPrimaryWallet())return he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),void s(new j.PrivyClientError("Unable to connect to wallet",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR));if(Ut({showWalletUIs:n?.showWalletUIs})){let{instructions:r}=await te.decodeSolanaTransaction(e,t);r.every((e=>e.hasFunds))||(he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.INSUFFICIENT_BALANCE),s(new j.PrivyClientError("Solana wallet has insufficient funds for this transaction.",j.PrivyErrorCode.INSUFFICIENT_BALANCE)))}let{entropyId:i,entropyIdVerifier:l}=m.getEntropyDetailsFromUser(Ae),{signature:d,receipt:u}=await B.sendSolanaTransaction({accessToken:a,tx:e,connection:t,walletProxy:it,transactionOptions:r,entropyId:i,entropyIdVerifier:l,transactingWalletAddress:c.address,transactingWalletIndex:c.walletIndex??0}),h=te.createSolanaTransactionReceipt(d,u);he.emitPrivyEvent(Tt,"sendSolanaTransaction","onSuccess",h),o(h)}catch(e){he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.TRANSACTION_FAILURE),s(e)}})();else{let{entropyId:i,entropyIdVerifier:u}=m.getEntropyDetailsFromAccount(d),h={entropyId:i,entropyIdVerifier:u,onCompleteNavigateTo:se.ModalScreen.EMBEDDED_WALLET_SEND_SOLANA_TRANSACTION_SCREEN,onFailure:e=>{he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}},y=X.isFundingEnabled(st)?ve.prepareSolanaFundingModalData({address:c.address,appConfig:st,methodScreen:se.ModalScreen.FUNDING_METHOD_SELECTION_SCREEN,fundWalletConfig:a,comingFromSendTransactionScreen:!0}):void 0;ht({connectWallet:h,sendSolanaTransaction:{transactionRequest:e,connection:t,transactionOptions:r,transactingWallet:c,onSuccess:e=>{he.emitPrivyEvent(Tt,"sendSolanaTransaction","onSuccess",e),o(e)},onFailure:e=>{he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.TRANSACTION_FAILURE),s(e)},uiOptions:n||{},requesterAppId:l},funding:y}),bt(se.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)}}));function er(){return new Promise((async(e,t)=>{let r=await Xe();if(!r||!it)throw Error("Must have valid access token to enroll in MFA");try{await it.verifyMfa({accessToken:r}),e()}catch(e){t(e)}}))}let tr=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],rr=e=>{let t=Ae?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:r,loginMethod:a}=re.toDisplayFromAccountType(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw he.emitPrivyEvent(Tt,"linkAccount","onError",j.PrivyErrorCode.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:a}),new j.PrivyClientError(`User already has an account of type ${r} linked.`)};async function ar({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){De(null);let r=t?"setWalletPassword":"setWalletRecovery";if(!Ce||!Ae)throw he.emitPrivyEvent(Tt,r,"onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let a=m.getPrivyPrimaryWallet(Ae);if(!a||!it)throw he.emitPrivyEvent(Tt,r,"onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");try{await er()}catch(e){throw he.emitPrivyEvent(Tt,r,"onError",j.PrivyErrorCode.MISSING_MFA_CREDENTIALS),e}return new Promise(((n,i)=>{dt(!0);let o={onSuccess:e=>{he.emitPrivyEvent(Tt,r,"onSuccess","user-passcode",e),n(e)},onFailure:e=>{he.emitPrivyEvent(Tt,r,"onError",j.PrivyErrorCode.USER_EXITED_SET_PASSWORD_FLOW),i(e)},callAuthOnSuccessOnClose:!1},s="user-passcode"===a.recoveryMethod,l=Y.toEmbeddedWalletSetRecoveryScreen({walletAction:"update",availableRecoveryMethods:st.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:s,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:d}=m.getEntropyDetailsFromAccount(a);ht({setWalletPassword:o,recoverWallet:{entropyId:c,entropyIdVerifier:d,onFailure:i},createWallet:o,connectWallet:{onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,entropyIdVerifier:d,onFailure:e=>{he.emitPrivyEvent(Tt,r,"onError",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}},recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:s}}),bt(se.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)}))}async function nr({appId:e,action:t}){let r=await Xe();if("link"===t&&!r)throw he.emitPrivyEvent(Tt,"linkAccount","onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new j.PrivyClientError("User must be authenticated before linking an account.");if("login"===t&&r)throw he.emitPrivyEvent(Tt,"login","onError",j.PrivyErrorCode.UNKNOWN_AUTH_ERROR),new j.PrivyClientError("Attempted to log in, but user is already logged in. Use a `link` helper instead.");St.current=`privy:${e}`,Nt.current=t;let a=Q.triggerPopup();return v.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(r,n)=>{let{name:i,logoUrl:o}=await V.getProviderAppMetadata({api:v.api,providerAppId:e,requesterAppId:st.id});ht({crossAppAuth:{appId:e,name:i,logoUrl:o,action:t,popup:a,onSuccess:r,onError:n}}),Ot(se.ModalScreen.CROSS_APP_AUTH_SCREEN)}))}let ir={ready:T,authenticated:Ce,user:Ae,walletConnectors:v.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),ht({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,suggestedAddress:e?.suggestedAddress}}),bt(Ce?se.ModalScreen.CONNECT_ONLY_AUTHENTICATED_SCREEN:se.ModalScreen.CONNECT_ONLY_LANDING_SCREEN)},linkWallet:Ht,startCrossAppAuthFlow:nr,linkEmail:()=>{Bt("email"),rr("email"),St.current="email",Nt.current="link",bt(se.ModalScreen.LINK_EMAIL_SCREEN)},linkPhone:()=>{Bt("sms"),rr("phone"),St.current="sms",Nt.current="link",bt(se.ModalScreen.LINK_PHONE_SCREEN)},linkGoogle:async()=>{Bt("google"),rr("google_oauth"),Nt.current="link",await or.initLoginWithOAuth("google")},linkTwitter:async()=>{Bt("twitter"),rr("twitter_oauth"),Nt.current="link",await or.initLoginWithOAuth("twitter")},linkDiscord:async()=>{Bt("discord"),rr("discord_oauth"),Nt.current="link",await or.initLoginWithOAuth("discord")},linkGithub:async()=>{Bt("github"),rr("github_oauth"),Nt.current="link",await or.initLoginWithOAuth("github")},linkSpotify:async()=>{Bt("spotify"),rr("spotify_oauth"),Nt.current="link",await or.initLoginWithOAuth("spotify")},linkInstagram:async()=>{Bt("instagram"),rr("instagram_oauth"),Nt.current="link",await or.initLoginWithOAuth("instagram")},linkTiktok:async()=>{Bt("tiktok"),rr("tiktok_oauth"),Nt.current="link",await or.initLoginWithOAuth("tiktok")},linkLinkedIn:async()=>{Bt("linkedin"),rr("linkedin_oauth"),Nt.current="link",await or.initLoginWithOAuth("linkedin")},linkApple:async()=>{Bt("apple"),rr("apple_oauth"),Nt.current="link",await or.initLoginWithOAuth("apple")},linkPasskey:async()=>{Bt("passkey"),rr("passkey"),await or.initLinkWithPasskey(),bt(se.ModalScreen.LINK_PASSKEY_SCREEN)},linkTelegram:async()=>{Bt("telegram"),rr("telegram"),Nt.current="link",St.current="telegram",await or.initLoginWithTelegram(),bt(se.ModalScreen.TELEGRAM_AUTH_SCREEN)},linkFarcaster:async()=>{Bt("farcaster"),rr("farcaster"),await or.initLoginWithFarcaster(),Nt.current="link",St.current="farcaster",bt(se.ModalScreen.AWAITING_FARCASTER_CONNECTION)},updateEmail:()=>{if(Bt("email"),!Ae?.email)throw new j.PrivyClientError("User does not have an email linked to their account.");Nt.current="update",St.current="email",bt(se.ModalScreen.UPDATE_EMAIL_SCREEN)},updatePhone:()=>{if(Bt("sms"),!Ae?.phone)throw new j.PrivyClientError("User does not have a phone number linked to their account.");Nt.current="update",St.current="sms",bt(se.ModalScreen.UPDATE_PHONE_SCREEN)},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!T){let e=await new Promise((e=>{pt((t=>e.bind(t)))}));if(pt(null),e)return void console.warn(t)}!Ae||Ae.isGuest?(Nt.current="login",ht({login:e}),Ot(se.ModalScreen.LANDING)):console.warn(t)},connectOrCreateWallet:async()=>{T||(await new Promise((e=>{pt((()=>e))})),pt(null)),Ce?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(Nt.current="login",Ot(se.ModalScreen.CONNECT_OR_CREATE))},logout:async()=>{if(Nt.current=null,St.current=null,Ae&&v.clearProviderAcccessTokens(Ae),De(null),await v.logout(),Ae&&it)try{await it.clearMfa({userId:Ae.id})}catch(e){}_e(null),Pe(!1),he.emitPrivyEvent(Tt,"logout","onSuccess"),_(!1),C.default.del(f.CLIENT_ANALYTICS_ID_KEY),C.default.del(f.getGuestCredentialStorageKey(st.id))},getAccessToken:()=>v.getCustomerAccessToken(),getEthereumProvider:()=>{if(!Ae||!Ae.wallet)return new R.PrivyProxyProvider;let e=Te.find((e=>Ae.wallet&&e.address===Ae.wallet.address)),t=v.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new R.PrivyProxyProvider},getEthersProvider:()=>{if(!Ae||!Ae.wallet)return new r.Web3Provider(new R.AsExternalProvider(new R.PrivyProxyProvider));let e=Te.find((e=>Ae.wallet&&e.address===Ae.wallet.address)),t=v.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new r.Web3Provider(new R.AsExternalProvider(e&&t?t.proxyProvider:new R.PrivyProxyProvider))},getWeb3jsProvider:()=>{if(!Ae||!Ae.wallet)return new R.AsAbstractProvider(new R.PrivyProxyProvider);let e=Te.find((e=>Ae.wallet&&e.address===Ae.wallet.address)),t=v.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new R.AsAbstractProvider(e&&t?t.proxyProvider:new R.PrivyProxyProvider)},unlinkWallet:async e=>{let t;return _e(t=e.startsWith("0x")?await v.unlinkEthereumWallet(e):await v.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await v.unlinkEmail(e);return _e(t),t},unlinkPhone:async e=>{let t=await v.unlinkPhone(e);return _e(t),t},unlinkGoogle:async e=>{let t=await v.unlinkOAuth("google",e);return _e(t),t},unlinkTwitter:async e=>{let t=await v.unlinkOAuth("twitter",e);return _e(t),t},unlinkDiscord:async e=>{let t=await v.unlinkOAuth("discord",e);return _e(t),t},unlinkGithub:async e=>{let t=await v.unlinkOAuth("github",e);return _e(t),t},unlinkSpotify:async e=>{let t=await v.unlinkOAuth("spotify",e);return _e(t),t},unlinkInstagram:async e=>{let t=await v.unlinkOAuth("instagram",e);return _e(t),t},unlinkTiktok:async e=>{let t=await v.unlinkOAuth("tiktok",e);return _e(t),t},unlinkLinkedIn:async e=>{let t=await v.unlinkOAuth("linkedin",e);return _e(t),t},unlinkApple:async e=>{let t=await v.unlinkOAuth("apple",e);return _e(t),t},unlinkFarcaster:async e=>{let t=await v.unlinkFarcaster(e);return _e(t),t},unlinkTelegram:async e=>{let t=await v.unlinkTelegram(e);return _e(t),t},unlinkPasskey:async e=>{let t=await v.unlinkPasskey(e);return _e(t),t},unlinkCrossAppAccount:async({subject:e})=>{let t=Ae?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new j.PrivyClientError("Invalid subject");v.storeProviderAccessToken(t.id,null);let r=await v.unlinkOAuth(`privy:${t.id}`,e);return _e(r),r},setActiveWallet:async e=>{let r=Te.find((r=>t.getAddress(r.address)===t.getAddress(e))),a=Ae?.linkedAccounts.find((r=>"wallet"===r.type&&t.getAddress(r.address)===t.getAddress(e)));if(r&&await r.isConnected())if(r.linked){let e=Object.assign({},Ae);e.wallet=a&&{address:a.address,chainType:a.chainType,chainId:a.chainId,walletClient:a.walletClient,walletClientType:a.walletClientType,connectorType:a.connectorType,imported:a.imported,delegated:a.delegated,walletIndex:a.walletIndex},_e(e)}else r.loginOrLink();else ht({externalConnectWallet:{suggestedAddress:e}}),Ht()},forkSession:()=>v.forkSession(),createWallet:async e=>{if(e&&"target"in e&&e&&(e=void 0),!Ce||!Ae)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return zt(Ae,15e3,e)},setWalletRecovery:async e=>ar({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>ar({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t,r)=>new Promise((async(a,n)=>{let{requesterAppId:i}=t||{};if(!Ce||!Ae)return he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=r??m.getPrivyEthereumWallet(Ae)?.address;if(!o)throw new j.PrivyClientError("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=m.getEthereumSigningAndRootWallet(Ae,o);if(!s||!l)return he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.INVALID_MESSAGE),void n(Error("Message must be a non-empty string"));dt(!0);let c=async()=>{if(!Ce)throw Error("User must be authenticated before signing with a Privy wallet");let t=await Xe();if(!it||!t||!await or.recoverPrimaryWallet())throw Error("Unable to connect to wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:r,entropyIdVerifier:a}=m.getEntropyDetailsFromAccount(l),{response:n}=await it.rpc({accessToken:t,entropyId:r,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"personal_sign",params:[e,s.address]}}),o=n.data;return v.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:s.address,requesterAppId:i}}),o};if(Ut({showWalletUIs:t?.showWalletUIs}))try{let e=await c();he.emitPrivyEvent(Tt,"signMessage","onSuccess",e),a(e)}catch(e){he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.UNABLE_TO_SIGN),n(e??new U.PrivyProviderRpcError("Unable to sign message"))}else{let{entropyId:r,entropyIdVerifier:i}=m.getEntropyDetailsFromAccount(l);ht({signMessage:{method:"personal_sign",data:e,confirmAndSign:c,onSuccess:e=>{he.emitPrivyEvent(Tt,"signMessage","onSuccess",e),a(e)},onFailure:e=>{he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:r,entropyIdVerifier:i,onCompleteNavigateTo:se.ModalScreen.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),bt(se.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),signTypedData:(e,t,r)=>new Promise((async(a,n)=>{let{requesterAppId:i}=t||{};if(!Ce||!Ae)return he.emitPrivyEvent(Tt,"signTypedData","onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=r??m.getPrivyEthereumWallet(Ae)?.address;if(!o)throw new j.PrivyClientError("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=m.getEthereumSigningAndRootWallet(Ae,o);if(!l||!s)return he.emitPrivyEvent(Tt,"signTypedData","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));dt(!0);let c=P.generateTypedDataWithDomainType(e),d=async()=>{if(!Ce)throw Error("User must be authenticated before signing with a Privy wallet");let e=await Xe();if(!it||!e||!await or.recoverPrimaryWallet())throw Error("Unable to connect to wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:t,entropyIdVerifier:r}=m.getEntropyDetailsFromAccount(l),{response:a}=await it.rpc({accessToken:e,entropyId:t,entropyIdVerifier:r,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"eth_signTypedData_v4",params:[s.address,c]}}),n=a.data;return v.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:s.address,requesterAppId:i}}),n};if(Ut({showWalletUIs:t?.showWalletUIs,typedData:!0}))try{let e=await d();he.emitPrivyEvent(Tt,"signTypedData","onSuccess",e),a(e)}catch(e){he.emitPrivyEvent(Tt,"signTypedData","onError",j.PrivyErrorCode.UNABLE_TO_SIGN),n(e??new U.PrivyProviderRpcError("Unable to sign message"))}else{let{entropyId:e,entropyIdVerifier:r}=m.getEntropyDetailsFromAccount(l);ht({signMessage:{method:"eth_signTypedData_v4",data:c,confirmAndSign:d,onSuccess:e=>{he.emitPrivyEvent(Tt,"signTypedData","onSuccess",e),a(e)},onFailure:e=>{he.emitPrivyEvent(Tt,"signTypedData","onError",j.PrivyErrorCode.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:e,entropyIdVerifier:r,onCompleteNavigateTo:se.ModalScreen.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),bt(se.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),sendTransaction:async(e,t,r,a)=>{let n=await Qt(e,t,r,a);return q.formatReceipt(await n.wait())},sendSolanaTransaction:async(e,t,r,a,n,i)=>{let o=i?Ie.find((({address:e})=>e===i)):Ie.slice().sort(((e,t)=>(e.walletIndex??0)-(t.walletIndex??0)))[0];if(!o)throw he.emitPrivyEvent(Tt,"sendSolanaTransaction","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),new j.PrivyClientError("Embedded wallet not found",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND);return await Zt({transaction:e,connection:t,transactionOptions:a,uiOptions:r,fundWalletConfig:n,wallet:o})},exportWallet:e=>new Promise((async(t,r)=>{if(!Ce||!Ae)return void r(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let a=e?.address??m.getPrivyEthereumWallet(Ae)?.address;if(!a)return void r(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));let{signingWallet:n,rootWallet:i}=m.getEthereumSigningAndRootWallet(Ae,a);if(!n||!i)return void r(Error("Must have a Privy wallet before exporting"));dt(!0);let{entropyId:o,entropyIdVerifier:s}=m.getEntropyDetailsFromAccount(i),l={entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:se.ModalScreen.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:r,shouldForceMFA:!0};ht(ut),await Xe()&&it?it?(ht({keyExport:{appId:E.appId,appClientId:E.clientId,origin:v.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:r},connectWallet:l}),bt(se.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)):r(Error("Must have a Privy wallet before exporting")):r(Error("Must have valid access token to enroll in MFA"))})),promptMfa:er,async init(e){switch(e){case"sms":return void await v.initMfaSmsVerification();case"passkey":return await v.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new j.PrivyClientError("Invalid MFA code");At.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{_t.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new j.PrivyClientError("Invalid authenticator response");let r=await import("@simplewebauthn/browser"),a=ae.transformResponseToSnakeCase(await r.startAuthentication(t));At.current?.resolve({mfaMethod:e,mfaCode:a,relyingParty:window.origin}),await new Promise(((e,t)=>{_t.current={resolve:e,reject:t}}));break;default:throw At.current?.reject(new j.PrivyClientError("Unsupported MFA method")),new j.PrivyClientError(`Unsupported MFA method: ${e}`)}},cancel(){At.current?.reject(new j.PrivyClientError("MFA canceled"))},async initEnrollmentWithSms(e){let t=await Xe();if(!t||!it)throw Error("Must have valid access token to enroll in MFA");await it.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,r)=>{if(!e)return or.closePrivyModal(),void t();st.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),ht({mfaEnrollmentFlow:{mfaMethods:st.mfa.methods,onSuccess:t,onFailure:r}}),bt(se.ModalScreen.MFA_ENROLLMENT_FLOW_SCREEN)})),async initEnrollmentWithTotp(){let e=await Xe();if(!e||!it)throw Error("Must have valid access token to enroll in MFA");let t=await it.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await Xe();if(!t||!it)throw Error("Must have valid access token to enroll in MFA");await it.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),_e(await v.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await Xe();if(!t||!it)throw Error("Must have valid access token to enroll in MFA");await it.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),_e(await v.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e}){let t=await Xe();if(!t||!it)throw Error("Must have valid access token to enroll in MFA");await it.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:e}),_e(await v.getAuthenticatedUser())},async unenroll(e){let t=await Xe();if(!t||!it)throw Error("Must have valid access token to remove MFA");"passkey"===e?await it.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:[]}):await it.unenrollMfa({method:e,accessToken:t}),_e(await v.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await Xe(),t=Ae?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!it||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(!Ae?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await or.recoverPrimaryWallet())throw Error("Unable to connect to wallet");let r=await it.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===r.status&&_e(await v.getAuthenticatedUser()||Ae||null),ht({farcasterSigner:r}),bt(se.ModalScreen.AWAITING_FARCASTER_SIGNER)},getFarcasterSignerPublicKey:async()=>{let e,t=await Xe(),r=Ae?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!it||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!Ae?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await or.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!Ae.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=Ae.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await Xe(),r=Ae?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!it||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!Ae?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await or.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!Ae.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let a=await import("@simplewebauthn/browser"),n=await it.signFarcasterMessage({address:r.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:a.bufferToBase64URLString(e)},fid:BigInt(Ae.farcaster.fid),relyingParty:window.origin});return new Uint8Array(a.base64URLStringToBuffer(n.signature))},createGuestAccount:async()=>{if(Ae&&!Ae.isGuest)throw Error("User cannot already be authenticated to create a guest account");return Ae?.isGuest?Ae:or.loginWithGuestAccountFlow()},signMessageWithCrossAppWallet(e,{address:t}){let r=Ae?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return z.sendCrossAppRequest({user:Ae,client:v,address:t,requesterAppId:st.id,request:{method:r?"privy_signSmartWalletMessage":"personal_sign",params:[e,t]},reconnect:nr})},signTypedDataWithCrossAppWallet(e,{address:t}){let r=Ae?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),a=P.generateTypedDataWithDomainType(e);return z.sendCrossAppRequest({user:Ae,client:v,address:t,requesterAppId:st.id,request:{method:r?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,a]},reconnect:nr})},sendTransactionWithCrossAppWallet(e,{address:t}){let r=Ae?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return z.sendCrossAppRequest({user:Ae,client:v,address:t,requesterAppId:st.id,request:{method:r?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e]},reconnect:nr})},isModalOpen:A,mfaMethods:st.mfa.methods};Ke=ir.signMessage,Ve=ir.signTypedData,Ge=async(...e)=>{let t=await Qt(...e);return st.embeddedWallets.waitForTransactionConfirmation&&await t.wait(),t};let or={setAuthenticated:Pe,setUser:_e,isNewUserThisSession:be,pendingTransaction:null,walletConnectionStatus:Fe,connectors:v.connectors?.walletConnectors??[],solanaWallets:Ie,rpcConfig:st.rpcConfig,chains:st.chains,appId:E.appId,showFiatPrices:"native-token"!==st.embeddedWallets.priceDisplay.primary,clientAnalyticsId:v.clientAnalyticsId,customAuthStatus:Ct,noPromptOnSignature:kt,emailOtpState:Je,setEmailOtpState:Qe,smsOtpState:Ze,setSmsOtpState:et,oAuthState:at,setOAuthState:nt,siweState:tt,setSiweState:rt,isHeadlessOAuthLoading:Me,nativeTokenSymbolForChainId:e=>st.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(it)return it;let t=new Promise((e=>{Et((()=>t=>e(t)))})),r=new Promise((t=>setTimeout((()=>t(null)),e))),a=await Promise.race([t,r]);return Et(null),a},getAuthFlow:()=>v.authFlow,getAuthMeta:()=>v.authFlow?.meta,client:v,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,r=T&&Ce&&Ae;r&&St.current&&(t=tr(Ae)),"login"===Nt.current?e.shouldCallAuthOnSuccess&&r&&St.current?(he.emitPrivyEvent(Tt,"login","onComplete",Ae,be,!1,St.current,t??null),E.onSuccess?.(Ae,be)):he.emitPrivyEvent(Tt,"login","onError",j.PrivyErrorCode.USER_EXITED_AUTH_FLOW):"link"===Nt.current&&t?e.isSuccess&&r&&St.current?he.emitPrivyEvent(Tt,"linkAccount","onSuccess",Ae,St.current,t):St.current&&he.emitPrivyEvent(Tt,"linkAccount","onError",j.PrivyErrorCode.USER_EXITED_LINK_FLOW,{linkMethod:St.current}):"update"===Nt.current&&t&&(e.isSuccess&&r&&St.current?he.emitPrivyEvent(Tt,"update","onSuccess",Ae,St.current,t):St.current&&he.emitPrivyEvent(Tt,"update","onError",j.PrivyErrorCode.USER_EXITED_UPDATE_FLOW,{linkMethod:St.current}));let a=Re&&$.FUNDING_SCREENS.includes(Re),n=Re===se.ModalScreen.ERROR_SCREEN&&ut.errorModalData&&$.FUNDING_SCREENS.includes(ut.errorModalData.previousScreen);if((a||n)&&ut.funding){let e,t=$.fundingScreenMethodMap[Re]??null;if("solana"===ut.funding.chainType){let r=g(ie.SOLANA_FUNDING_PLUGIN_ID);if(!r)return void console.warn("Unable to load solana plugin, skipping balance");try{e=BigInt(await r.getBalance({address:ut.funding.address,cluster:ut.funding.cluster}))}catch{console.error("Unable to pull wallet balance")}he.emitPrivyEvent(Tt,"fundSolanaWallet","onUserExited",{address:ut.funding.address,cluster:ut.funding.cluster,fundingMethod:t,balance:e})}else{let r=P.getJsonRpcProvider(ut.funding.chain.id,st.chains,st.rpcConfig,{appId:E.appId});try{e=(await r.getBalance(ut.funding.address)).toBigInt()}catch{console.error("Unable to pull wallet balance")}he.emitPrivyEvent(Tt,"fundWallet","onUserExited",{address:ut.funding.address,chain:ut.funding.chain,fundingMethod:t,balance:e})}}ht({...ut,externalConnectWallet:{suggestedAddress:void 0}}),Nt.current=null,St.current=null,Oe(!1),_(!1),setTimeout((()=>{v.authFlow=void 0}),200),v.createAnalyticsEvent({eventName:"modal_closed"})},solanaSignMessage:({message:e,address:t})=>new Promise((async(r,a)=>{if(!Ce||!Ae)return he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED),void a(Error("User must be authenticated before signing with a Privy wallet"));let n=t??m.getPrivySolanaWallet(Ae)?.address;if(!n)throw new j.PrivyClientError("User must have an embedded wallet to sign a message.");let{signingWallet:i,rootWallet:o}=m.getSolanaSigningAndRootWallet(Ae,n);if(!i||!o)return he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void a(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.INVALID_MESSAGE),void a(Error("Message must be a non-empty string"));dt(!0);let s=async()=>{if(!Ce)throw Error("User must be authenticated before signing with a Privy wallet");let t=await v.getAccessToken();if(!t)throw Error("User must be authenticated to use their embedded wallet.");let r=or.walletProxy??await or.initializeWalletProxy(15e3);if(!r)throw Error("Failed to initialize embedded wallet proxy.");if(!await or.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!o)throw Error("No root wallet for signing wallet found");let{entropyId:a,entropyIdVerifier:n}=m.getEntropyDetailsFromAccount(o),{response:s}=await r.rpc({accessToken:t,entropyId:a,entropyIdVerifier:n,chainType:"solana",hdWalletIndex:i.walletIndex??0,request:{method:"signMessage",params:{message:e}}});return s.data.signature};if(Ut({showWalletUIs:void 0}))try{let e=await s();r({signature:e})}catch(e){a(e)}else{let{entropyId:t,entropyIdVerifier:n}=m.getEntropyDetailsFromAccount(o);ht({signMessage:{method:"solana_signMessage",data:e,confirmAndSign:s,onSuccess:e=>{r({signature:e})},onFailure:e=>{a(e)},uiOptions:{}},connectWallet:{entropyId:t,entropyIdVerifier:n,onCompleteNavigateTo:se.ModalScreen.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{he.emitPrivyEvent(Tt,"signMessage","onError",j.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),a(e)}}}),Ot(se.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),openPrivyModal:bt,connectWallet:Ft,initLoginWithWallet:async(e,t,r)=>{O.isBaseConnectedEthereumWallet(e)?(St.current="siwe",xt(e,t,r)):(St.current="siws",qt(e,t))},loginWithWallet:async()=>{let e,t,r;if(!T)throw new j.PrivyNotReadyError;if(v.authFlow instanceof h.SiweFlow?e="siwe":v.authFlow instanceof y.SiwsFlow&&(e="siws"),!e)throw new j.PrivyClientError("Must initialize SIWE/SIWS flow first.");if(null!==await v.getAccessToken())try{({user:t}=await v.link()),St.current=e}catch(t){throw he.emitPrivyEvent(Tt,"linkAccount","onError",t.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:r}=await v.authenticate()),St.current=e}catch(e){throw he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.GENERIC_CONNECT_WALLET_ERROR),e}_e(t||Ae||null),Oe(r||!1),Pe(!0)},delegateWallet:async({address:e,chainType:t})=>new Promise((async(r,a)=>{let n=await Xe();if(!Ce||!Ae||!n)throw new j.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new j.PrivyClientError("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let i=or.walletProxy??await or.initializeWalletProxy(15e3);if(!i)throw new j.PrivyClientError("Wallet proxy not initialized.");if(F.isWalletDelegated({address:e,chainType:t,user:Ae}))return r();let o=F.getDelegatedWalletsData({address:e,user:Ae}),s=F.getRootWalletDataForDelegation({address:e,user:Ae});await or.recoverPrimaryWallet(),ht({delegatedActions:{consent:{address:e,onDelegate:async()=>{await i.createDelegatedAction({accessToken:n,rootWallet:s,delegatedWallets:[o]}),await or.refreshUser()},onSuccess:async()=>{r()},onError:async e=>{a(e)}}}}),bt(se.ModalScreen.EMBEDDED_WALLET_DELEGATED_ACTIONS_CONSENT_SCREEN)})),revokeDelegatedWallets:async()=>new Promise((async(e,t)=>{if(!Ce||!Ae)throw new j.PrivyClientError("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");if(0===F.getDelegatedWalletsForUser(Ae).length)throw new j.PrivyClientError("User has no delegated wallets to revoke.");ht({delegatedActions:{revoke:{onRevoke:async()=>{await v.revokeDelegatedWallet(),await or.refreshUser()},onSuccess:async()=>{e()},onError:async e=>{t(e)}}}}),bt(se.ModalScreen.EMBEDDED_WALLET_DELEGATED_ACTIONS_REVOKE_SCREEN)})),initLoginWithFarcaster:async(e,t)=>{let r=new c.FarcasterFlow(e,t);v.startAuthFlow(r);try{St.current="farcaster",await r.initializeFarcasterConnect()}catch(e){throw"login"===Nt.current?he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR):"link"===Nt.current&&he.emitPrivyEvent(Tt,"linkAccount","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!T)throw new j.PrivyNotReadyError;if(!(v.authFlow instanceof c.FarcasterFlow))throw new j.PrivyClientError("Must initialize Farcaster flow first.");if(null!==await v.getAccessToken())try{({user:e}=await v.link()),St.current="farcaster"}catch(e){throw he.emitPrivyEvent(Tt,"linkAccount","onError",e.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await v.authenticate()),St.current="farcaster"}catch(e){throw he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}_e(e||null),Oe(t||!1),Pe(!0)},async loginWithGuestAccountFlow(){let e=new d.GuestFlow(this.appId);v.startAuthFlow(e);try{Nt.current="login",St.current="guest";let{user:e,isNewUser:t}=await v.authenticate();if(t=t||!1,!e)throw new j.PrivyClientError("Unable to authenticate guest account");if(m.shouldProceedtoEmbeddedWalletCreationFlow(e,st.embeddedWallets.createOnLogin))try{await zt(e,15e3),e=await or.refreshUser()}catch(t){_e(e),console.warn("Unable to create embedded wallet for guest account")}else _e(e);return Oe(t),Pe(!0),he.emitPrivyEvent(Tt,"login","onComplete",e,t,!1,"guest",null),e}catch(e){throw he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}},async crossAppAuthFlow({appId:e,popup:t,action:r}){let a=`privy:${e}`;St.current=a;let{url:n,stateCode:i,codeVerifier:o}=await V.getCrossAppAuthorizationUrl({api:v.api,appId:e});if(!n)throw v.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new j.PrivyClientError("No authorization URL returned for cross-app auth.");try{let s=await G.popupCrossAppAuthFlow({url:n,popup:t,provider:a}),l=s.stateCode,c=s.authorizationCode;if(l!==i)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:a,storedStateCode:i??"",returnedStateCode:l??""}}),new j.PrivyClientError("Unexpected auth flow. This may be a phishing attempt.",void 0,j.PrivyErrorCode.OAUTH_UNEXPECTED);let d=await V.authenticateCrossAppAccount({appId:e,codeVerifier:o,stateCode:l,authorizationCode:c,action:r,client:v});d&&v.storeProviderAccessToken(e,d);let u=await or.refreshUser();if(!u)throw new j.PrivyClientError("Unable to update user");return v.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),u}catch(e){throw v.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:a}}),e}},async initLoginWithOAuth(e,t,r){if(St.current=e,!C.isLocalStorageAccessible())return void Ot(se.ModalScreen.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);if("google"===e&&J.default(window.navigator.userAgent))return void Ot(se.ModalScreen.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);"twitter"===e&&window.opener&&window.opener.postMessage({type:K.USE_BROADCAST_CHANNEL_EVENT_TYPE},"*"),C.default.del(f.HEADLESS_OAUTH_KEY),C.default.del(f.OAUTH_DISABLE_SIGNUP_KEY);let a=new ge.OAuthFlow({provider:e,disableSignup:!!r,withPrivyUi:!0});t&&a.addCaptchaToken(t),v.startAuthFlow(a);let n=await v.authFlow.getAuthorizationUrl();n&&n.url&&("twitter"===e&&i.isAndroid&&(n.url=n.url.replace("x.com","twitter.com")),window.location.assign(n.url))},async initLoginWithTelegram(e,t){if(!T)throw new j.PrivyNotReadyError;St.current="telegram";let r=new w.TelegramAuthFlow(e,t);v.startAuthFlow(r),r.meta.telegramWebAppData=void 0,r.meta.telegramAuthResult=await new Promise(((e,t)=>st.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:st.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(r=>r?e(r):t(new j.PrivyClientError("Telegram auth failed or was canceled by the client")))):t(new j.PrivyClientError("Telegram was not initialized")):t(new j.PrivyClientError("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,r;if(!(v.authFlow instanceof w.TelegramAuthFlow))throw new j.PrivyClientError("Must initialize Telegram flow before calling loginWithTelegram");if(v.authFlow.meta.captchaToken||=e,"login"===Nt.current)try{let e=await v.authenticate();t=e.user,r=e.isNewUser,St.current="telegram"}catch(e){throw he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}else{if("link"!==Nt.current)throw new j.PrivyClientError("Unknown auth intent");try{t=(await v.link()).user,St.current="telegram"}catch(e){throw he.emitPrivyEvent(Tt,"linkAccount","onError",e.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}_e(t),Oe(r||!1),Pe(!0)},async recoveryOAuthFlow(e,t,r){let a,n;function i(t){if(!t)throw v.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:e}}),new j.PrivyClientError("Recovery OAuth failed")}switch(e){case"google-drive":{let t,o,{url:s,codeVerifier:l,stateCode:c}=await Y.getRecoveryAuthorizationUrl({api:He.api,provider:e});i(s);try{let a=await Z.popupOAuthFlow({url:s,popup:r,provider:e});if(t=a.stateCode,o=a.authorizationCode,t!==c)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:c??"",returnedStateCode:t??""}}),new j.PrivyClientError("Unexpected auth flow. This may be a phishing attempt.",void 0,j.PrivyErrorCode.OAUTH_UNEXPECTED)}catch(t){throw v.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:t.toString(),provider:e}}),new j.PrivyClientError("Recovery OAuth failed")}[a,n]=await Promise.all([Xe(),Y.authenticateRecovery({api:He.api,provider:e,codeVerifier:l,stateCode:t,authorizationCode:o})]);break}case"icloud":{let{url:t}=await Y.getRecoveryAuthorizationUrl({api:He.api,provider:e});i(t);let{ckWebAuthToken:o}=await Z.popupOAuthFlow({url:t,popup:r,provider:e});n=o,a=await Xe()}}if(!it)throw new j.PrivyClientError("Cannot connect to wallet proxy");if(!a)throw new j.PrivyClientError("Unable to authorize user");switch(t){case"recover":{let t=ut.recoverWallet?.entropyId,r=ut.recoverWallet?.entropyIdVerifier;if(!t||!r)throw new j.PrivyClientError("Recovery OAuth failed");v.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:t,recoveryMethod:e}}),await it.recover({accessToken:a,entropyId:t,entropyIdVerifier:r,recoveryAccessToken:n}),v.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:t,recoveryMethod:e}});break}case"create-wallet":{v.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),await it.create({accessToken:a,recoveryAccessToken:n,recoveryMethod:e});let t=m.getPrivyEthereumWallet(await or.refreshUser());if(!t)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:t.address}}),he.emitPrivyEvent(Tt,"createWallet","onSuccess",t);break}case"set-recovery":{let t=m.getPrivyPrimaryWallet(Ae);if(!t)throw he.emitPrivyEvent(Tt,"setWalletRecovery","onError",j.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");v.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}});let{entropyId:r,entropyIdVerifier:i}=m.getEntropyDetailsFromAccount(t);await it.setRecovery({accessToken:a,entropyId:r,entropyIdVerifier:i,recoveryMethod:e,recoveryAccessToken:n});let o=m.getPrivyPrimaryWallet(await or.refreshUser());if(!o)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}}),he.emitPrivyEvent(Tt,"setWalletRecovery","onSuccess",e,o);break}default:throw new j.PrivyClientError("Unsupported recovery action")}},async loginWithOAuth(e){let t,r,a;if(!(v.authFlow instanceof ge.OAuthFlow))throw new j.PrivyClientError("Must initialize OAuth flow before calling loginWithOAuth");let n=C.default.get(f.STATE_CODE_KEY),i=v.authFlow.meta.stateCode;if(n!==i)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:n??"",returnedStateCode:i??""}}),new j.PrivyClientError("Unexpected auth flow. This may be a phishing attempt.",void 0,j.PrivyErrorCode.OAUTH_UNEXPECTED);if(null!==await v.getAccessToken())try{let r=await v.link();t=r.user,a=r.oAuthTokens,St.current=e}catch(t){throw he.emitPrivyEvent(Tt,"linkAccount","onError",t.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let n=await v.authenticate();t=n.user,r=n.isNewUser,a=n.oAuthTokens,St.current=e}catch(t){throw"login"===Nt.current?he.emitPrivyEvent(Tt,"login","onError",t.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR):"link"===Nt.current&&he.emitPrivyEvent(Tt,"linkAccount","onError",t.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return _e(t),Oe(r||!1),Pe(!0),a&&t&&he.emitPrivyEvent(Tt,"oAuthAuthorization","onOAuthTokenGrant",a,{user:t}),a},passkeyAuthState:qe,setPasskeyAuthState:je,async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let r=new u.PasskeyFlow({captchaToken:e,setPasskeyAuthState:je});v.startAuthFlow(r),Nt.current="login";try{St.current="passkey",je({status:"generating-challenge"}),await r.initAuthenticationFlow(t),je({status:"awaiting-passkey"})}catch(e){throw je({status:"error",error:e}),he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(){let e,t;if(!T)throw new j.PrivyNotReadyError;if(!(v.authFlow instanceof u.PasskeyFlow))throw new j.PrivyClientError("Must initialize Passkey flow first.");if("passkey"!==St.current){let e=new j.PrivyClientError("Must init login with Passkey flow first.");throw je({status:"error",error:e}),e}let r=await Xe();try{St.current="passkey",je({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await v.authenticate())}catch(e){throw je({status:"error",error:e}),he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}_e(e),Oe(t||!1),Pe(!0),je({status:"done"});let a=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!r,loginAccount:a}},async initLinkWithPasskey(e){let t=new u.PasskeyFlow({captchaToken:e});v.startAuthFlow(t),Nt.current="link",St.current="passkey",je({status:"generating-challenge"});try{await t.initLinkFlow(),je({status:"awaiting-passkey"})}catch(e){throw he.emitPrivyEvent(Tt,"linkAccount","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),je({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!T)throw new j.PrivyNotReadyError;if(!(v.authFlow instanceof u.PasskeyFlow))throw new j.PrivyClientError("Must initialize Passkey flow first.");if("passkey"!==St.current)throw new j.PrivyClientError("Must init login with Passkey flow first.");try{St.current="passkey",({user:e}=await v.link())}catch(e){throw he.emitPrivyEvent(Tt,"linkAccount","onError",e.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return _e(e||Ae||null),je({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,r){if(!C.isLocalStorageAccessible())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&J.default(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let a=new ge.OAuthFlow({provider:e,withPrivyUi:!1,disableSignup:r??!1});t&&a.addCaptchaToken(t),nt({status:"loading"});let n=await v.startAuthFlow(a).getAuthorizationUrl();n?.url&&window.location.assign(n.url)},async loginWithHeadlessOAuth(e){let t,r,a;Le(!0),nt({status:"loading"}),v.startAuthFlow(new ge.OAuthFlow(e));let n=C.default.get(f.STATE_CODE_KEY),i=e.stateCode;if(n!==i)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:n??"",returnedStateCode:i??""}}),Le(!1),new j.PrivyClientError("Unexpected auth flow. This may be a phishing attempt.",void 0,j.PrivyErrorCode.OAUTH_UNEXPECTED);if(null!==await v.getAccessToken())try{({user:t,oAuthTokens:a}=await v.link()),St.current=e.provider;let r=tr(t);t&&r&&he.emitPrivyEvent(Tt,"linkAccount","onSuccess",t,St.current,r)}catch(t){throw Le(!1),he.emitPrivyEvent(Tt,"linkAccount","onError",t.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:r,oAuthTokens:a}=await v.authenticate()),St.current=e.provider;let n=tr(t);t&&n&&void 0!==r&&he.emitPrivyEvent(Tt,"login","onComplete",t,r,!1,St.current,n)}catch(e){throw Le(!1),nt({status:"error",error:e}),he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}return _e(t),Oe(r||!1),Pe(!0),Le(!1),nt({status:"done"}),a&&t&&he.emitPrivyEvent(Tt,"oAuthAuthorization","onOAuthTokenGrant",a,{user:t}),t??void 0},initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:r,withPrivyUi:a})=>{let n=new l.EmailFlow({email:e,captchaToken:t,disableSignup:r});v.startAuthFlow(n);try{St.current="email",Qe({status:"sending-code"}),await n.sendCodeEmail({withPrivyUi:a}),Qe({status:"awaiting-code-input"})}catch(e){throw Qe({status:"error",error:e}),"login"===Nt.current?he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR):"link"===Nt.current&&he.emitPrivyEvent(Tt,"linkAccount","onError",e.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async(e,t,r)=>{let a=new l.UpdateEmailFlow(e,t,r);v.startAuthFlow(a);try{await a.sendCodeEmail({withPrivyUi:!0})}catch(e){he.emitPrivyEvent(Tt,"update","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:St.current})}},initUpdatePhone:async(e,t,r)=>{let a=new p.UpdateSmsFlow(e,t,r);v.startAuthFlow(a);try{await a.sendSmsCode({withPrivyUi:!0})}catch(e){he.emitPrivyEvent(Tt,"update","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:St.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:r,withPrivyUi:a})=>{et({status:"sending-code"});let n=new p.SmsFlow({phoneNumber:e,captchaToken:t,disableSignup:r});v.startAuthFlow(n);try{St.current="sms",await n.sendSmsCode({withPrivyUi:a}),et({status:"awaiting-code-input"})}catch(e){throw et({status:"error",error:e}),"login"===Nt.current?he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR):"link"===Nt.current&&he.emitPrivyEvent(Tt,"linkAccount","onError",e.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(v.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(v.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,r;function a(e){v.authFlow instanceof l.EmailFlow?Qe(e):v.authFlow instanceof p.SmsFlow&&et(e)}if(a({status:"submitting-code"}),!T){let e=new j.PrivyNotReadyError;throw a({status:"error",error:e}),e}if(v.authFlow instanceof l.EmailFlow)v.authFlow.meta.emailCode=e.trim();else{if(!(v.authFlow instanceof p.SmsFlow)){let e=new j.PrivyClientError("Must initialize a passwordless code flow first");throw a({status:"error",error:e}),e}v.authFlow.meta.smsCode=e.trim()}let n=await Xe();if("link"===Nt.current)try{({user:t}=await v.link())}catch(e){throw a({status:"error",error:e}),he.emitPrivyEvent(Tt,"linkAccount","onError",e.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:St.current}),e}else if("update"===Nt.current)try{({user:t}=await v.link())}catch(e){throw a({status:"error",error:e}),he.emitPrivyEvent(Tt,"update","onError",e.privyErrorCode||j.PrivyErrorCode.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:St.current}),e}else try{({user:t,isNewUser:r}=await v.authenticate())}catch(e){throw a({status:"error",error:e}),he.emitPrivyEvent(Tt,"login","onError",e.privyErrorCode||j.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}let i=t||Ae;_e(i||null),Oe(r||!1),Pe(!0),a({status:"done"});let o=null;return v.authFlow instanceof l.EmailFlow?o=i?.linkedAccounts.find((({type:e})=>"email"===e))||null:v.authFlow instanceof p.SmsFlow&&(o=i?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:i,isNewUser:r||!1,wasAlreadyAuthenticated:!!n,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:r})=>{Nt.current="link",St.current="siwe",rt({status:"generating-message"});let a=await v.generateSiweNonce({address:e,captchaToken:r});return rt({status:"awaiting-signature"}),ee.prepareSiweMessageWithNonce({address:e,chainId:t.replace("eip155:",""),nonce:a})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let r=await v.generateSiweNonce({address:e});return ee.prepareSiweMessageWithNonce({address:e,chainId:t.replace("eip155:",""),nonce:r})},linkSmartWallet:async({message:e,signature:t,smartWalletType:r})=>{let a;a=await v.linkSmartWallet({message:e,signature:t,smartWalletType:r}),_e((a=await or.refreshUser()??a)||Ae||null)},linkWithSiwe:async({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n})=>{let i;Bt("siwe");let o=null;try{rt({status:"submitting-signature"}),i=await v.linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}),i=await or.refreshUser()??i,rt({status:"done"}),(o=tr(i)||null)&&he.emitPrivyEvent(Tt,"linkAccount","onSuccess",i,"siwe",o)}catch(e){throw he.emitPrivyEvent(Tt,"linkAccount","onError",e.privyErrorCode||j.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),Nt.current=null,St.current=null,rt({status:"error",error:e}),e}let s=i||Ae;return _e(s||null),Nt.current=null,St.current=null,{user:s,linkedAccount:o}},refreshUser:async()=>{let e=await v.getAuthenticatedUser();return Pe(!!e),_e(e),e},walletProxy:it,createAnalyticsEvent:({eventName:e,payload:t,timestamp:r})=>v.createAnalyticsEvent({eventName:e,payload:t,timestamp:r}),acceptTerms:async()=>{let e=await v.acceptTerms();return _e(e),e},getUsdTokenPrice:e=>v.getUsdTokenPrice(e),getUsdPriceForSol:()=>v.getUsdPriceForSol(),recoverPrimaryWallet:async e=>new Promise((async(t,r)=>{let a=m.getPrivyPrimaryWallet(e?.user??Ae)||m.getImportedPrivyEthereumWallet(e?.user??Ae)||m.getImportedPrivySolanaWallet(e?.user??Ae),n=await Xe();if(!n||!it||!a)return void r(Error("Must have valid access token and Privy wallet to recover wallet"));dt(!0);let{entropyId:i,entropyIdVerifier:o}=m.getEntropyDetailsFromAccount(a);try{await it.connect({accessToken:n,entropyId:i,entropyIdVerifier:o}),t(!0)}catch(e){x.errorIndicatesRecoveryIsNeeded(e)&&"privy"===a.recoveryMethod?(v.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:a.address}}),(await it.recover({entropyId:i,entropyIdVerifier:o,accessToken:n})).entropyId||r(Error("Unable to recover wallet")),v.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:a.address}}),t(!0)):x.errorIndicatesRecoveryIsNeeded(e)&&"privy"!==a.recoveryMethod?(ht({recoverWallet:{entropyId:i,entropyIdVerifier:o,onFailure:r,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:a.recoveryMethod,action:"recover"}}),bt(Y.embeddedWalletRecoveryScreen(a.recoveryMethod))):r(e)}})),createEmbeddedSolanaWallet:async e=>{if(e&&"target"in e&&(e=void 0),!Ce||!Ae)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return(async(e,t,r)=>{let a=m.getPrivyEthereumWallet(e),n=m.getPrivySolanaWallet(e),i=r&&"createAdditional"in r&&r.createAdditional,o=r&&"walletIndex"in r?r.walletIndex:void 0,s=(m.getLatestPrivySolanaWallet(e)?.walletIndex??-1)+1;if(n&&!i&&"number"!=typeof o)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");if("number"==typeof o&&o<0)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${o}) is invalid.`);let[l,c]=await Promise.all([or.initializeWalletProxy(t),Xe()]);if(!l||!c)throw he.emitPrivyEvent(Tt,"createWallet","onError",j.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return await Xt({user:e,wp:l,accessToken:c,walletIndex:o??s,ethereumWallet:a})})(Ae,15e3,e)},exportSolanaWallet:e=>new Promise((async(t,r)=>{if(!Ce||!Ae)return void r(Error("User must be authenticated before exporting their Privy wallet"));let a=e?.address??m.getPrivySolanaWallet(Ae)?.address;if(!a)return void r(Error("User does not have an HD Solana wallet."));let{signingWallet:n,rootWallet:i}=m.getSolanaSigningAndRootWallet(Ae,a);if(!n||!i)return void r(Error("Must have a Privy wallet before exporting"));if(dt(!0),!await Xe()||!it)return void r(Error("Must have valid access token to enroll in MFA"));if(!it)return void r(Error("Must have a Privy wallet before exporting"));let{entropyId:o,entropyIdVerifier:s}=m.getEntropyDetailsFromAccount(i);ht({connectWallet:{entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:se.ModalScreen.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:r,shouldForceMFA:!0},keyExport:{appId:E.appId,appClientId:E.clientId,origin:v.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:r}}),bt(se.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})),setReadyToTrue:e=>{fe(!0),yt?.(e)},updateWallets:()=>Gt(),fundWallet:async(e,t)=>{let r=se.ModalScreen.FUNDING_METHOD_SELECTION_SCREEN;ht({funding:ve.prepareFundingModalData({address:e,appConfig:st,fundWalletConfig:t,methodScreen:r})}),bt(r)},openModal:bt,requestFarcasterSignerStatus:async e=>{let t=await Xe(),r=Ae?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!it||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!Ae?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let a=await v.requestFarcasterSignerStatus(e);return"approved"===a.status&&_e(await v.getAuthenticatedUser()||Ae||null),a},connectCoinbaseSmartWallet:async()=>{st.externalWallets.coinbaseWallet.connectionOptions="smartWalletOnly";let e=v.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||v.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),Ft(e);await Lt("coinbase_wallet","coinbase_smart_wallet")},initiateAccountTransfer:async({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o})=>{let s=await v.sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o});return _e(s),s}};ze=or.recoverPrimaryWallet,Ye=or.recoverPrimaryWallet,$e=or.solanaSignMessage;let sr=n.useMemo((()=>({wallets:Te,ready:vt&&Wt})),[Te,vt,Wt]),lr=v.authFlow instanceof w.TelegramAuthFlow,cr=!st.headless&&st.captchaEnabled&&!Ce&&(T||lr);/*#__PURE__*/return e.jsx(we.PrivyContext.Provider,{value:ir,children:/*#__PURE__*/e.jsx(he.PrivyEventsContext.Provider,{value:Tt,children:/*#__PURE__*/e.jsx(Ee.UseWalletsContext.Provider,{value:sr,children:/*#__PURE__*/e.jsx(ue.CaptchaProvider,{...st,children:/*#__PURE__*/e.jsxs(ye.InternalPrivyContext.Provider,{value:or,children:[/*#__PURE__*/e.jsx(oe.RecentlyUsedAccountProvider,{children:/*#__PURE__*/e.jsxs(pe.ModalProvider,{data:ut,setModalData:ht,setInitialScreen:De,initialScreen:Re,authenticated:Ce,open:A,children:[E.children,cr&&/*#__PURE__*/e.jsx(W.Captcha,{delayedExecution:!1}),/*#__PURE__*/e.jsx(ce.GlobalStyle,{theme:{...st.appearance.palette||{}}}),!st.render.standalone&&/*#__PURE__*/e.jsx(I.LoginModal,{open:A})]})}),ct&&lt?/*#__PURE__*/e.jsx(L.EmbeddedWalletIframe,{appId:E.appId,appClientId:E.clientId,clientAnalyticsId:v.clientAnalyticsId,origin:v.apiUrl,mfaMethods:Ae?.mfaMethods,mfaPromise:At,mfaSubmitPromise:_t,onLoad:ot,onLoadFailed:()=>null}):null,st.loginConfig.telegramAuthConfiguration&&
-/*#__PURE__*/e.jsx(le.Hide,{$if:!0,children:/*#__PURE__*/e.jsx(S.TelegramLoginButton,{scriptHost:E.apiUrl||f.DEFAULT_PRIVY_API_URL,botUsername:st.loginConfig.telegramAuthConfiguration.botName})})]})})})})})};exports.ConnectorManager=De,exports.Embedded1193Provider=Re,exports.EmbeddedSolanaProvider=Be,exports.PrivyClient=qe,exports.PrivyProvider=({config:t,...r})=>{var a;if("undefined"!=typeof window&&0>["localhost","127.0.0.1"].indexOf(window.location.hostname)&&"https:"!==window.location.protocol)throw new j.PrivyClientError("Embedded wallet is only available over HTTPS");if("string"!=typeof(a=r.appId)||25!==a.length)throw new j.PrivyClientError("Cannot initialize the Privy provider with an invalid Privy app ID");He||(He=new qe({appId:r.appId,appClientId:r.clientId,apiUrl:r.apiUrl}));let n=Object.assign({},t);return void 0!==r.createPrivyWalletOnLogin&&void 0===n.embeddedWallets?.createOnLogin&&(n.embeddedWallets||(n.embeddedWallets={}),n.embeddedWallets.createOnLogin=r.createPrivyWalletOnLogin?"users-without-wallets":"off"),void 0!==r.createPrivyWalletOnLogin&&t?.embeddedWallets?.createOnLogin&&console.warn("Both `createPrivyWalletOnLogin` and `config.embeddedWallets.createOnLogin` are set. `createPrivyWalletOnLogin` is deprecated and should be removed."),/*#__PURE__*/e.jsx(N.PrivyAppConfigProvider,{client:He,clientConfig:n,legacyCreateEmbeddedWalletFlag:r.createPrivyWalletOnLogin,children:/*#__PURE__*/e.jsx(ne.PrivyPluginProvider,{children:/*#__PURE__*/e.jsx(at,{...r,client:He})})})},exports.getAccessToken=Xe,exports.getCustomerAccessToken=function(){return He?He.getCustomerAccessToken():Promise.resolve(C.default.get(f.CUSTOMER_ACCESS_TOKEN_STORAGE_KEY)||null)},exports.globalRecoverEthereumModal=et,exports.globalRecoverSolanaModal=tt,exports.globalSignMessageModal=Je,exports.globalSignSolanaModal=rt,exports.globalSignTypedDataModal=Qe,exports.globalTransactModal=Ze,exports.loadConnectionHistory=Me;
+/*#__PURE__*/e.jsx(le.Hide,{$if:!0,children:/*#__PURE__*/e.jsx(S.TelegramLoginButton,{scriptHost:E.apiUrl||f.DEFAULT_PRIVY_API_URL,botUsername:st.loginConfig.telegramAuthConfiguration.botName})})]})})})})})};exports.ConnectorManager=De,exports.Embedded1193Provider=Re,exports.EmbeddedSolanaProvider=Be,exports.PrivyClient=qe,exports.PrivyProvider=({config:t,...r})=>{var a;if("undefined"!=typeof window&&0>["localhost","127.0.0.1"].indexOf(window.location.hostname)&&0>["https:","chrome-extension:","file:"].indexOf(window.location.protocol))throw new j.PrivyClientError("Embedded wallet is only available over HTTPS/CHROME-EXTENSION/FILE");if("string"!=typeof(a=r.appId)||25!==a.length)throw new j.PrivyClientError("Cannot initialize the Privy provider with an invalid Privy app ID");He||(He=new qe({appId:r.appId,appClientId:r.clientId,apiUrl:r.apiUrl}));let n=Object.assign({},t);return void 0!==r.createPrivyWalletOnLogin&&void 0===n.embeddedWallets?.createOnLogin&&(n.embeddedWallets||(n.embeddedWallets={}),n.embeddedWallets.createOnLogin=r.createPrivyWalletOnLogin?"users-without-wallets":"off"),void 0!==r.createPrivyWalletOnLogin&&t?.embeddedWallets?.createOnLogin&&console.warn("Both `createPrivyWalletOnLogin` and `config.embeddedWallets.createOnLogin` are set. `createPrivyWalletOnLogin` is deprecated and should be removed."),/*#__PURE__*/e.jsx(N.PrivyAppConfigProvider,{client:He,clientConfig:n,legacyCreateEmbeddedWalletFlag:r.createPrivyWalletOnLogin,children:/*#__PURE__*/e.jsx(ne.PrivyPluginProvider,{children:/*#__PURE__*/e.jsx(at,{...r,client:He})})})},exports.getAccessToken=Xe,exports.getCustomerAccessToken=function(){return He?He.getCustomerAccessToken():Promise.resolve(C.default.get(f.CUSTOMER_ACCESS_TOKEN_STORAGE_KEY)||null)},exports.globalRecoverEthereumModal=et,exports.globalRecoverSolanaModal=tt,exports.globalSignMessageModal=Je,exports.globalSignSolanaModal=rt,exports.globalSignTypedDataModal=Qe,exports.globalTransactModal=Ze,exports.loadConnectionHistory=Me;
diff --git a/node_modules/@privy-io/react-auth/dist/cjs/svg/protected-by-privy.js b/node_modules/@privy-io/react-auth/dist/cjs/svg/protected-by-privy.js
index 4d18d30..64c2a3f 100644
--- a/node_modules/@privy-io/react-auth/dist/cjs/svg/protected-by-privy.js
+++ b/node_modules/@privy-io/react-auth/dist/cjs/svg/protected-by-privy.js
@@ -1 +1 @@
-"use strict";var c=require("react/jsx-runtime");exports.ProtectedByPrivy=function(a){/*#__PURE__*/return c.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 460 40",...a,children:/*#__PURE__*/c.jsx("g",{fill:a.color||"var(--privy-color-foreground)",children:/*#__PURE__*/c.jsx("path",{d:"M0 15.4v15.38h4.64V19.96h3.58c2.47 0 3.63-.01 3.77-.02 1-.08 1.49-.15 2.18-.3a9.45 9.45 0 0 0 4.6-2.37c1.66-1.57 2.64-3.87 2.81-6.56.02-.3.02-1.19 0-1.49-.1-1.77-.56-3.35-1.36-4.72A8.84 8.84 0 0 0 15.14.57c-.93-.3-1.75-.43-3.09-.54C11.9.02 10.2 0 5.93 0H0ZM10.85 4c1.85.05 3.1.45 4.16 1.3.22.17.54.49.69.68a5.97 5.97 0 0 1 1.19 3.13c.04.35.04 1.36 0 1.71-.08.68-.23 1.3-.44 1.85a4.8 4.8 0 0 1-1.09 1.68A5.63 5.63 0 0 1 12 15.92c-.6.08-.4.08-4.01.09H4.64V3.98h2.9c1.6 0 3.08 0 3.31.02ZM187.65 5.71v5.72h-.27l-.09-.14a15.9 15.9 0 0 0-1.21-1.73c-.43-.5-1-.95-1.7-1.36-.54-.3-1.05-.5-1.73-.63a8.98 8.98 0 0 0-1.7-.17 8.84 8.84 0 0 0-7.8 4.03 12.95 12.95 0 0 0-2.03 6.39c-.07.98-.06 2.15.02 3.13.2 2.47.87 4.53 2.02 6.25a8.98 8.98 0 0 0 10.22 3.65 6.5 6.5 0 0 0 2.8-1.93c.41-.51.84-1.1 1.1-1.55l.1-.17h.37v3.58h4.38V0h-4.48Zm-5.24 5.54c1.3.14 2.3.6 3.17 1.48.9.9 1.5 2.09 1.85 3.64.36 1.6.39 3.72.06 5.43a8.13 8.13 0 0 1-1.54 3.62 5.1 5.1 0 0 1-3.93 1.96 6.13 6.13 0 0 1-2.32-.31 5.87 5.87 0 0 1-3.33-3.5c-.39-1-.62-2.05-.72-3.32-.03-.32-.04-1.35-.02-1.73.08-1.56.4-2.91.96-4.05a6.2 6.2 0 0 1 1.06-1.58 5.08 5.08 0 0 1 3.6-1.66c.25-.02.9 0 1.16.02ZM210.07 15.39l.01 15.38h4.38l.01-3.57h.37l.09.15c.24.44.84 1.26 1.21 1.7a6.79 6.79 0 0 0 2.57 1.75 9.3 9.3 0 0 0 6.86-.49 9.28 9.28 0 0 0 4.05-4.07A13.05 13.05 0 0 0 231 21.6c.21-1.73.18-3.7-.09-5.32a13.03 13.03 0 0 0-1.5-4.3 9.1 9.1 0 0 0-3.75-3.63 9.15 9.15 0 0 0-4.43-.96 7.46 7.46 0 0 0-2.8.5A7.07 7.07 0 0 0 216 9.7c-.4.52-.82 1.12-1.1 1.59l-.07.14h-.27V0h-4.5Zm11.13-4.14c1.07.1 1.94.44 2.7 1.04a6.1 6.1 0 0 1 1.64 1.98c.43.84.78 2 .94 3.11.15 1.16.16 2.4.02 3.54a9.34 9.34 0 0 1-1.39 4.03 5.33 5.33 0 0 1-2.69 2.15c-.9.3-2.04.38-3.06.2a5.14 5.14 0 0 1-3.45-2.37 6.03 6.03 0 0 1-.45-.8c-.5-1.03-.8-2.2-.92-3.58-.04-.49-.06-.89-.05-1.53.01-.76.05-1.23.13-1.85.38-2.53 1.47-4.38 3.15-5.31a5.46 5.46 0 0 1 2.3-.63 10 10 0 0 1 1.13.02ZM69.05 2.17l-.01 2.77V7.7h-3.36v3.6h3.36v6.8l.01 7.15c.06 1.4.4 2.44 1.1 3.37a5.8 5.8 0 0 0 2.97 2.07c.91.3 1.83.42 2.9.38a8.71 8.71 0 0 0 2.66-.48l-.8-3.7-.38.06a4.96 4.96 0 0 1-2.43-.06c-.33-.1-.56-.25-.8-.49-.4-.41-.6-.88-.7-1.67-.02-.2-.02-.62-.03-6.82v-6.6h4.73V7.7h-4.73V2.16h-4.49ZM133.34 2.17V7.7h-3.39v3.6h3.38v6.9l.01 7.17a5.66 5.66 0 0 0 2.36 4.49c.85.6 2.03 1.03 3.26 1.17.85.1 2.03.05 2.81-.1.3-.06.75-.18 1-.26l.2-.06v-.05l-.81-3.67-.37.06a4.99 4.99 0 0 1-1.8.09c-.85-.13-1.32-.4-1.7-.97a2.63 2.63 0 0 1-.39-1.04c-.06-.4-.06 0-.06-7.1V11.3h4.7V7.7h-4.7l-.01-2.77V2.16h-4.49ZM293.41 2.36a14.56 14.56 0 0 0-13.7 16.07 14.59 14.59 0 0 0 21.86 11.08 14.5 14.5 0 0 0 7.11-14.07 14.61 14.61 0 0 0-6.53-10.73 14.49 14.49 0 0 0-8.74-2.35ZM350.8 2.36a10.17 10.17 0 0 0-7.56 4.2c-.16.2-.45.63-.58.83l-.05.1h-.47l-.01-4.36h-7.36v36.4h7.82V27.27h.49l.05.07a11.3 11.3 0 0 0 7.49 4.15 10.52 10.52 0 0 0 9.38-4.1c1.66-2.1 2.73-4.9 3.07-8.06.1-.87.13-1.4.13-2.37 0-.8 0-1.1-.07-1.76a15.95 15.95 0 0 0-3.23-8.72 12.8 12.8 0 0 0-1.85-1.84 10.49 10.49 0 0 0-7.26-2.28Zm-.94 6.05c1.27.15 2.33.65 3.2 1.5.98.96 1.67 2.31 2.03 4 .34 1.57.38 3.68.12 5.39a9.78 9.78 0 0 1-1.04 3.25c-.14.25-.44.69-.6.89a5.35 5.35 0 0 1-4.31 2.07 5.25 5.25 0 0 1-4.41-1.9 7.35 7.35 0 0 1-1.26-2.32 14.09 14.09 0 0 1-.62-4.83c.05-1.98.38-3.53 1.02-4.85a5.63 5.63 0 0 1 2.5-2.65c.66-.34 1.3-.5 2.14-.58.18-.02 1.04 0 1.23.03ZM363.63 3.1l-.01 3.2v3.16h1.43c1.26.01 1.44.02 1.54.04.42.09.66.28.79.62.08.23.08.08.08 2.96a911.57 911.57 0 0 1 .03 10.18v7.54h7.82v-7.4l.01-7.83c.03-.94.11-1.63.27-2.28.46-1.9 1.54-2.93 3.35-3.23.52-.08.2-.08 5-.08h4.4V3.08h-3.1c-3.48 0-3.91.01-4.67.1-1.83.2-3.04.79-3.96 1.88-.5.6-.9 1.32-1.26 2.26l-.06.17h-.46V3.09h-5.6c-4.46 0-5.6 0-5.6.02ZM390.8 16.95V30.8h3.87l3.86-.01V3.09h-7.73ZM400.6 3.1l-.01.4v.38l4.66 13.4 4.69 13.47.02.05h10.3l.03-.05 4.67-13.45 4.67-13.4V3.1h-7.43l-6.7 19.26h-.5l-3.28-9.5-3.31-9.64-.05-.12h-3.88l-3.88.01ZM430.98 3.1c-.01 0-.02.19-.02.4v.39l5.08 14.59c2.8 8.02 5.08 14.6 5.08 14.61.01.02-.22.02-4.8.02h-4.82v6.42h4.95c5.09 0 5.23 0 5.87-.06 3.15-.28 5.29-1.63 6.63-4.15.28-.55.44-.95.87-2.16L459 6.78l1-2.89v-.8h-7.43l-6.69 19.26h-.5l-3.27-9.46-3.31-9.64-.06-.16h-3.88l-3.88.01ZM36.57 7.36c-1.36.1-2.6.6-3.62 1.45a5.65 5.65 0 0 0-1.67 2.42l-.05.13H31V7.7h-4.35v23.08h4.5v-7.3c0-8 0-7.34.08-7.82a4.89 4.89 0 0 1 2.06-3.18c.83-.58 1.74-.89 2.87-.98a11.87 11.87 0 0 1 2.8.25H39v-4.3l-.21-.02c-.61-.07-1.74-.1-2.22-.07ZM51.08 7.41c-2.33.12-4.3.84-5.95 2.16a9.89 9.89 0 0 0-2.03 2.2 12.5 12.5 0 0 0-2 5.78 18.04 18.04 0 0 0 0 3.65 12.13 12.13 0 0 0 2.26 6.05 9.74 9.74 0 0 0 5 3.52c2.11.64 4.7.64 6.8 0a9.78 9.78 0 0 0 4.88-3.37c1.38-1.78 2.19-4 2.4-6.58.13-1.46.06-3.06-.18-4.42a11.24 11.24 0 0 0-3.58-6.6 10 10 0 0 0-5.75-2.35c-.56-.06-1.31-.07-1.85-.04Zm1.42 3.78c.88.1 1.62.34 2.28.75a6.13 6.13 0 0 1 1.99 2.15 10.31 10.31 0 0 1 1.2 5c.02 1.23-.12 2.44-.42 3.51a7.14 7.14 0 0 1-1.81 3.32c-.61.6-1.2.98-1.95 1.24a6 6 0 0 1-2 .3 5.7 5.7 0 0 1-2.72-.6 5 5 0 0 1-1.28-.94A7.1 7.1 0 0 1 46 22.73c-.57-1.99-.6-4.46-.08-6.5a7.24 7.24 0 0 1 2.03-3.67 5.13 5.13 0 0 1 3.35-1.4 11 11 0 0 1 1.2.03ZM92.05 7.4c-.96.06-1.56.15-2.3.33a9.62 9.62 0 0 0-6.09 4.66 13.5 13.5 0 0 0-1.71 7c0 .83 0 1.04.06 1.6.16 1.77.58 3.32 1.29 4.7A9.72 9.72 0 0 0 90.28 31c1.84.37 4.08.32 5.85-.13a9.07 9.07 0 0 0 5.02-3.1A7.64 7.64 0 0 0 102.5 25l-2.11-.39-2.11-.38-.08.13a4.72 4.72 0 0 1-2.35 2.55 6.3 6.3 0 0 1-2.23.58c-.29.03-1.13.03-1.44 0a6.35 6.35 0 0 1-3.02-1.04 5.93 5.93 0 0 1-2.02-2.43 8.44 8.44 0 0 1-.72-3.18v-.26h16.38v-.81c0-1.83-.06-2.76-.25-3.87-.2-1.22-.53-2.24-1.05-3.28a8.9 8.9 0 0 0-2.66-3.26 10.1 10.1 0 0 0-5.34-1.94 18.3 18.3 0 0 0-1.46-.03Zm1.3 3.75c1.2.13 2.19.55 3.05 1.3a5.8 5.8 0 0 1 1.78 2.96c.13.51.21 1.17.21 1.66v.15H86.43v-.12c.08-.97.3-1.78.72-2.61.5-1 1.2-1.8 2.14-2.42a5.32 5.32 0 0 1 2.9-.95c.2-.01.97 0 1.17.03ZM116.79 7.41c-2 .1-3.73.65-5.22 1.65a10.7 10.7 0 0 0-4.25 6.06 16.1 16.1 0 0 0-.5 5.8c.2 2.17.84 4.13 1.88 5.76.58.9 1.32 1.73 2.15 2.4a9.37 9.37 0 0 0 3.6 1.8 12.06 12.06 0 0 0 3.92.34 10.2 10.2 0 0 0 3.84-.95 8.31 8.31 0 0 0 4.76-6.75l.01-.04h-4.37l-.05.16a4.87 4.87 0 0 1-4.24 3.75c-.59.07-1.32.06-1.93-.05a5.47 5.47 0 0 1-3.5-2.27c-.56-.75-1-1.73-1.26-2.79a13.8 13.8 0 0 1-.16-5.24 7.77 7.77 0 0 1 2.1-4.3 5.48 5.48 0 0 1 2.15-1.3 6.4 6.4 0 0 1 3.89.1c.59.21 1.03.5 1.5.96a5.32 5.32 0 0 1 1.46 2.5l.04.15h4.37v-.06a8.22 8.22 0 0 0-5.31-6.94 10.98 10.98 0 0 0-4.88-.74ZM156.2 7.41a9.87 9.87 0 0 0-6 2.29 11.02 11.02 0 0 0-3.41 5.43c-.52 1.78-.68 3.9-.48 5.97.17 1.8.63 3.38 1.37 4.8a9.68 9.68 0 0 0 5.91 4.86c1.65.48 3.63.61 5.53.36 3.72-.49 6.55-2.62 7.56-5.69.12-.39.13-.42.1-.43-.02 0-4.13-.75-4.19-.75-.03 0-.04 0-.1.16-.18.42-.45.9-.72 1.22-.16.2-.49.53-.7.7-.67.54-1.5.9-2.43 1.08-.48.08-.83.11-1.41.11-.64 0-1.07-.04-1.6-.15a5.76 5.76 0 0 1-3.93-2.83 8 8 0 0 1-.99-3.79v-.16h16.38v-1.11l-.02-1.43c-.1-2.25-.53-4-1.35-5.59a9.24 9.24 0 0 0-6.18-4.75c-1.04-.26-2.2-.36-3.33-.3Zm1.45 3.74a5.35 5.35 0 0 1 3.66 1.94 6.1 6.1 0 0 1 1.38 4.01v.12h-11.97v-.06c0-.02 0-.14.02-.25a6.6 6.6 0 0 1 2.15-4.32 5.73 5.73 0 0 1 3.5-1.46c.25-.02 1 0 1.26.02ZM233.58 7.82l8.37 23.22a49.22 49.22 0 0 1-.67 1.9 5.36 5.36 0 0 1-1.14 1.8c-.41.4-.82.58-1.48.69-.27.04-1.03.03-1.35 0a8.05 8.05 0 0 1-1.1-.23l-1.08 3.67c0 .02.32.14.66.22.83.21 1.57.29 2.56.28.56-.01.8-.03 1.24-.1 2.71-.4 4.66-2.09 5.86-5.08l9.64-26.44c0-.02-4.82-.06-4.83-.05l-2.93 8.96-2.91 8.94h-.24l-.22-.65-2.91-8.95-2.7-8.3H233.53ZM293.05 35.8c-1.18.04-1.93.09-2.8.16-2.52.24-4.53.69-5.43 1.23-.7.41-.76.86-.2 1.28.88.66 3.29 1.19 6.36 1.4a48.55 48.55 0 0 0 5.75.05c3.47-.19 6.24-.78 7.11-1.5.22-.19.3-.34.3-.53 0-.1 0-.12-.04-.22-.35-.69-2.32-1.3-5.25-1.63a41.09 41.09 0 0 0-5.8-.24Zm0 0"})})})};
+"use strict";var c=require("react/jsx-runtime");exports.ProtectedByPrivy=function(a){/*#__PURE__*/return c.jsx("div",{...a})};
diff --git a/node_modules/@privy-io/react-auth/dist/esm/privy-provider-BnF-KW5M.mjs b/node_modules/@privy-io/react-auth/dist/esm/privy-provider-BnF-KW5M.mjs
index d64b2d9..68fa640 100644
--- a/node_modules/@privy-io/react-auth/dist/esm/privy-provider-BnF-KW5M.mjs
+++ b/node_modules/@privy-io/react-auth/dist/esm/privy-provider-BnF-KW5M.mjs
@@ -1,2 +1,2 @@
-import{jsx as e,jsxs as t}from"react/jsx-runtime";import{getAddress as r}from"@ethersproject/address";import{Web3Provider as a}from"@ethersproject/providers";import{createStore as n}from"mipd";import{useState as i,useRef as o,useEffect as s,useMemo as l}from"react";import{isAndroid as c}from"react-device-detect";import{populateTransactionRequest as d,calculateTotalGasEstimate as u,ProviderErrors as h}from"@privy-io/js-sdk-core";import{CustomJwtAccountFlow as p}from"./auth-flows/custom-jwt-account.mjs";import{UpdateEmailFlow as w,EmailFlow as m}from"./auth-flows/email.mjs";import{FarcasterFlow as y}from"./auth-flows/farcaster.mjs";import{GuestFlow as f}from"./auth-flows/guest.mjs";import{PasskeyFlow as g}from"./auth-flows/passkey.mjs";import{SiweFlow as E}from"./auth-flows/siwe.mjs";import{SiwsFlow as _}from"./auth-flows/siws.mjs";import{UpdateSmsFlow as A,SmsFlow as T}from"./auth-flows/sms.mjs";import{TelegramAuthFlow as v,detectCompletingTelegramFlow as C}from"./auth-flows/telegram.mjs";import{v4 as I}from"uuid";import{AccessToken as W}from"./accessToken.mjs";import{getEntropyDetailsFromAccount as k,convertUserResponseToUser as N,getPrivySolanaHDWallets as b,getImportedPrivySolanaWallet as U,getPrivyPrimaryWallet as O,getPrivyEthereumWallet as S,getPrivyEthereumHDWallets as R,getImportedPrivyEthereumWallet as P,shouldProceedtoEmbeddedWalletCreationFlow as D,getPrivySolanaWallet as L,getLatestPrivyEthereumWallet as M,getSolanaSigningAndRootWallet as F,getEthereumSigningAndRootWallet as x,getLatestPrivySolanaWallet as j,getEntropyDetailsFromUser as B}from"./client/user.mjs";import V from"eventemitter3";import{CONNECTORS_STATE_KEY as H,CONNECTIONS_HISTORY_KEY as K,DEFAULT_PRIVY_API_URL as G,DEFAULT_API_TIMEOUT_MS as z,CLIENT_ANALYTICS_ID_KEY as q,CUSTOMER_ACCESS_TOKEN_STORAGE_KEY as $,PRIVY_ACCESS_TOKEN_STORAGE_KEY as Y,getGuestCredentialStorageKey as X,HEADLESS_OAUTH_KEY as Q,OAUTH_DISABLE_SIGNUP_KEY as J,STATE_CODE_KEY as Z,WALLET_PROXY_TIMEOUT as ee,FORKED_TOKEN_STORAGE_KEY as te}from"./constants.mjs";import re,{isLocalStorageAccessible as ae}from"./storage.mjs";import{getJsonRpcProvider as ne,generateTypedDataWithDomainType as ie,toHex as oe,detectInjectedConnectors as se,formatChainIdToCAIP2 as le}from"./utils/index.mjs";import{CoinbaseWalletConnector as ce}from"./connectors/coinbase.mjs";import{EmbeddedWalletConnector as de}from"./connectors/embedded.mjs";import{isSupportedEthereumRpcMethod as ue}from"./embedded-wallets/rpc/types.mjs";import{Captcha as he}from"./components/Captcha.mjs";import{LoginModal as pe}from"./components/LoginModal.mjs";import{TelegramLoginButton as we}from"./components/TelegramLoginButton.mjs";import{PrivyAppConfigProvider as me,useAppConfig as ye,useIsServerConfigLoaded as fe}from"./configuration/context.mjs";import{areWalletArraysEqual as ge}from"./connectors/areWalletArraysEqual.mjs";import{PrivyProviderRpcError as Ee,ProviderRpcError as _e}from"./connectors/errors.mjs";import{isPhantomInstalled as Ae}from"./connectors/is-wallet-installed.mjs";import{isBaseConnectedEthereumWallet as Te}from"./connectors/isBaseConnectedEthereumWallet.mjs";import{PrivyProxyProvider as ve,AsExternalProvider as Ce,AsAbstractProvider as Ie}from"./connectors/privyProxyProvider.mjs";import{isSolanaWalletConnector as We,isBaseConnectedSolanaWallet as ke}from"./connectors/solana/index.mjs";import{WalletConnectV2WalletConnector as Ne}from"./connectors/walletconnect-v2.mjs";import{EmbeddedWalletIframe as be}from"./embedded-wallets/EmbeddedWalletIframe.mjs";import{isWalletDelegated as Ue,getDelegatedWalletsData as Oe,getRootWalletDataForDelegation as Se,getDelegatedWalletsForUser as Re}from"./embedded-wallets/delegated-actions.mjs";import{errorIndicatesRecoveryIsNeeded as Pe}from"./embedded-wallets/errors.mjs";import{formatReceipt as De,getAndCheckBalance as Le,sendTransaction as Me}from"./embedded-wallets/rpc/index.mjs";import{PrivyClientError as Fe,formatApiError as xe,formatPrivyError as je,PrivyErrorCode as Be,PrivyNotReadyError as Ve,PrivyConnectorError as He,PrivyError as Ke}from"./errors.mjs";import{signSolanaTransaction as Ge,sendSolanaTransaction as ze}from"./embedded-wallets/solana/transaction.mjs";import{extractChainIdFromCAIP2 as qe}from"./lib/caip2.mjs";import{USE_BROADCAST_CHANNEL_EVENT_TYPE as $e,isPrivyTheOAuthProvider as Ye,CROSS_APP_BROADCAST_CHANNEL_NAME as Xe}from"./lib/cross-app/index.mjs";import{getCrossAppAuthorizationUrl as Qe,authenticateCrossAppAccount as Je,getProviderAppMetadata as Ze}from"./lib/cross-app/authFlow.mjs";import{popupCrossAppAuthFlow as et}from"./lib/cross-app/popupCrossAppAuthFlow.mjs";import{sendCrossAppRequest as tt}from"./lib/cross-app/sendCrossAppRequest.mjs";import{getRecoveryAuthorizationUrl as rt,authenticateRecovery as at,embeddedWalletRecoveryScreen as nt,toEmbeddedWalletSetRecoveryScreen as it}from"./lib/embeddedWalletRecovery.mjs";import{FUNDING_SCREENS as ot,fundingScreenMethodMap as st}from"./lib/funding/index.mjs";import{isFundingEnabled as lt}from"./lib/funding/isFundingEnabled.mjs";import ct from"./lib/isEmbeddedWebview.mjs";import{triggerPopup as dt}from"./lib/popup/triggerPopup.mjs";import{popupOAuthFlow as ut}from"./lib/popupOAuthFlow.mjs";import{prepareSiweMessageWithNonce as ht}from"./lib/siwe.mjs";import{decodeSolanaTransaction as pt,createSolanaTransactionReceipt as wt}from"./lib/solana/transaction.mjs";import{toDisplayFromAccountType as mt}from"./lib/toDisplayFromAccountType.mjs";import{transformResponseToSnakeCase as yt}from"./passkeys/transformResponseToSnakeCase.mjs";import{PrivyPluginProvider as ft,usePlugins as gt}from"./plugins/context/PrivyPluginContext.mjs";import{SOLANA_FUNDING_PLUGIN_ID as Et}from"./plugins/solana-funding/id.mjs";import{RecentlyUsedAccountProvider as _t}from"./recent-login/context.mjs";import{ModalScreen as At}from"./screens/index.mjs";import{Hide as Tt}from"./screens/LandingScreen/styles.mjs";import{GlobalStyle as vt}from"./styles.mjs";import{notImplemented as Ct}from"./hooks/index.mjs";import{CaptchaProvider as It}from"./hooks/captcha-context.mjs";import{privyEventsDefault as Wt,emitPrivyEvent as kt,PrivyEventsContext as Nt}from"./hooks/events-context.mjs";import{InternalPrivyContext as bt}from"./hooks/internal-context.mjs";import{ModalProvider as Ut}from"./hooks/modal-context.mjs";import{PrivyContext as Ot}from"./hooks/privy-context.mjs";import{UseWalletsContext as St}from"./hooks/useWallets.mjs";import{prepareSolanaFundingModalData as Rt,prepareFundingModalData as Pt}from"./lib/funding/prepareFundingModalData.mjs";import{detectCompletingOAuthFlow as Dt}from"./auth-flows/oauth/detectCompletingOAuthFlow.mjs";import{OAuthFlow as Lt}from"./auth-flows/oauth/OAuthFlow.mjs";import{getRpcTimeout as Mt}from"./connectors/getRpcTimeout.mjs";import{EmbeddedProviderError as Ft}from"./connectors/providerTypes.mjs";import{isEthereumWalletConnector as xt}from"./connectors/ethereum/index.mjs";import{LegacyInjectedWalletConnector as jt,Injected6963WalletConnector as Bt}from"./connectors/injected.mjs";import{MetamaskWalletConnector as Vt}from"./connectors/metamask.mjs";import{PhantomEthereumNullWalletConnector as Ht}from"./connectors/phantom.mjs";import{PhantomSolanaNullWalletConnector as Kt}from"./connectors/phantom-solana.mjs";import{Http as Gt}from"./http.mjs";import{getPaymasterContext as zt}from"./lib/smart-wallet-helpers.mjs";import{transformOptionsToCamelCase as qt}from"./passkeys/transformOptionsToCamelCase.mjs";import{mfaPasswordlessSmsInitPath as $t,mfaPasskeyInitPath as Yt,acceptTermsPath as Xt,unlinkEmailPath as Qt,unlinkPhonePath as Jt,unlinkWalletPath as Zt,siwsUnlinkWalletPath as er,unlinkOAuthPath as tr,unlinkFarcasterPath as rr,telegramAccountUnlinkPath as ar,unlinkPasskeyPath as nr,delegatedActionsRevokePath as ir,analyticsEventsPath as or,moonpayPluginOnRampPath as sr,coinbaseOnRampInitPath as lr,coinbaseOnRampStatusPath as cr,siweInitPath as dr,siweAuthenticatePath as ur,siweLinkPath as hr,smartWalletLinkPath as pr,siwsInitPath as wr,siwsAuthenticatePath as mr,transferOAuthPath as yr,telegramAccountTransferPath as fr,transferFarcasterPath as gr,transferWalletPath as Er,transferPhonePath as _r,transferEmailPath as Ar,siwsLinkPath as Tr}from"./paths.mjs";import{AccessTokenTypes as vr,Session as Cr}from"./session.mjs";class Ir extends V{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new Ft(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Vr()||!this.address)throw new Ft("Disconnected",4900);return(await Gr(t,void 0,void 0,this.address)).hash}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new Ft(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new Ft(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.provider=ne(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],r=e.params[1];return await Hr(t,void 0,r)}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],r="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1];return await Kr(ie(r),void 0,t)}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:oe(this.chainId)};try{return await this.provider.send("eth_estimateGas",[t])}catch(e){console.warn(`Gas estimation failed with error: ${e}. Retrying gas estimation by omitting the 'from' address`);try{return delete t.from,await this.provider.send("eth_estimateGas",[t])}catch(t){throw console.warn(`Gas estimation failed with error: ${t} when omitting the 'from' address`),e}}}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return oe(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!ue(e.method))return this.provider.send(e.method,e.params);{let t=await Vr();if(await zr(),!t||!this.address)throw new Ft("Disconnected",4900);try{return(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:{method:e.method,params:e.params}})).response.data}catch(e){throw console.error(e),new Ft("Disconnected",4900)}}}constructor({walletProxy:e,address:t,entropyId:r,entropyIdVerifier:a,rpcConfig:n,chains:i,appId:o,chainId:s=1,walletIndex:l}){super(),this.walletProxy=e,this.address=t,this.entropyId=r,this.entropyIdVerifier=a,this.chainId=s,this.rpcConfig=n,this.chains=i,this.provider=ne(s,this.chains,n,{appId:o}),this.rpcTimeoutDuration=Mt(n,"privy"),this.appId=o,this.walletIndex=l}}class Wr extends V{get wallets(){let e=new Set,t=this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let r=`${t.address}${t.walletClientType}${t.connectorType}`;return!e.has(r)&&(e.add(r),!0)})),r=t.findIndex((e=>e.address===(this.activeWallet?this.activeWallet:"unknown")));return r>=0&&t.unshift(t.splice(r,1)[0]),t}async initialize(){if(this.initialized)return;re.get(H)&&(re.getKeys().forEach((e=>{e.startsWith("walletconnect")&&re.del(e)})),re.del(H));let e=se({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:r})=>{this.createEthereumWalletConnector("injected",e,{eip6963InjectedProvider:t,legacyInjectedProvider:r})}))}));this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector("coinbase_wallet","coinbase_wallet"),!Ae()&&this.walletList.includes("phantom")&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&this.createEthereumWalletConnector("phantom","phantom"),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&this.addWalletConnector(new Kt)),this.externalWalletConfig.walletConnect.enabled&&this.createEthereumWalletConnector("wallet_connect_v2","unknown"),this.externalWalletConfig.solana.connectors?.get().forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{e?.forEach(this.addSolanaWalletConnector)})),await e,this.initialized=!0}findWalletConnector(e,t){return"wallet_connect_v2"===e?this.walletConnectors.filter(xt).find((t=>t.connectorType===e))??null:this.walletConnectors.filter(xt).find((r=>r.connectorType===e&&r.walletClientType===t))??null}findSolanaWalletConnector(e,t){return this.walletConnectors.filter(We).find((r=>r.connectorType===e&&r.walletClientType===t))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&t.walletClientType===e.walletClientType));t&&(e.connectedAt=t.connectedAt)})),this.saveConnectionHistory(),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&(this.saveConnectionHistory(),this.emit("walletsUpdated"))}addEmbeddedWalletConnectors({walletProxy:e,rootWallet:t,embeddedWallets:r,defaultChain:a,appId:n}){for(let i of r){let r=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===i.walletIndex));if(r&&xt(r))r.proxyProvider.walletProxy=e;else{let{entropyId:r,entropyIdVerifier:o}=k(t),s=new de({provider:new Ir({walletProxy:e,address:i.address,entropyId:r,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:n,chainId:a.id,walletIndex:i.walletIndex}),chains:this.chains,defaultChain:a,rpcConfig:this.rpcConfig,imported:!1,walletIndex:i.walletIndex});this.addWalletConnector(s)}}}addImportedWalletConnector(e,t,r,a){let n=this.findWalletConnector("embedded_imported","privy");if(n&&xt(n))n.proxyProvider.walletProxy=e;else{let n=new de({provider:new Ir({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:a,chainId:r.id}),chains:this.chains,walletIndex:0,defaultChain:r,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(n)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.saveConnectionHistory(),this.storedConnections=kr(),this.emit("walletsUpdated")}removeImportedWalletConnector(){let e=this.findWalletConnector("embedded_imported","privy");if(e){let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1),this.saveConnectionHistory(),this.storedConnections=kr(),this.emit("walletsUpdated")}}async createEthereumWalletConnector(e,t,r){let a=this.findWalletConnector(e,t);if(a&&xt(a))return a instanceof Ne&&a.resetConnection(t),a;let n=(()=>"injected"!==e?"coinbase_wallet"===e?new ce(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig,this.privyAppName,this.privyAppLogo):"phantom"===e?new Ht(this.defaultChain):new Ne(this.walletConnectCloudProjectId,this.rpcConfig,this.chains,this.defaultChain,this.shouldEnforceDefaultChainOnConnect,this.privyAppId,this.privyAppName,t):"metamask"===t&&r?.eip6963InjectedProvider?new Vt(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,"metamask"):"metamask"===t&&r?.legacyInjectedProvider?new jt(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"metamask"):"phantom"===t&&r?.legacyInjectedProvider?new jt(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"phantom"):r?.legacyInjectedProvider&&"unknown_browser_extension"===t?new jt(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider):r?.eip6963InjectedProvider?new Bt(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,t):void 0)();return n&&this.addWalletConnector(n),n||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}saveConnectionHistory(){let e=this.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt})));re.put(K,e)}async activeWalletSign(e){let t=this.wallets,r=t.length>0?t[0]:null;return r&&Te(r)?r.sign(e):null}setActiveWallet(e){this.activeWallet=r(e),this.emit("walletsUpdated")}constructor(e,t,r,a,n,i,o,s,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{this.findSolanaWalletConnector("solana_adapter",e.walletClientType)||this.addWalletConnector(e)},this.getEthereumProvider=()=>{let e=this.wallets[0],t=this.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new ve},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=r,this.chains=a,this.defaultChain=n,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=o,this.shouldEnforceDefaultChainOnConnect=s,this.externalWalletConfig=l,this.privyAppName=c,this.privyAppLogo=d,this.walletChainType=u||"ethereum-only",this.storedConnections=kr()}}const kr=()=>{let e=re.get(K);return e&&Array.isArray(e)&&e.map((e=>(e=>e&&"string"==typeof e.address&&"string"==typeof e.connectorType&&"string"==typeof e.walletClientType&&"number"==typeof e.connectedAt)(e))).every(Boolean)?e:[]};let Nr;var br=0,Ur="__private_"+br+++"__getOrGenerateClientAnalyticsId";class Or{initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:r,defaultChain:a,store:n,walletList:i,shouldEnforceDefaultChainOnConnect:o,externalWalletConfig:s,appName:l,walletChainType:c}){this.connectors||(this.connectors=new Wr(this.appId,e,t,r,a,n,i,o,s,l,void 0,c))}generateApi(){let e=new Gt({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new Fe("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new Fe("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post($t,{action:"verify"})}catch(e){throw xe(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(Yt,{});return qt(e.options)}catch(e){throw xe(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(Xt,{});return N(e)}catch(e){throw je(e)}}async unlinkEmail(e){try{let t=await this.api.post(Qt,{address:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkPhone(e){try{let t=await this.api.post(Jt,{phoneNumber:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(Zt,{address:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(er,{address:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkOAuth(e,t){try{let r=await this.api.post(tr,{provider:e,subject:t});return await this.getAuthenticatedUser()??N(r)}catch(e){throw je(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(rr,{fid:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkTelegram(e){try{let t=await this.api.post(ar,{telegram_user_id:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkPasskey(e){try{let t=await this.api.post(nr,{credential_id:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async revokeDelegatedWallet(){try{await this.api.post(ir,{})}catch(e){throw je(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:r,options:a}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(or,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:r?r.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:a?.keepAlive??!1})}catch(e){}}async signMoonpayOnRampUrl(e){try{return this.api.post(sr,e)}catch(e){throw je(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(lr,e)}catch(e){throw je(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${cr}?partnerUserId=${e}`)}catch(e){throw je(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()||this.session.hasRecoveryCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(vr.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(vr.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?W.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getSmartWalletsConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let r=await this.api.get(`/api/v1/apps/${this.appId}/smart_wallets`,{baseURL:this.fallbackApiUrl,headers:e});return r.enabled?{enabled:r.enabled,smartWalletType:r.smart_wallet_type,configuredNetworks:r.configured_networks.map((e=>({chainId:e.chain_id,bundlerUrl:e.bundler_url,paymasterUrl:e.paymaster_url,paymasterContext:zt(e.paymaster_url,e.paymaster_context)})))}:{enabled:r.enabled}}catch(e){throw je(e)}}async getServerConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let r=await this.api.get(`/api/v1/apps/${this.appId}`,{baseURL:this.fallbackApiUrl,headers:e}),a=r.telegram_auth_config?{botId:r.telegram_auth_config.bot_id,botName:r.telegram_auth_config.bot_name,linkEnabled:r.telegram_auth_config.link_enabled,seamlessAuthEnabled:r.telegram_auth_config.seamless_auth_enabled}:void 0,n=r.funding_config?{methods:r.funding_config.methods,options:r.funding_config.options,defaultRecommendedAmount:r.funding_config.default_recommended_amount,defaultRecommendedCurrency:r.funding_config.default_recommended_currency,promptFundingOnWalletCreation:r.funding_config.prompt_funding_on_wallet_creation,crossChainBridgingEnabled:r.funding_config.cross_chain_bridging_enabled}:void 0;return{id:r.id,name:r.name,verificationKey:r.verification_key,logoUrl:r.logo_url||void 0,accentColor:r.accent_color||void 0,showWalletLoginFirst:r.show_wallet_login_first,allowlistConfig:{errorTitle:r.allowlist_config.error_title,errorDetail:r.allowlist_config.error_detail,errorCtaText:r.allowlist_config.cta_text,errorCtaLink:r.allowlist_config.cta_link},walletAuth:r.wallet_auth,solanaWalletAuth:r.solana_wallet_auth,emailAuth:r.email_auth,smsAuth:r.sms_auth,googleOAuth:r.google_oauth,twitterOAuth:r.twitter_oauth,discordOAuth:r.discord_oauth,githubOAuth:r.github_oauth,spotifyOAuth:r.spotify_oauth,instagramOAuth:r.instagram_oauth,tiktokOAuth:r.tiktok_oauth,linkedinOAuth:r.linkedin_oauth,appleOAuth:r.apple_oauth,farcasterAuth:r.farcaster_auth,passkeyAuth:r.passkey_auth,telegramAuth:r.telegram_auth,disablePlusEmails:r.disable_plus_emails,termsAndConditionsUrl:r.terms_and_conditions_url,embeddedWalletConfig:{createOnLogin:r.embedded_wallet_config?.create_on_login,userOwnedRecoveryOptions:r.embedded_wallet_config.user_owned_recovery_options,requireUserOwnedRecoveryOnCreate:r.embedded_wallet_config.require_user_owned_recovery_on_create},privacyPolicyUrl:r.privacy_policy_url,requireUsersAcceptTerms:r.require_users_accept_terms,customApiUrl:r.custom_api_url,walletConnectCloudProjectId:r.wallet_connect_cloud_project_id,fiatOnRampEnabled:r.fiat_on_ramp_enabled,captchaEnabled:r.captcha_enabled,captchaSiteKey:r.captcha_site_key,createdAt:new Date(1e3*r.created_at),updatedAt:new Date(1e3*r.updated_at),mfaMethods:r.mfa_methods,enforceWalletUis:r.enforce_wallet_uis,legacyWalletUiConfig:r.legacy_wallet_ui_config,telegramAuthConfiguration:a,fundingConfig:n}}catch(e){throw je(e)}}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async forkSession(){return await this.session.forkSession()}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(dr,{address:e,token:t})).nonce}catch(e){throw je(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n,mode:i}){return await this.api.post(ur,{message:e,signature:t,chainId:r,walletClientType:a,connectorType:n,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}){return await this.api.post(hr,{message:e,signature:t,chainId:r,walletClientType:a,connectorType:n})}async linkSmartWallet({message:e,signature:t,smartWalletType:r}){try{let a=await this.api.post(pr,{message:e,signature:t,smart_wallet_type:r});return N(a)}catch(e){throw je(e)}}async linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n});return N(i)}catch(e){throw je(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(wr,{address:e,token:t})).nonce}catch(e){throw je(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a,mode:n}){return await this.api.post(mr,{message:e,signature:t,walletClientType:r,connectorType:a,mode:n})}async sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o}){try{let s,l;switch(r){case"email":s=Ar,l={nonce:e,email:t};break;case"sms":s=_r,l={nonce:e,phoneNumber:t};break;case"siwe":if(s=Er,!a)throw Error("Wallet parameters must be defined");l={nonce:e,address:t,...a};break;case"farcaster":s=gr,l={nonce:e,farcaster_id:t,farcaster_embedded_address:i};break;case"telegram":s=fr,l={nonce:e,telegram_auth_result:n};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:s=yr,l={nonce:e,userInfo:o}}let c=await this.api.post(s,l);return await this.getAuthenticatedUser()??N(c)}catch(e){throw je(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a}){return await this.api.post(Tr,{message:e,signature:t,walletClientType:r,connectorType:a})}async linkWithSiws({message:e,signature:t,walletClientType:r,connectorType:a}){try{let n=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a});return N(n)}catch(e){throw je(e)}}constructor({apiUrl:e=G,appId:t,appClientId:r,timeout:a=z}){Object.defineProperty(this,Ur,{value:Sr}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==G&&e.startsWith("https://privy."),this.timeout=a,this.appId=t,this.appClientId=r,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Ur)[Ur](),Nr||(Nr=new Cr),this.session=Nr,this.api=this.generateApi(),this.session.client=this}}function Sr(){if("undefined"==typeof window)return null;try{let e=re.get(q);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=I();try{return re.put(q,e),e}catch(t){return e}}class Rr{async handleSignMessage(e){if(!e.params||"string"!=typeof e.params.message)throw Error("Message must be provided as a string for Solana signMessage RPC");return await $r({message:e.params.message,address:this.address})}async request(e){if(console.debug("EmbeddedSolanaProvider.request() called with args",e),!await Vr())throw Error("User must be authenticated to use embedded Solana wallet");if(!await qr())throw new Fe("Unable to connect to Solana embedded wallet");if("signMessage"===e.method)return await this.handleSignMessage(e);throw Error("Embedded Solana provider does not yet support this RPC method.")}constructor(e,t){this.walletProxy=e,this.address=t}}let Pr,Dr,Lr,Mr,Fr,xr,jr;function Br(){return Pr?Pr.getCustomerAccessToken():Promise.resolve(re.get($)||null)}async function Vr(){return Pr?Pr.getAccessToken():Promise.resolve(re.get(Y)||re.get($)||null)}const Hr=(e,t,r)=>Dr(e,t,r),Kr=(e,t,r)=>Lr(e,t,r),Gr=(e,t,r,a)=>Mr(e,t,r,a),zr=()=>Fr(),qr=()=>xr(),$r=({message:e,address:t})=>jr({message:e,address:t});const Yr=({config:t,...r})=>{var a;if("undefined"!=typeof window&&0>["localhost","127.0.0.1"].indexOf(window.location.hostname)&&"https:"!==window.location.protocol)throw new Fe("Embedded wallet is only available over HTTPS");if("string"!=typeof(a=r.appId)||25!==a.length)throw new Fe("Cannot initialize the Privy provider with an invalid Privy app ID");Pr||(Pr=new Or({appId:r.appId,appClientId:r.clientId,apiUrl:r.apiUrl}));let n=Object.assign({},t);return void 0!==r.createPrivyWalletOnLogin&&void 0===n.embeddedWallets?.createOnLogin&&(n.embeddedWallets||(n.embeddedWallets={}),n.embeddedWallets.createOnLogin=r.createPrivyWalletOnLogin?"users-without-wallets":"off"),void 0!==r.createPrivyWalletOnLogin&&t?.embeddedWallets?.createOnLogin&&console.warn("Both `createPrivyWalletOnLogin` and `config.embeddedWallets.createOnLogin` are set. `createPrivyWalletOnLogin` is deprecated and should be removed."),/*#__PURE__*/e(me,{client:Pr,clientConfig:n,legacyCreateEmbeddedWalletFlag:r.createPrivyWalletOnLogin,children:/*#__PURE__*/e(ft,{children:/*#__PURE__*/e(Xr,{...r,client:Pr})})})};let Xr=I=>{let W=I.client,N=gt(),[V,H]=i(!1),[K,z]=i(!1),[$,Y]=i(!1),[se,ce]=i(null),[de,ue]=i([]),[me,We]=i([]),[xe,je]=i([]),ft=o(de),[Mt,Ft]=i(!1),[xt,jt]=i(null),[Bt,Vt]=i(!1),[Ht,Kt]=i({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:Ct}),[Gt,zt]=i({status:"initial"}),[qt,$t]=i({status:"initial"}),[Yt,Xt]=i({status:"initial"}),[Qt,Jt]=i({status:"initial"}),[Zt,er]=i({status:"initial"}),[tr,rr]=i(null),ar=ye(),nr=fe(),[ir,or]=i(!0),[sr,lr]=i({}),[cr,dr]=i(null),[ur,hr]=i(null),[pr,wr]=i(!1),[mr,yr]=i(!1),[fr,gr]=i(ar.customAuth?.enabled?{status:"initial"}:{status:"not-enabled"}),Er=o(null),_r=o(null),Ar=o(Wt),[Tr,vr]=i(!1);W.onStoreCustomerAccessToken=e=>{e&&kt(Ar,"accessToken","onAccessTokenGranted",e)},W.onDeleteCustomerAccessToken=()=>{ce(null),Y(!1),kt(Ar,"accessToken","onAccessTokenRemoved")};let Cr=o(null),Ir=o(null),Wr=o(!1),kr=({showWalletUIs:e,typedData:t})=>Wr.current?Wr.current:void 0!==e?!e:void 0!==ar.embeddedWallets.showWalletUIs?!ar.embeddedWallets.showWalletUIs:t?ar.embeddedWallets.noPromptOnSignature||(ar.legacyWalletUiConfig??!1):!!ar.embeddedWallets.noPromptOnSignature,Nr=e=>{jt(e),setTimeout((()=>{H(!0)}),15),W.createAnalyticsEvent({eventName:"modal_open",payload:{initialScreen:e}})},br=e=>{"off"!==ar.embeddedWallets.createOnLogin&&or(!0),Nr(e)};s((()=>{let e=[...b(se),U(se)].filter((e=>!!e));tr&&je(e.map((e=>({type:"solana",imported:e.imported,address:e.address,connectedAt:Date.now(),walletClientType:"privy",connectorType:"embedded",walletIndex:e.walletIndex??void 0,meta:{name:"Privy Wallet",icon:void 0,id:"io.privy.solana.wallet"},linked:!0,fund(){throw new Fe("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:()=>{throw new Fe("Cannot unlink an embedded Solana wallet")},getProvider:async()=>new Rr(tr,e.address),async signMessage(t){let r=await Vr();if(!r||!tr)throw new Fe("Must have valid access token and Privy wallet to send transaction",Be.MUST_BE_AUTHENTICATED);let a=e.imported?U(se):O(se);if(!a)throw new Fe("Attempting to sign a transaction without a root wallet");let{entropyId:n,entropyIdVerifier:i}=k(a);if(!await ua.recoverPrimaryWallet().catch((()=>!1)))throw new Fe("Wallet couldn't be connected",Be.UNKNOWN_CONNECT_WALLET_ERROR);if(!se)throw new Fe("Attempting to sign a transaction with no user initialized");let{response:o}=await tr.rpc({accessToken:r,entropyId:n,entropyIdVerifier:i,chainType:"solana",hdWalletIndex:this.walletIndex??0,request:{method:"signMessage",params:{message:Buffer.from(t).toString("base64")}}});return Buffer.from(o.data.signature,"base64")},async sendTransaction(e,t,r){let{signature:a}=await na({transaction:e,connection:t,transactionOptions:r,wallet:this});return a},async signTransaction(t){let r=await Vr();if(!r||!tr)throw new Fe("Must have valid access token and Privy wallet to send transaction",Be.MUST_BE_AUTHENTICATED);if(!await ua.recoverPrimaryWallet().catch((()=>!1)))throw new Fe("Wallet couldn't be connected",Be.UNKNOWN_CONNECT_WALLET_ERROR);let{entropyId:a,entropyIdVerifier:n}=k(e);return await Ge({tx:t,accessToken:r,walletProxy:tr,entropyId:a,entropyIdVerifier:n,transactingWalletAddress:this.address,transactingWalletIndex:this.walletIndex??0}),t},loginOrLink:async()=>{throw new Fe("Cannot login or link with an embedded Solana wallet")},disconnect:()=>{},isConnected:async()=>!0}))))}),[tr,se]),s((()=>{if(!se)return void W.connectors?.removeEmbeddedWalletConnectors();let e=S(se),t=R(se),r=P(se);e&&t.length||W.connectors?.removeEmbeddedWalletConnectors(),r||W.connectors?.removeImportedWalletConnector(),W.connectors?tr?(e&&W.connectors.addEmbeddedWalletConnectors({walletProxy:tr,rootWallet:e,embeddedWallets:t,defaultChain:ar.defaultChain,appId:I.appId}),r&&W.connectors.addImportedWalletConnector(tr,r.address,ar.defaultChain,I.appId)):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[tr,se]),s((()=>{tr&&ur?.(tr)}),[tr]);let Ur=o();s((()=>{(async()=>{if(!ar.customAuth?.enabled)return void gr({status:"not-enabled"});or(!0);let{getCustomAccessToken:e,isLoading:t}=ar.customAuth;if(K&&!t&&"loading"!==fr.status){gr({status:"loading"});try{let t=await e();if(t===Ur.current)return void gr({status:"done"});if(!t&&$)return Ur.current=t,await da.logout(),gr({status:"done"}),void kt(Ar,"customAuth","onUnauthenticated");if(!t)return Ur.current=t,void gr({status:"done"});W.startAuthFlow(new p(t));let{user:r,isNewUser:a}=await W.authenticate();if(!r)return await da.logout(),gr({status:"error",error:new Fe("Failed to sync with custom auth provider")}),void kt(Ar,"customAuth","onUnauthenticated");void 0!==a&&kt(Ar,"login","onComplete",r,a,!1,"custom",null),Ur.current=t,kt(Ar,"customAuth","onAuthenticated",{user:r}),gr({status:"done"}),ce(r||null),Ft(a||!1),Y(!0),yr(!0)}catch(e){if(console.warn(e),await da.logout(),kt(Ar,"customAuth","onUnauthenticated"),"User already exists with provided custom JWT account."===e.message)return void gr({status:"initial"});kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),gr({status:"error",error:e})}}})()}),["initial"===fr.status,ar.customAuth?.enabled,ar.customAuth?.getCustomAccessToken,ar.customAuth?.isLoading,K,$]),s((()=>{mr&&tr&&se&&D(se,ar.embeddedWallets.createOnLogin)&&(yr(!1),Jr(se,ee).catch(console.error))}),[mr&&tr&&se]),s((()=>{if(ar.externalWallets.solana.connectors)return ar.externalWallets.solana.connectors.onMount(),()=>ar.externalWallets.solana.connectors?.onUnmount()}),[ar.externalWallets.solana.connectors]),s((()=>{!K&&nr&&async function(){let e,t=Or(),r=Sr();(()=>{let e=new URLSearchParams(window.location.search).get("privy_token");if(!e)return;re.put(te,e);let t=new URL(window.location.href);t.searchParams.delete("privy_token"),window.history.pushState({},"",t)})();let a=n();W.initializeConnectorManager({walletConnectCloudProjectId:ar.walletConnectCloudProjectId,rpcConfig:ar.rpcConfig,chains:ar.chains,defaultChain:ar.defaultChain,store:a,walletList:ar.appearance.walletList,shouldEnforceDefaultChainOnConnect:ar.shouldEnforceDefaultChainOnConnect,externalWalletConfig:ar.externalWallets,appName:ar.name??"Privy",walletChainType:ar.appearance.walletChainType}),W.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=W.connectors.walletConnectors.length,r=W.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);r===t?vr(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:r,expected:t}),vr(!0)}),1500)})),W.connectors?.initialize().then((()=>{zr()}));let i=await W.getAuthenticatedUser(),o=!!i;ar.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await W.logout(),ua.setReadyToTrue(!0),kt(Ar,"logout","onSuccess")):(ar.customAuth?.enabled||(Y(!!i),i&&kt(Ar,"login","onComplete",i,!1,!0,null,null),ce(i)),t?Ir.current=o?"link":"login":r&&!o?(Ir.current="login",lr({telegramAuthModalData:{seamlessAuth:!0}}),br(At.TELEGRAM_AUTH_SCREEN)):ua.setReadyToTrue(!!i))}()}),[W,cr,K,nr]),s((()=>{if(K){if(!se||!se.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void wr(!0);wr(!!de.find((e=>"privy"===e.walletClientType)))}}),[K,se,de]);let Or=()=>{let e=Dt();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&Ye(e.provider)&&!e.popupFlow&&(new BroadcastChannel(Xe).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(W.startAuthFlow(new Lt(e)),br(At.AWAITING_OAUTH_SCREEN),!0))},Sr=()=>{let e=C();if(!e||!ar.loginMethods.telegram||!ar.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new v;return W.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},Br=async(e,t,r,a)=>{Hr(await(W.connectors?.createEthereumWalletConnector(e,t))||null,t,r,a)};async function Hr(e,t,r,a){if(!e)return Kt({status:"disconnected",connectedWallet:null,connectError:new He("Unable to connect to wallet."),connector:null,connectRetry:Ct}),a?.(null,r);Kt({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:Ct}),e instanceof Ne&&t&&await e.resetConnection(t),Kt({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>Hr(e,t,r,a)});try{let t=await e.connect({showPrompt:!0});if((!t||Te(t))&&ar.shouldEnforceDefaultChainOnConnect&&!ar.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){Kt((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:Ct})));try{await(t?.switchChain(ar.defaultChain.id)),t&&(t.chainId=le(oe(ar.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${ar.defaultChain.id}`)}}return Kt((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:Ct}))),t&&kt(Ar,"connectWallet","onSuccess",(e.chainType,t)),a?.(t,r)}catch(e){return e instanceof Ke?(console.warn(e.cause?e.cause:e.message),kt(Ar,"connectWallet","onError",e.privyErrorCode||Be.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),kt(Ar,"connectWallet","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR)),Kt((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),a?.(null,r)}}let Kr=async(e,t,r)=>{if(null===e||!Te(e))return;let a=new E(e,W,t,r);W.startAuthFlow(a)},Gr=async(e,t)=>{if(null===e||!ke(e))return;let r=new _(e,W,t);W.startAuthFlow(r)},zr=()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),r=e.get("privy_wallet_client");if(!t||!r)return;if("phantom"!==r||Ae()||br(At.LOGIN_FAILED_SCREEN),!W.connectors)throw new Fe("Connector not initialized");Nr(At.AWAITING_CONNECTION);let a=new URL(window.location.href);a.searchParams.delete("privy_connector"),a.searchParams.delete("privy_wallet_client"),window.history.pushState({},"",a),Br(t,r,void 0,Kr)};s((()=>{K&&$&&null===se&&W.getAuthenticatedUser().then(ce)}),[K,$,se,W]);let qr=e=>{if(!$)throw kt(Ar,"linkAccount","onError",Be.MUST_BE_AUTHENTICATED,{linkMethod:e}),new Fe("User must be authenticated before linking an account.")},$r=()=>{qr("siwe"),Cr.current="siwe",Ir.current="link",Nr(At.LINK_WALLET_SCREEN)},Yr=e=>{if(!$||!se)return!1;if("privy"===e.walletClientType)return!0;for(let t of se.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},Xr=async e=>{let t;if(!W.connectors)throw new Fe("Connector not initialized");t="ethereum"===e.type?W.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:W.connectors.findSolanaWalletConnector(e.connectorType,e.walletClientType)||null,Kt((r=>({...r,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:Ct}))),ar.captchaEnabled&&!$?(lr({captchaModalData:{callback:t=>Te(e)?Kr(e,t):Gr(e,t),userIntentRequired:!1,onSuccessNavigateTo:At.AWAITING_CONNECTION,onErrorNavigateTo:At.ERROR_SCREEN}}),br(At.CAPTCHA_SCREEN)):(Te(e)?await Kr(e):await Gr(e),br(At.AWAITING_CONNECTION))},Qr=()=>{ue((e=>{let t=W.connectors?.wallets.filter(Te).map((e=>({...e,linked:Yr(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Fe("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot link or login with embedded wallet");Xr(e)},fund:async t=>{await ua.fundWallet(e.address,t)},unlink:async()=>{if(!$)throw new Fe("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot unlink an embedded wallet");ce(await W.unlinkEthereumWallet(e.address))}})))||[];return ge(e,t)?e:t})),We((e=>{let t=(W.connectors?.wallets??[]).concat(xe).filter(ke).map((e=>({...e,linked:Yr(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Fe("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot link or login with embedded wallet");Xr(e)},fund:async()=>{throw new Fe("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:async()=>{if(!$)throw new Fe("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot unlink an embedded wallet");ce(await W.unlinkSolanaWallet(e.address))}})));return ge(e,t)?e:t}))};s((()=>{Qr()}),[se?.linkedAccounts,$,K,xe]),s((()=>{if(K){if(!W.connectors)throw new Fe("Connector not initialized");Qr(),W.connectors.on("walletsUpdated",Qr)}}),[K]),s((()=>{[...ar.loginMethodsAndOrder?.primary??[],...ar.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>W.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!W]),s((()=>{let e;if(!de[0])return;let t=de[0],r=ft.current.find((e=>e.address===t.address));if(e="privy"===t.walletClientType?se?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"===e.walletClientType)):se?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"!==e.walletClientType)),!r&&e){let t=Object.assign({},se);t.wallet=e&&{address:e.address,chainType:e.chainType,chainId:e.chainId,walletClient:e.walletClient,walletClientType:e.walletClientType,connectorType:e.connectorType,imported:e.imported,delegated:e.delegated,walletIndex:e.walletIndex},ce(t)}ft.current=de}),[de]);let Jr=async(e,t,r)=>{let a=S(e),n=L(e);if(r&&"walletIndex"in r)return ea(e,t,r.walletIndex,a,n);let i=r&&"createAdditional"in r&&r.createAdditional;if(a&&!i)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");let[o,s]=await Promise.all([ua.initializeWalletProxy(t),Vr()]);if(!o&&ar.customAuth?.enabled)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!o||!s||ar.embeddedWallets?.requireUserOwnedRecoveryOnCreate)return Zr();if(!a)return await o.create({accessToken:s,solanaAddress:n?.address}),ra(0,"ethereum");{let t=(M(e)?.walletIndex??0)+1,{entropyId:r,entropyIdVerifier:a}=k(O(e));return await ua.recoverPrimaryWallet(),await o.addWallet({accessToken:s,entropyId:r,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:t}),ra(t,"ethereum")}},Zr=async()=>new Promise(((e,t)=>{or(!0),lr({createWallet:{onSuccess:t=>{kt(Ar,"createWallet","onSuccess",t),e(t)},onFailure:e=>{kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),t(e)},callAuthOnSuccessOnClose:!1}}),Nr(At.EMBEDDED_WALLET_ON_ACCOUNT_CREATE_SCREEN)})),ea=async(e,t,r,a,n)=>{if(r<0)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${r}) is invalid.`);let[i,o]=await Promise.all([ua.initializeWalletProxy(t),Vr()]);if(!i&&ar.customAuth?.enabled)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!i||!o||ar.embeddedWallets?.requireUserOwnedRecoveryOnCreate){if(0==r)return Zr();throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Create wallet UI can only be displayed when walletIndex is 0.")}if(0==r){if(a)return a;await i.create({accessToken:o,solanaAddress:n?.address})}else{if(!a)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error("A user must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let t=R(e).find((e=>e.walletIndex===r));if(t)return t;let{entropyId:n,entropyIdVerifier:s}=k(O(e));await ua.recoverPrimaryWallet(),await i.addWallet({accessToken:o,entropyId:n,entropyIdVerifier:s,chainType:"ethereum",hdWalletIndex:r})}return ra(r,"ethereum")},ta=async({user:e,wp:t,accessToken:r,walletIndex:a,ethereumWallet:n})=>{let i=b(e).find((e=>e.walletIndex===a));if(i)return i;if(0===a)await t.createSolana({accessToken:r,ethereumAddress:n?.address});else{let n=O(e);if(!n)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error("User must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let{entropyId:i,entropyIdVerifier:o}=k(n);await ua.recoverPrimaryWallet(),await t.addWallet({accessToken:r,entropyId:i,entropyIdVerifier:o,chainType:"solana",hdWalletIndex:a})}return ra(a,"solana")},ra=async(e,t)=>{let r=await ua.refreshUser(),a=("ethereum"===t?R(r):b(r)).find((t=>t.walletIndex===e));if(!a)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");return kt(Ar,"createWallet","onSuccess",a),a},aa=(e,t,a,n)=>new Promise((async(i,o)=>{let{requesterAppId:s}=t||{};if(!$||!se)return kt(Ar,"sendTransaction","onError",Be.MUST_BE_AUTHENTICATED),void o(Error("User must be authenticated before signing with a Privy wallet"));let l=n??S(se)?.address;if(!l)throw new Fe("User must have an embedded wallet to send a transaction.");let{signingWallet:c,rootWallet:p}=x(se,l);if(!p||!c)return kt(Ar,"sendTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have a Privy wallet before signing"));or(!0);let w=ha.wallets.find((e=>"privy"===e.walletClientType&&r(e.address)===r(c.address))),m=await(w?.getEthereumProvider());if(!w||!m)throw new Fe(`Cannot sendTransaction before embedded wallet ${c.address} is connected`);let y=e.chainId?Number(e.chainId):qe(w.chainId);(e=>{if(!ar.chains.map((e=>e.id)).includes(e))throw new He(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,Be.UNSUPPORTED_CHAIN_ID)})(y);let f=Object.assign({},e,{chainId:y});if(kr({showWalletUIs:t?.showWalletUIs}))(async()=>{let e=await Vr();if(!e||!tr)return kt(Ar,"sendTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have valid access token and Privy wallet to send transaction"));try{if(!await ua.recoverPrimaryWallet())return kt(Ar,"sendTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),void o(Error("Unable to connect to wallet"));let r=ne(f.chainId,ar.chains,ar.rpcConfig,{appId:I.appId}),a=await d(c.address,f,r);if(kr({showWalletUIs:t?.showWalletUIs})){let{totalGasEstimate:e}=await u(a,r),{hasSufficientFunds:t}=await Le(c.address,a,e,r);if(!t)throw new Ee(new _e("Wallet has insufficient funds for this transaction.",h.E32603_DEFAULT_INTERNAL_ERROR.eipCode))}let{entropyId:n,entropyIdVerifier:l}=k(p),w=await Me({accessToken:e,entropyId:n,entropyIdVerifier:l,transactingWallet:c,walletProxy:tr,transactionRequest:a,provider:r,requesterAppId:s});kt(Ar,"sendTransaction","onSuccess",w),i(w)}catch(e){kt(Ar,"sendTransaction","onError",Be.TRANSACTION_FAILURE),o(e)}})();else{let{entropyId:e,entropyIdVerifier:r}=k(p),n={entropyId:e,entropyIdVerifier:r,onCompleteNavigateTo:At.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:e=>{kt(Ar,"sendTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),o(e)}},l=lt(ar)?Pt({address:c.address,appConfig:ar,fundWalletConfig:a,methodScreen:At.FUNDING_METHOD_SELECTION_SCREEN,chainIdOverride:f.chainId,comingFromSendTransactionScreen:!0}):void 0;lr({connectWallet:n,sendTransaction:{transactionRequest:f,transactingWallet:c,entropyId:e,entropyIdVerifier:r,onSuccess:e=>{kt(Ar,"sendTransaction","onSuccess",e),i(e)},onFailure:e=>{kt(Ar,"sendTransaction","onError",Be.TRANSACTION_FAILURE),o(e)},uiOptions:t||{},fundWalletConfig:a,requesterAppId:s},funding:l}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),na=({transaction:e,connection:t,transactionOptions:r,fundWalletConfig:a,uiOptions:n,wallet:i})=>new Promise((async(o,s)=>{let{requesterAppId:l}=n||{};if(!$||!se)return kt(Ar,"sendSolanaTransaction","onError",Be.MUST_BE_AUTHENTICATED),void s(new Fe("User must be authenticated before signing with a Privy wallet",Be.MUST_BE_AUTHENTICATED));let c=i?se.linkedAccounts.find((e=>"wallet"===e.type&&e.address===i.address)):L(se);if(!c)return kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void s(new Fe("Must have a Privy wallet before signing",Be.EMBEDDED_WALLET_NOT_FOUND));or(!0);let{rootWallet:d}=F(se,c.address);if(!await ua.recoverPrimaryWallet().catch((()=>!1))||!d)throw kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),new Fe(`Cannot sendSolanaTransaction before embedded wallet ${c.address} is connected`,Be.EMBEDDED_WALLET_NOT_FOUND);if(kr({showWalletUIs:n?.showWalletUIs}))(async()=>{let a=await Vr();if(!a||!tr)return kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void s(new Fe("Must have valid access token and Privy wallet to send transaction",Be.EMBEDDED_WALLET_NOT_FOUND));try{if(!await ua.recoverPrimaryWallet())return kt(Ar,"sendSolanaTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),void s(new Fe("Unable to connect to wallet",Be.UNKNOWN_CONNECT_WALLET_ERROR));if(kr({showWalletUIs:n?.showWalletUIs})){let{instructions:r}=await pt(e,t);r.every((e=>e.hasFunds))||(kt(Ar,"sendSolanaTransaction","onError",Be.INSUFFICIENT_BALANCE),s(new Fe("Solana wallet has insufficient funds for this transaction.",Be.INSUFFICIENT_BALANCE)))}let{entropyId:i,entropyIdVerifier:l}=B(se),{signature:d,receipt:u}=await ze({accessToken:a,tx:e,connection:t,walletProxy:tr,transactionOptions:r,entropyId:i,entropyIdVerifier:l,transactingWalletAddress:c.address,transactingWalletIndex:c.walletIndex??0}),h=wt(d,u);kt(Ar,"sendSolanaTransaction","onSuccess",h),o(h)}catch(e){kt(Ar,"sendSolanaTransaction","onError",Be.TRANSACTION_FAILURE),s(e)}})();else{let{entropyId:i,entropyIdVerifier:u}=k(d),h={entropyId:i,entropyIdVerifier:u,onCompleteNavigateTo:At.EMBEDDED_WALLET_SEND_SOLANA_TRANSACTION_SCREEN,onFailure:e=>{kt(Ar,"sendSolanaTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}},p=lt(ar)?Rt({address:c.address,appConfig:ar,methodScreen:At.FUNDING_METHOD_SELECTION_SCREEN,fundWalletConfig:a,comingFromSendTransactionScreen:!0}):void 0;lr({connectWallet:h,sendSolanaTransaction:{transactionRequest:e,connection:t,transactionOptions:r,transactingWallet:c,onSuccess:e=>{kt(Ar,"sendSolanaTransaction","onSuccess",e),o(e)},onFailure:e=>{kt(Ar,"sendSolanaTransaction","onError",Be.TRANSACTION_FAILURE),s(e)},uiOptions:n||{},requesterAppId:l},funding:p}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}}));function ia(){return new Promise((async(e,t)=>{let r=await Vr();if(!r||!tr)throw Error("Must have valid access token to enroll in MFA");try{await tr.verifyMfa({accessToken:r}),e()}catch(e){t(e)}}))}let oa=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],sa=e=>{let t=se?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:r,loginMethod:a}=mt(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw kt(Ar,"linkAccount","onError",Be.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:a}),new Fe(`User already has an account of type ${r} linked.`)};async function la({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){jt(null);let r=t?"setWalletPassword":"setWalletRecovery";if(!$||!se)throw kt(Ar,r,"onError",Be.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let a=O(se);if(!a||!tr)throw kt(Ar,r,"onError",Be.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");try{await ia()}catch(e){throw kt(Ar,r,"onError",Be.MISSING_MFA_CREDENTIALS),e}return new Promise(((n,i)=>{or(!0);let o={onSuccess:e=>{kt(Ar,r,"onSuccess","user-passcode",e),n(e)},onFailure:e=>{kt(Ar,r,"onError",Be.USER_EXITED_SET_PASSWORD_FLOW),i(e)},callAuthOnSuccessOnClose:!1},s="user-passcode"===a.recoveryMethod,l=it({walletAction:"update",availableRecoveryMethods:ar.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:s,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:d}=k(a);lr({setWalletPassword:o,recoverWallet:{entropyId:c,entropyIdVerifier:d,onFailure:i},createWallet:o,connectWallet:{onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,entropyIdVerifier:d,onFailure:e=>{kt(Ar,r,"onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}},recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:s}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}))}async function ca({appId:e,action:t}){let r=await Vr();if("link"===t&&!r)throw kt(Ar,"linkAccount","onError",Be.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new Fe("User must be authenticated before linking an account.");if("login"===t&&r)throw kt(Ar,"login","onError",Be.UNKNOWN_AUTH_ERROR),new Fe("Attempted to log in, but user is already logged in. Use a `link` helper instead.");Cr.current=`privy:${e}`,Ir.current=t;let a=dt();return W.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(r,n)=>{let{name:i,logoUrl:o}=await Ze({api:W.api,providerAppId:e,requesterAppId:ar.id});lr({crossAppAuth:{appId:e,name:i,logoUrl:o,action:t,popup:a,onSuccess:r,onError:n}}),br(At.CROSS_APP_AUTH_SCREEN)}))}let da={ready:K,authenticated:$,user:se,walletConnectors:W.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),lr({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,suggestedAddress:e?.suggestedAddress}}),Nr($?At.CONNECT_ONLY_AUTHENTICATED_SCREEN:At.CONNECT_ONLY_LANDING_SCREEN)},linkWallet:$r,startCrossAppAuthFlow:ca,linkEmail:()=>{qr("email"),sa("email"),Cr.current="email",Ir.current="link",Nr(At.LINK_EMAIL_SCREEN)},linkPhone:()=>{qr("sms"),sa("phone"),Cr.current="sms",Ir.current="link",Nr(At.LINK_PHONE_SCREEN)},linkGoogle:async()=>{qr("google"),sa("google_oauth"),Ir.current="link",await ua.initLoginWithOAuth("google")},linkTwitter:async()=>{qr("twitter"),sa("twitter_oauth"),Ir.current="link",await ua.initLoginWithOAuth("twitter")},linkDiscord:async()=>{qr("discord"),sa("discord_oauth"),Ir.current="link",await ua.initLoginWithOAuth("discord")},linkGithub:async()=>{qr("github"),sa("github_oauth"),Ir.current="link",await ua.initLoginWithOAuth("github")},linkSpotify:async()=>{qr("spotify"),sa("spotify_oauth"),Ir.current="link",await ua.initLoginWithOAuth("spotify")},linkInstagram:async()=>{qr("instagram"),sa("instagram_oauth"),Ir.current="link",await ua.initLoginWithOAuth("instagram")},linkTiktok:async()=>{qr("tiktok"),sa("tiktok_oauth"),Ir.current="link",await ua.initLoginWithOAuth("tiktok")},linkLinkedIn:async()=>{qr("linkedin"),sa("linkedin_oauth"),Ir.current="link",await ua.initLoginWithOAuth("linkedin")},linkApple:async()=>{qr("apple"),sa("apple_oauth"),Ir.current="link",await ua.initLoginWithOAuth("apple")},linkPasskey:async()=>{qr("passkey"),sa("passkey"),await ua.initLinkWithPasskey(),Nr(At.LINK_PASSKEY_SCREEN)},linkTelegram:async()=>{qr("telegram"),sa("telegram"),Ir.current="link",Cr.current="telegram",await ua.initLoginWithTelegram(),Nr(At.TELEGRAM_AUTH_SCREEN)},linkFarcaster:async()=>{qr("farcaster"),sa("farcaster"),await ua.initLoginWithFarcaster(),Ir.current="link",Cr.current="farcaster",Nr(At.AWAITING_FARCASTER_CONNECTION)},updateEmail:()=>{if(qr("email"),!se?.email)throw new Fe("User does not have an email linked to their account.");Ir.current="update",Cr.current="email",Nr(At.UPDATE_EMAIL_SCREEN)},updatePhone:()=>{if(qr("sms"),!se?.phone)throw new Fe("User does not have a phone number linked to their account.");Ir.current="update",Cr.current="sms",Nr(At.UPDATE_PHONE_SCREEN)},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!K){let e=await new Promise((e=>{dr((t=>e.bind(t)))}));if(dr(null),e)return void console.warn(t)}!se||se.isGuest?(Ir.current="login",lr({login:e}),br(At.LANDING)):console.warn(t)},connectOrCreateWallet:async()=>{K||(await new Promise((e=>{dr((()=>e))})),dr(null)),$?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(Ir.current="login",br(At.CONNECT_OR_CREATE))},logout:async()=>{if(Ir.current=null,Cr.current=null,se&&W.clearProviderAcccessTokens(se),jt(null),await W.logout(),se&&tr)try{await tr.clearMfa({userId:se.id})}catch(e){}ce(null),Y(!1),kt(Ar,"logout","onSuccess"),H(!1),re.del(q),re.del(X(ar.id))},getAccessToken:()=>W.getCustomerAccessToken(),getEthereumProvider:()=>{if(!se||!se.wallet)return new ve;let e=de.find((e=>se.wallet&&e.address===se.wallet.address)),t=W.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new ve},getEthersProvider:()=>{if(!se||!se.wallet)return new a(new Ce(new ve));let e=de.find((e=>se.wallet&&e.address===se.wallet.address)),t=W.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new a(new Ce(e&&t?t.proxyProvider:new ve))},getWeb3jsProvider:()=>{if(!se||!se.wallet)return new Ie(new ve);let e=de.find((e=>se.wallet&&e.address===se.wallet.address)),t=W.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new Ie(e&&t?t.proxyProvider:new ve)},unlinkWallet:async e=>{let t;return ce(t=e.startsWith("0x")?await W.unlinkEthereumWallet(e):await W.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await W.unlinkEmail(e);return ce(t),t},unlinkPhone:async e=>{let t=await W.unlinkPhone(e);return ce(t),t},unlinkGoogle:async e=>{let t=await W.unlinkOAuth("google",e);return ce(t),t},unlinkTwitter:async e=>{let t=await W.unlinkOAuth("twitter",e);return ce(t),t},unlinkDiscord:async e=>{let t=await W.unlinkOAuth("discord",e);return ce(t),t},unlinkGithub:async e=>{let t=await W.unlinkOAuth("github",e);return ce(t),t},unlinkSpotify:async e=>{let t=await W.unlinkOAuth("spotify",e);return ce(t),t},unlinkInstagram:async e=>{let t=await W.unlinkOAuth("instagram",e);return ce(t),t},unlinkTiktok:async e=>{let t=await W.unlinkOAuth("tiktok",e);return ce(t),t},unlinkLinkedIn:async e=>{let t=await W.unlinkOAuth("linkedin",e);return ce(t),t},unlinkApple:async e=>{let t=await W.unlinkOAuth("apple",e);return ce(t),t},unlinkFarcaster:async e=>{let t=await W.unlinkFarcaster(e);return ce(t),t},unlinkTelegram:async e=>{let t=await W.unlinkTelegram(e);return ce(t),t},unlinkPasskey:async e=>{let t=await W.unlinkPasskey(e);return ce(t),t},unlinkCrossAppAccount:async({subject:e})=>{let t=se?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new Fe("Invalid subject");W.storeProviderAccessToken(t.id,null);let r=await W.unlinkOAuth(`privy:${t.id}`,e);return ce(r),r},setActiveWallet:async e=>{let t=de.find((t=>r(t.address)===r(e))),a=se?.linkedAccounts.find((t=>"wallet"===t.type&&r(t.address)===r(e)));if(t&&await t.isConnected())if(t.linked){let e=Object.assign({},se);e.wallet=a&&{address:a.address,chainType:a.chainType,chainId:a.chainId,walletClient:a.walletClient,walletClientType:a.walletClientType,connectorType:a.connectorType,imported:a.imported,delegated:a.delegated,walletIndex:a.walletIndex},ce(e)}else t.loginOrLink();else lr({externalConnectWallet:{suggestedAddress:e}}),$r()},forkSession:()=>W.forkSession(),createWallet:async e=>{if(e&&"target"in e&&e&&(e=void 0),!$||!se)throw kt(Ar,"createWallet","onError",Be.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return Jr(se,15e3,e)},setWalletRecovery:async e=>la({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>la({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t,r)=>new Promise((async(a,n)=>{let{requesterAppId:i}=t||{};if(!$||!se)return kt(Ar,"signMessage","onError",Be.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=r??S(se)?.address;if(!o)throw new Fe("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=x(se,o);if(!s||!l)return kt(Ar,"signMessage","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return kt(Ar,"signMessage","onError",Be.INVALID_MESSAGE),void n(Error("Message must be a non-empty string"));or(!0);let c=async()=>{if(!$)throw Error("User must be authenticated before signing with a Privy wallet");let t=await Vr();if(!tr||!t||!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:r,entropyIdVerifier:a}=k(l),{response:n}=await tr.rpc({accessToken:t,entropyId:r,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"personal_sign",params:[e,s.address]}}),o=n.data;return W.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:s.address,requesterAppId:i}}),o};if(kr({showWalletUIs:t?.showWalletUIs}))try{let e=await c();kt(Ar,"signMessage","onSuccess",e),a(e)}catch(e){kt(Ar,"signMessage","onError",Be.UNABLE_TO_SIGN),n(e??new Ee("Unable to sign message"))}else{let{entropyId:r,entropyIdVerifier:i}=k(l);lr({signMessage:{method:"personal_sign",data:e,confirmAndSign:c,onSuccess:e=>{kt(Ar,"signMessage","onSuccess",e),a(e)},onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:r,entropyIdVerifier:i,onCompleteNavigateTo:At.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),signTypedData:(e,t,r)=>new Promise((async(a,n)=>{let{requesterAppId:i}=t||{};if(!$||!se)return kt(Ar,"signTypedData","onError",Be.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=r??S(se)?.address;if(!o)throw new Fe("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=x(se,o);if(!l||!s)return kt(Ar,"signTypedData","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));or(!0);let c=ie(e),d=async()=>{if(!$)throw Error("User must be authenticated before signing with a Privy wallet");let e=await Vr();if(!tr||!e||!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:t,entropyIdVerifier:r}=k(l),{response:a}=await tr.rpc({accessToken:e,entropyId:t,entropyIdVerifier:r,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"eth_signTypedData_v4",params:[s.address,c]}}),n=a.data;return W.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:s.address,requesterAppId:i}}),n};if(kr({showWalletUIs:t?.showWalletUIs,typedData:!0}))try{let e=await d();kt(Ar,"signTypedData","onSuccess",e),a(e)}catch(e){kt(Ar,"signTypedData","onError",Be.UNABLE_TO_SIGN),n(e??new Ee("Unable to sign message"))}else{let{entropyId:e,entropyIdVerifier:r}=k(l);lr({signMessage:{method:"eth_signTypedData_v4",data:c,confirmAndSign:d,onSuccess:e=>{kt(Ar,"signTypedData","onSuccess",e),a(e)},onFailure:e=>{kt(Ar,"signTypedData","onError",Be.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:e,entropyIdVerifier:r,onCompleteNavigateTo:At.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),sendTransaction:async(e,t,r,a)=>{let n=await aa(e,t,r,a);return De(await n.wait())},sendSolanaTransaction:async(e,t,r,a,n,i)=>{let o=i?me.find((({address:e})=>e===i)):me.slice().sort(((e,t)=>(e.walletIndex??0)-(t.walletIndex??0)))[0];if(!o)throw kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),new Fe("Embedded wallet not found",Be.EMBEDDED_WALLET_NOT_FOUND);return await na({transaction:e,connection:t,transactionOptions:a,uiOptions:r,fundWalletConfig:n,wallet:o})},exportWallet:e=>new Promise((async(t,r)=>{if(!$||!se)return void r(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let a=e?.address??S(se)?.address;if(!a)return void r(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));let{signingWallet:n,rootWallet:i}=x(se,a);if(!n||!i)return void r(Error("Must have a Privy wallet before exporting"));or(!0);let{entropyId:o,entropyIdVerifier:s}=k(i),l={entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:At.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:r,shouldForceMFA:!0};lr(sr),await Vr()&&tr?tr?(lr({keyExport:{appId:I.appId,appClientId:I.clientId,origin:W.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:r},connectWallet:l}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)):r(Error("Must have a Privy wallet before exporting")):r(Error("Must have valid access token to enroll in MFA"))})),promptMfa:ia,async init(e){switch(e){case"sms":return void await W.initMfaSmsVerification();case"passkey":return await W.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new Fe("Invalid MFA code");Er.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{_r.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new Fe("Invalid authenticator response");let r=await import("@simplewebauthn/browser"),a=yt(await r.startAuthentication(t));Er.current?.resolve({mfaMethod:e,mfaCode:a,relyingParty:window.origin}),await new Promise(((e,t)=>{_r.current={resolve:e,reject:t}}));break;default:throw Er.current?.reject(new Fe("Unsupported MFA method")),new Fe(`Unsupported MFA method: ${e}`)}},cancel(){Er.current?.reject(new Fe("MFA canceled"))},async initEnrollmentWithSms(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,r)=>{if(!e)return ua.closePrivyModal(),void t();ar.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),lr({mfaEnrollmentFlow:{mfaMethods:ar.mfa.methods,onSuccess:t,onFailure:r}}),Nr(At.MFA_ENROLLMENT_FLOW_SCREEN)})),async initEnrollmentWithTotp(){let e=await Vr();if(!e||!tr)throw Error("Must have valid access token to enroll in MFA");let t=await tr.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),ce(await W.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),ce(await W.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e}){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:e}),ce(await W.getAuthenticatedUser())},async unenroll(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to remove MFA");"passkey"===e?await tr.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:[]}):await tr.unenrollMfa({method:e,accessToken:t}),ce(await W.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await Vr(),t=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");let r=await tr.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===r.status&&ce(await W.getAuthenticatedUser()||se||null),lr({farcasterSigner:r}),Nr(At.AWAITING_FARCASTER_SIGNER)},getFarcasterSignerPublicKey:async()=>{let e,t=await Vr(),r=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!se.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=se.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await Vr(),r=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!se.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let a=await import("@simplewebauthn/browser"),n=await tr.signFarcasterMessage({address:r.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:a.bufferToBase64URLString(e)},fid:BigInt(se.farcaster.fid),relyingParty:window.origin});return new Uint8Array(a.base64URLStringToBuffer(n.signature))},createGuestAccount:async()=>{if(se&&!se.isGuest)throw Error("User cannot already be authenticated to create a guest account");return se?.isGuest?se:ua.loginWithGuestAccountFlow()},signMessageWithCrossAppWallet(e,{address:t}){let r=se?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return tt({user:se,client:W,address:t,requesterAppId:ar.id,request:{method:r?"privy_signSmartWalletMessage":"personal_sign",params:[e,t]},reconnect:ca})},signTypedDataWithCrossAppWallet(e,{address:t}){let r=se?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),a=ie(e);return tt({user:se,client:W,address:t,requesterAppId:ar.id,request:{method:r?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,a]},reconnect:ca})},sendTransactionWithCrossAppWallet(e,{address:t}){let r=se?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return tt({user:se,client:W,address:t,requesterAppId:ar.id,request:{method:r?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e]},reconnect:ca})},isModalOpen:V,mfaMethods:ar.mfa.methods};Dr=da.signMessage,Lr=da.signTypedData,Mr=async(...e)=>{let t=await aa(...e);return ar.embeddedWallets.waitForTransactionConfirmation&&await t.wait(),t};let ua={setAuthenticated:Y,setUser:ce,isNewUserThisSession:Mt,pendingTransaction:null,walletConnectionStatus:Ht,connectors:W.connectors?.walletConnectors??[],solanaWallets:me,rpcConfig:ar.rpcConfig,chains:ar.chains,appId:I.appId,showFiatPrices:"native-token"!==ar.embeddedWallets.priceDisplay.primary,clientAnalyticsId:W.clientAnalyticsId,customAuthStatus:fr,noPromptOnSignature:Wr,emailOtpState:qt,setEmailOtpState:$t,smsOtpState:Yt,setSmsOtpState:Xt,oAuthState:Zt,setOAuthState:er,siweState:Qt,setSiweState:Jt,isHeadlessOAuthLoading:Bt,nativeTokenSymbolForChainId:e=>ar.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(tr)return tr;let t=new Promise((e=>{hr((()=>t=>e(t)))})),r=new Promise((t=>setTimeout((()=>t(null)),e))),a=await Promise.race([t,r]);return hr(null),a},getAuthFlow:()=>W.authFlow,getAuthMeta:()=>W.authFlow?.meta,client:W,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,r=K&&$&&se;r&&Cr.current&&(t=oa(se)),"login"===Ir.current?e.shouldCallAuthOnSuccess&&r&&Cr.current?(kt(Ar,"login","onComplete",se,Mt,!1,Cr.current,t??null),I.onSuccess?.(se,Mt)):kt(Ar,"login","onError",Be.USER_EXITED_AUTH_FLOW):"link"===Ir.current&&t?e.isSuccess&&r&&Cr.current?kt(Ar,"linkAccount","onSuccess",se,Cr.current,t):Cr.current&&kt(Ar,"linkAccount","onError",Be.USER_EXITED_LINK_FLOW,{linkMethod:Cr.current}):"update"===Ir.current&&t&&(e.isSuccess&&r&&Cr.current?kt(Ar,"update","onSuccess",se,Cr.current,t):Cr.current&&kt(Ar,"update","onError",Be.USER_EXITED_UPDATE_FLOW,{linkMethod:Cr.current}));let a=xt&&ot.includes(xt),n=xt===At.ERROR_SCREEN&&sr.errorModalData&&ot.includes(sr.errorModalData.previousScreen);if((a||n)&&sr.funding){let e,t=st[xt]??null;if("solana"===sr.funding.chainType){let r=N(Et);if(!r)return void console.warn("Unable to load solana plugin, skipping balance");try{e=BigInt(await r.getBalance({address:sr.funding.address,cluster:sr.funding.cluster}))}catch{console.error("Unable to pull wallet balance")}kt(Ar,"fundSolanaWallet","onUserExited",{address:sr.funding.address,cluster:sr.funding.cluster,fundingMethod:t,balance:e})}else{let r=ne(sr.funding.chain.id,ar.chains,ar.rpcConfig,{appId:I.appId});try{e=(await r.getBalance(sr.funding.address)).toBigInt()}catch{console.error("Unable to pull wallet balance")}kt(Ar,"fundWallet","onUserExited",{address:sr.funding.address,chain:sr.funding.chain,fundingMethod:t,balance:e})}}lr({...sr,externalConnectWallet:{suggestedAddress:void 0}}),Ir.current=null,Cr.current=null,Ft(!1),H(!1),setTimeout((()=>{W.authFlow=void 0}),200),W.createAnalyticsEvent({eventName:"modal_closed"})},solanaSignMessage:({message:e,address:t})=>new Promise((async(r,a)=>{if(!$||!se)return kt(Ar,"signMessage","onError",Be.MUST_BE_AUTHENTICATED),void a(Error("User must be authenticated before signing with a Privy wallet"));let n=t??L(se)?.address;if(!n)throw new Fe("User must have an embedded wallet to sign a message.");let{signingWallet:i,rootWallet:o}=F(se,n);if(!i||!o)return kt(Ar,"signMessage","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void a(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return kt(Ar,"signMessage","onError",Be.INVALID_MESSAGE),void a(Error("Message must be a non-empty string"));or(!0);let s=async()=>{if(!$)throw Error("User must be authenticated before signing with a Privy wallet");let t=await W.getAccessToken();if(!t)throw Error("User must be authenticated to use their embedded wallet.");let r=ua.walletProxy??await ua.initializeWalletProxy(15e3);if(!r)throw Error("Failed to initialize embedded wallet proxy.");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!o)throw Error("No root wallet for signing wallet found");let{entropyId:a,entropyIdVerifier:n}=k(o),{response:s}=await r.rpc({accessToken:t,entropyId:a,entropyIdVerifier:n,chainType:"solana",hdWalletIndex:i.walletIndex??0,request:{method:"signMessage",params:{message:e}}});return s.data.signature};if(kr({showWalletUIs:void 0}))try{let e=await s();r({signature:e})}catch(e){a(e)}else{let{entropyId:t,entropyIdVerifier:n}=k(o);lr({signMessage:{method:"solana_signMessage",data:e,confirmAndSign:s,onSuccess:e=>{r({signature:e})},onFailure:e=>{a(e)},uiOptions:{}},connectWallet:{entropyId:t,entropyIdVerifier:n,onCompleteNavigateTo:At.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),a(e)}}}),br(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),openPrivyModal:Nr,connectWallet:Hr,initLoginWithWallet:async(e,t,r)=>{Te(e)?(Cr.current="siwe",Kr(e,t,r)):(Cr.current="siws",Gr(e,t))},loginWithWallet:async()=>{let e,t,r;if(!K)throw new Ve;if(W.authFlow instanceof E?e="siwe":W.authFlow instanceof _&&(e="siws"),!e)throw new Fe("Must initialize SIWE/SIWS flow first.");if(null!==await W.getAccessToken())try{({user:t}=await W.link()),Cr.current=e}catch(t){throw kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:r}=await W.authenticate()),Cr.current=e}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.GENERIC_CONNECT_WALLET_ERROR),e}ce(t||se||null),Ft(r||!1),Y(!0)},delegateWallet:async({address:e,chainType:t})=>new Promise((async(r,a)=>{let n=await Vr();if(!$||!se||!n)throw new Fe("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new Fe("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let i=ua.walletProxy??await ua.initializeWalletProxy(15e3);if(!i)throw new Fe("Wallet proxy not initialized.");if(Ue({address:e,chainType:t,user:se}))return r();let o=Oe({address:e,user:se}),s=Se({address:e,user:se});await ua.recoverPrimaryWallet(),lr({delegatedActions:{consent:{address:e,onDelegate:async()=>{await i.createDelegatedAction({accessToken:n,rootWallet:s,delegatedWallets:[o]}),await ua.refreshUser()},onSuccess:async()=>{r()},onError:async e=>{a(e)}}}}),Nr(At.EMBEDDED_WALLET_DELEGATED_ACTIONS_CONSENT_SCREEN)})),revokeDelegatedWallets:async()=>new Promise((async(e,t)=>{if(!$||!se)throw new Fe("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");if(0===Re(se).length)throw new Fe("User has no delegated wallets to revoke.");lr({delegatedActions:{revoke:{onRevoke:async()=>{await W.revokeDelegatedWallet(),await ua.refreshUser()},onSuccess:async()=>{e()},onError:async e=>{t(e)}}}}),Nr(At.EMBEDDED_WALLET_DELEGATED_ACTIONS_REVOKE_SCREEN)})),initLoginWithFarcaster:async(e,t)=>{let r=new y(e,t);W.startAuthFlow(r);try{Cr.current="farcaster",await r.initializeFarcasterConnect()}catch(e){throw"login"===Ir.current?kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!K)throw new Ve;if(!(W.authFlow instanceof y))throw new Fe("Must initialize Farcaster flow first.");if(null!==await W.getAccessToken())try{({user:e}=await W.link()),Cr.current="farcaster"}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await W.authenticate()),Cr.current="farcaster"}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}ce(e||null),Ft(t||!1),Y(!0)},async loginWithGuestAccountFlow(){let e=new f(this.appId);W.startAuthFlow(e);try{Ir.current="login",Cr.current="guest";let{user:e,isNewUser:t}=await W.authenticate();if(t=t||!1,!e)throw new Fe("Unable to authenticate guest account");if(D(e,ar.embeddedWallets.createOnLogin))try{await Jr(e,15e3),e=await ua.refreshUser()}catch(t){ce(e),console.warn("Unable to create embedded wallet for guest account")}else ce(e);return Ft(t),Y(!0),kt(Ar,"login","onComplete",e,t,!1,"guest",null),e}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}},async crossAppAuthFlow({appId:e,popup:t,action:r}){let a=`privy:${e}`;Cr.current=a;let{url:n,stateCode:i,codeVerifier:o}=await Qe({api:W.api,appId:e});if(!n)throw W.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new Fe("No authorization URL returned for cross-app auth.");try{let s=await et({url:n,popup:t,provider:a}),l=s.stateCode,c=s.authorizationCode;if(l!==i)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:a,storedStateCode:i??"",returnedStateCode:l??""}}),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED);let d=await Je({appId:e,codeVerifier:o,stateCode:l,authorizationCode:c,action:r,client:W});d&&W.storeProviderAccessToken(e,d);let u=await ua.refreshUser();if(!u)throw new Fe("Unable to update user");return W.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),u}catch(e){throw W.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:a}}),e}},async initLoginWithOAuth(e,t,r){if(Cr.current=e,!ae())return void br(At.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);if("google"===e&&ct(window.navigator.userAgent))return void br(At.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);"twitter"===e&&window.opener&&window.opener.postMessage({type:$e},"*"),re.del(Q),re.del(J);let a=new Lt({provider:e,disableSignup:!!r,withPrivyUi:!0});t&&a.addCaptchaToken(t),W.startAuthFlow(a);let n=await W.authFlow.getAuthorizationUrl();n&&n.url&&("twitter"===e&&c&&(n.url=n.url.replace("x.com","twitter.com")),window.location.assign(n.url))},async initLoginWithTelegram(e,t){if(!K)throw new Ve;Cr.current="telegram";let r=new v(e,t);W.startAuthFlow(r),r.meta.telegramWebAppData=void 0,r.meta.telegramAuthResult=await new Promise(((e,t)=>ar.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:ar.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(r=>r?e(r):t(new Fe("Telegram auth failed or was canceled by the client")))):t(new Fe("Telegram was not initialized")):t(new Fe("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,r;if(!(W.authFlow instanceof v))throw new Fe("Must initialize Telegram flow before calling loginWithTelegram");if(W.authFlow.meta.captchaToken||=e,"login"===Ir.current)try{let e=await W.authenticate();t=e.user,r=e.isNewUser,Cr.current="telegram"}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}else{if("link"!==Ir.current)throw new Fe("Unknown auth intent");try{t=(await W.link()).user,Cr.current="telegram"}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}ce(t),Ft(r||!1),Y(!0)},async recoveryOAuthFlow(e,t,r){let a,n;function i(t){if(!t)throw W.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:e}}),new Fe("Recovery OAuth failed")}switch(e){case"google-drive":{let t,o,{url:s,codeVerifier:l,stateCode:c}=await rt({api:Pr.api,provider:e});i(s);try{let a=await ut({url:s,popup:r,provider:e});if(t=a.stateCode,o=a.authorizationCode,t!==c)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:c??"",returnedStateCode:t??""}}),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED)}catch(t){throw W.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:t.toString(),provider:e}}),new Fe("Recovery OAuth failed")}[a,n]=await Promise.all([Vr(),at({api:Pr.api,provider:e,codeVerifier:l,stateCode:t,authorizationCode:o})]);break}case"icloud":{let{url:t}=await rt({api:Pr.api,provider:e});i(t);let{ckWebAuthToken:o}=await ut({url:t,popup:r,provider:e});n=o,a=await Vr()}}if(!tr)throw new Fe("Cannot connect to wallet proxy");if(!a)throw new Fe("Unable to authorize user");switch(t){case"recover":{let t=sr.recoverWallet?.entropyId,r=sr.recoverWallet?.entropyIdVerifier;if(!t||!r)throw new Fe("Recovery OAuth failed");W.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:t,recoveryMethod:e}}),await tr.recover({accessToken:a,entropyId:t,entropyIdVerifier:r,recoveryAccessToken:n}),W.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:t,recoveryMethod:e}});break}case"create-wallet":{W.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),await tr.create({accessToken:a,recoveryAccessToken:n,recoveryMethod:e});let t=S(await ua.refreshUser());if(!t)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:t.address}}),kt(Ar,"createWallet","onSuccess",t);break}case"set-recovery":{let t=O(se);if(!t)throw kt(Ar,"setWalletRecovery","onError",Be.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");W.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}});let{entropyId:r,entropyIdVerifier:i}=k(t);await tr.setRecovery({accessToken:a,entropyId:r,entropyIdVerifier:i,recoveryMethod:e,recoveryAccessToken:n});let o=O(await ua.refreshUser());if(!o)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}}),kt(Ar,"setWalletRecovery","onSuccess",e,o);break}default:throw new Fe("Unsupported recovery action")}},async loginWithOAuth(e){let t,r,a;if(!(W.authFlow instanceof Lt))throw new Fe("Must initialize OAuth flow before calling loginWithOAuth");let n=re.get(Z),i=W.authFlow.meta.stateCode;if(n!==i)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:n??"",returnedStateCode:i??""}}),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED);if(null!==await W.getAccessToken())try{let r=await W.link();t=r.user,a=r.oAuthTokens,Cr.current=e}catch(t){throw kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let n=await W.authenticate();t=n.user,r=n.isNewUser,a=n.oAuthTokens,Cr.current=e}catch(t){throw"login"===Ir.current?kt(Ar,"login","onError",t.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return ce(t),Ft(r||!1),Y(!0),a&&t&&kt(Ar,"oAuthAuthorization","onOAuthTokenGrant",a,{user:t}),a},passkeyAuthState:Gt,setPasskeyAuthState:zt,async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let r=new g({captchaToken:e,setPasskeyAuthState:zt});W.startAuthFlow(r),Ir.current="login";try{Cr.current="passkey",zt({status:"generating-challenge"}),await r.initAuthenticationFlow(t),zt({status:"awaiting-passkey"})}catch(e){throw zt({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(){let e,t;if(!K)throw new Ve;if(!(W.authFlow instanceof g))throw new Fe("Must initialize Passkey flow first.");if("passkey"!==Cr.current){let e=new Fe("Must init login with Passkey flow first.");throw zt({status:"error",error:e}),e}let r=await Vr();try{Cr.current="passkey",zt({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await W.authenticate())}catch(e){throw zt({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}ce(e),Ft(t||!1),Y(!0),zt({status:"done"});let a=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!r,loginAccount:a}},async initLinkWithPasskey(e){let t=new g({captchaToken:e});W.startAuthFlow(t),Ir.current="link",Cr.current="passkey",zt({status:"generating-challenge"});try{await t.initLinkFlow(),zt({status:"awaiting-passkey"})}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),zt({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!K)throw new Ve;if(!(W.authFlow instanceof g))throw new Fe("Must initialize Passkey flow first.");if("passkey"!==Cr.current)throw new Fe("Must init login with Passkey flow first.");try{Cr.current="passkey",({user:e}=await W.link())}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return ce(e||se||null),zt({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,r){if(!ae())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&ct(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let a=new Lt({provider:e,withPrivyUi:!1,disableSignup:r??!1});t&&a.addCaptchaToken(t),er({status:"loading"});let n=await W.startAuthFlow(a).getAuthorizationUrl();n?.url&&window.location.assign(n.url)},async loginWithHeadlessOAuth(e){let t,r,a;Vt(!0),er({status:"loading"}),W.startAuthFlow(new Lt(e));let n=re.get(Z),i=e.stateCode;if(n!==i)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:n??"",returnedStateCode:i??""}}),Vt(!1),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED);if(null!==await W.getAccessToken())try{({user:t,oAuthTokens:a}=await W.link()),Cr.current=e.provider;let r=oa(t);t&&r&&kt(Ar,"linkAccount","onSuccess",t,Cr.current,r)}catch(t){throw Vt(!1),kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:r,oAuthTokens:a}=await W.authenticate()),Cr.current=e.provider;let n=oa(t);t&&n&&void 0!==r&&kt(Ar,"login","onComplete",t,r,!1,Cr.current,n)}catch(e){throw Vt(!1),er({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}return ce(t),Ft(r||!1),Y(!0),Vt(!1),er({status:"done"}),a&&t&&kt(Ar,"oAuthAuthorization","onOAuthTokenGrant",a,{user:t}),t??void 0},initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:r,withPrivyUi:a})=>{let n=new m({email:e,captchaToken:t,disableSignup:r});W.startAuthFlow(n);try{Cr.current="email",$t({status:"sending-code"}),await n.sendCodeEmail({withPrivyUi:a}),$t({status:"awaiting-code-input"})}catch(e){throw $t({status:"error",error:e}),"login"===Ir.current?kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async(e,t,r)=>{let a=new w(e,t,r);W.startAuthFlow(a);try{await a.sendCodeEmail({withPrivyUi:!0})}catch(e){kt(Ar,"update","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:Cr.current})}},initUpdatePhone:async(e,t,r)=>{let a=new A(e,t,r);W.startAuthFlow(a);try{await a.sendSmsCode({withPrivyUi:!0})}catch(e){kt(Ar,"update","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:Cr.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:r,withPrivyUi:a})=>{Xt({status:"sending-code"});let n=new T({phoneNumber:e,captchaToken:t,disableSignup:r});W.startAuthFlow(n);try{Cr.current="sms",await n.sendSmsCode({withPrivyUi:a}),Xt({status:"awaiting-code-input"})}catch(e){throw Xt({status:"error",error:e}),"login"===Ir.current?kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(W.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(W.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,r;function a(e){W.authFlow instanceof m?$t(e):W.authFlow instanceof T&&Xt(e)}if(a({status:"submitting-code"}),!K){let e=new Ve;throw a({status:"error",error:e}),e}if(W.authFlow instanceof m)W.authFlow.meta.emailCode=e.trim();else{if(!(W.authFlow instanceof T)){let e=new Fe("Must initialize a passwordless code flow first");throw a({status:"error",error:e}),e}W.authFlow.meta.smsCode=e.trim()}let n=await Vr();if("link"===Ir.current)try{({user:t}=await W.link())}catch(e){throw a({status:"error",error:e}),kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:Cr.current}),e}else if("update"===Ir.current)try{({user:t}=await W.link())}catch(e){throw a({status:"error",error:e}),kt(Ar,"update","onError",e.privyErrorCode||Be.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:Cr.current}),e}else try{({user:t,isNewUser:r}=await W.authenticate())}catch(e){throw a({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}let i=t||se;ce(i||null),Ft(r||!1),Y(!0),a({status:"done"});let o=null;return W.authFlow instanceof m?o=i?.linkedAccounts.find((({type:e})=>"email"===e))||null:W.authFlow instanceof T&&(o=i?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:i,isNewUser:r||!1,wasAlreadyAuthenticated:!!n,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:r})=>{Ir.current="link",Cr.current="siwe",Jt({status:"generating-message"});let a=await W.generateSiweNonce({address:e,captchaToken:r});return Jt({status:"awaiting-signature"}),ht({address:e,chainId:t.replace("eip155:",""),nonce:a})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let r=await W.generateSiweNonce({address:e});return ht({address:e,chainId:t.replace("eip155:",""),nonce:r})},linkSmartWallet:async({message:e,signature:t,smartWalletType:r})=>{let a;a=await W.linkSmartWallet({message:e,signature:t,smartWalletType:r}),ce((a=await ua.refreshUser()??a)||se||null)},linkWithSiwe:async({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n})=>{let i;qr("siwe");let o=null;try{Jt({status:"submitting-signature"}),i=await W.linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}),i=await ua.refreshUser()??i,Jt({status:"done"}),(o=oa(i)||null)&&kt(Ar,"linkAccount","onSuccess",i,"siwe",o)}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),Ir.current=null,Cr.current=null,Jt({status:"error",error:e}),e}let s=i||se;return ce(s||null),Ir.current=null,Cr.current=null,{user:s,linkedAccount:o}},refreshUser:async()=>{let e=await W.getAuthenticatedUser();return Y(!!e),ce(e),e},walletProxy:tr,createAnalyticsEvent:({eventName:e,payload:t,timestamp:r})=>W.createAnalyticsEvent({eventName:e,payload:t,timestamp:r}),acceptTerms:async()=>{let e=await W.acceptTerms();return ce(e),e},getUsdTokenPrice:e=>W.getUsdTokenPrice(e),getUsdPriceForSol:()=>W.getUsdPriceForSol(),recoverPrimaryWallet:async e=>new Promise((async(t,r)=>{let a=O(e?.user??se)||P(e?.user??se)||U(e?.user??se),n=await Vr();if(!n||!tr||!a)return void r(Error("Must have valid access token and Privy wallet to recover wallet"));or(!0);let{entropyId:i,entropyIdVerifier:o}=k(a);try{await tr.connect({accessToken:n,entropyId:i,entropyIdVerifier:o}),t(!0)}catch(e){Pe(e)&&"privy"===a.recoveryMethod?(W.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:a.address}}),(await tr.recover({entropyId:i,entropyIdVerifier:o,accessToken:n})).entropyId||r(Error("Unable to recover wallet")),W.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:a.address}}),t(!0)):Pe(e)&&"privy"!==a.recoveryMethod?(lr({recoverWallet:{entropyId:i,entropyIdVerifier:o,onFailure:r,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:a.recoveryMethod,action:"recover"}}),Nr(nt(a.recoveryMethod))):r(e)}})),createEmbeddedSolanaWallet:async e=>{if(e&&"target"in e&&(e=void 0),!$||!se)throw kt(Ar,"createWallet","onError",Be.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return(async(e,t,r)=>{let a=S(e),n=L(e),i=r&&"createAdditional"in r&&r.createAdditional,o=r&&"walletIndex"in r?r.walletIndex:void 0,s=(j(e)?.walletIndex??-1)+1;if(n&&!i&&"number"!=typeof o)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");if("number"==typeof o&&o<0)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${o}) is invalid.`);let[l,c]=await Promise.all([ua.initializeWalletProxy(t),Vr()]);if(!l||!c)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return await ta({user:e,wp:l,accessToken:c,walletIndex:o??s,ethereumWallet:a})})(se,15e3,e)},exportSolanaWallet:e=>new Promise((async(t,r)=>{if(!$||!se)return void r(Error("User must be authenticated before exporting their Privy wallet"));let a=e?.address??L(se)?.address;if(!a)return void r(Error("User does not have an HD Solana wallet."));let{signingWallet:n,rootWallet:i}=F(se,a);if(!n||!i)return void r(Error("Must have a Privy wallet before exporting"));if(or(!0),!await Vr()||!tr)return void r(Error("Must have valid access token to enroll in MFA"));if(!tr)return void r(Error("Must have a Privy wallet before exporting"));let{entropyId:o,entropyIdVerifier:s}=k(i);lr({connectWallet:{entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:At.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:r,shouldForceMFA:!0},keyExport:{appId:I.appId,appClientId:I.clientId,origin:W.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:r}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)})),setReadyToTrue:e=>{z(!0),cr?.(e)},updateWallets:()=>Qr(),fundWallet:async(e,t)=>{let r=At.FUNDING_METHOD_SELECTION_SCREEN;lr({funding:Pt({address:e,appConfig:ar,fundWalletConfig:t,methodScreen:r})}),Nr(r)},openModal:Nr,requestFarcasterSignerStatus:async e=>{let t=await Vr(),r=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let a=await W.requestFarcasterSignerStatus(e);return"approved"===a.status&&ce(await W.getAuthenticatedUser()||se||null),a},connectCoinbaseSmartWallet:async()=>{ar.externalWallets.coinbaseWallet.connectionOptions="smartWalletOnly";let e=W.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||W.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),Hr(e);await Br("coinbase_wallet","coinbase_smart_wallet")},initiateAccountTransfer:async({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o})=>{let s=await W.sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o});return ce(s),s}};Fr=ua.recoverPrimaryWallet,xr=ua.recoverPrimaryWallet,jr=ua.solanaSignMessage;let ha=l((()=>({wallets:de,ready:pr&&Tr})),[de,pr,Tr]),pa=W.authFlow instanceof v,wa=!ar.headless&&ar.captchaEnabled&&!$&&(K||pa);/*#__PURE__*/return e(Ot.Provider,{value:da,children:/*#__PURE__*/e(Nt.Provider,{value:Ar,children:/*#__PURE__*/e(St.Provider,{value:ha,children:/*#__PURE__*/e(It,{...ar,children:/*#__PURE__*/t(bt.Provider,{value:ua,children:[/*#__PURE__*/e(_t,{children:/*#__PURE__*/t(Ut,{data:sr,setModalData:lr,setInitialScreen:jt,initialScreen:xt,authenticated:$,open:V,children:[I.children,wa&&/*#__PURE__*/e(he,{delayedExecution:!1}),/*#__PURE__*/e(vt,{theme:{...ar.appearance.palette||{}}}),!ar.render.standalone&&/*#__PURE__*/e(pe,{open:V})]})}),ir&&nr?/*#__PURE__*/e(be,{appId:I.appId,appClientId:I.clientId,clientAnalyticsId:W.clientAnalyticsId,origin:W.apiUrl,mfaMethods:se?.mfaMethods,mfaPromise:Er,mfaSubmitPromise:_r,onLoad:rr,onLoadFailed:()=>null}):null,ar.loginConfig.telegramAuthConfiguration&&
+import{jsx as e,jsxs as t}from"react/jsx-runtime";import{getAddress as r}from"@ethersproject/address";import{Web3Provider as a}from"@ethersproject/providers";import{createStore as n}from"mipd";import{useState as i,useRef as o,useEffect as s,useMemo as l}from"react";import{isAndroid as c}from"react-device-detect";import{populateTransactionRequest as d,calculateTotalGasEstimate as u,ProviderErrors as h}from"@privy-io/js-sdk-core";import{CustomJwtAccountFlow as p}from"./auth-flows/custom-jwt-account.mjs";import{UpdateEmailFlow as w,EmailFlow as m}from"./auth-flows/email.mjs";import{FarcasterFlow as y}from"./auth-flows/farcaster.mjs";import{GuestFlow as f}from"./auth-flows/guest.mjs";import{PasskeyFlow as g}from"./auth-flows/passkey.mjs";import{SiweFlow as E}from"./auth-flows/siwe.mjs";import{SiwsFlow as _}from"./auth-flows/siws.mjs";import{UpdateSmsFlow as A,SmsFlow as T}from"./auth-flows/sms.mjs";import{TelegramAuthFlow as v,detectCompletingTelegramFlow as C}from"./auth-flows/telegram.mjs";import{v4 as I}from"uuid";import{AccessToken as W}from"./accessToken.mjs";import{getEntropyDetailsFromAccount as k,convertUserResponseToUser as N,getPrivySolanaHDWallets as b,getImportedPrivySolanaWallet as U,getPrivyPrimaryWallet as O,getPrivyEthereumWallet as S,getPrivyEthereumHDWallets as R,getImportedPrivyEthereumWallet as P,shouldProceedtoEmbeddedWalletCreationFlow as D,getPrivySolanaWallet as L,getLatestPrivyEthereumWallet as M,getSolanaSigningAndRootWallet as F,getEthereumSigningAndRootWallet as x,getLatestPrivySolanaWallet as j,getEntropyDetailsFromUser as B}from"./client/user.mjs";import V from"eventemitter3";import{CONNECTORS_STATE_KEY as H,CONNECTIONS_HISTORY_KEY as K,DEFAULT_PRIVY_API_URL as G,DEFAULT_API_TIMEOUT_MS as z,CLIENT_ANALYTICS_ID_KEY as q,CUSTOMER_ACCESS_TOKEN_STORAGE_KEY as $,PRIVY_ACCESS_TOKEN_STORAGE_KEY as Y,getGuestCredentialStorageKey as X,HEADLESS_OAUTH_KEY as Q,OAUTH_DISABLE_SIGNUP_KEY as J,STATE_CODE_KEY as Z,WALLET_PROXY_TIMEOUT as ee,FORKED_TOKEN_STORAGE_KEY as te}from"./constants.mjs";import re,{isLocalStorageAccessible as ae}from"./storage.mjs";import{getJsonRpcProvider as ne,generateTypedDataWithDomainType as ie,toHex as oe,detectInjectedConnectors as se,formatChainIdToCAIP2 as le}from"./utils/index.mjs";import{CoinbaseWalletConnector as ce}from"./connectors/coinbase.mjs";import{EmbeddedWalletConnector as de}from"./connectors/embedded.mjs";import{isSupportedEthereumRpcMethod as ue}from"./embedded-wallets/rpc/types.mjs";import{Captcha as he}from"./components/Captcha.mjs";import{LoginModal as pe}from"./components/LoginModal.mjs";import{TelegramLoginButton as we}from"./components/TelegramLoginButton.mjs";import{PrivyAppConfigProvider as me,useAppConfig as ye,useIsServerConfigLoaded as fe}from"./configuration/context.mjs";import{areWalletArraysEqual as ge}from"./connectors/areWalletArraysEqual.mjs";import{PrivyProviderRpcError as Ee,ProviderRpcError as _e}from"./connectors/errors.mjs";import{isPhantomInstalled as Ae}from"./connectors/is-wallet-installed.mjs";import{isBaseConnectedEthereumWallet as Te}from"./connectors/isBaseConnectedEthereumWallet.mjs";import{PrivyProxyProvider as ve,AsExternalProvider as Ce,AsAbstractProvider as Ie}from"./connectors/privyProxyProvider.mjs";import{isSolanaWalletConnector as We,isBaseConnectedSolanaWallet as ke}from"./connectors/solana/index.mjs";import{WalletConnectV2WalletConnector as Ne}from"./connectors/walletconnect-v2.mjs";import{EmbeddedWalletIframe as be}from"./embedded-wallets/EmbeddedWalletIframe.mjs";import{isWalletDelegated as Ue,getDelegatedWalletsData as Oe,getRootWalletDataForDelegation as Se,getDelegatedWalletsForUser as Re}from"./embedded-wallets/delegated-actions.mjs";import{errorIndicatesRecoveryIsNeeded as Pe}from"./embedded-wallets/errors.mjs";import{formatReceipt as De,getAndCheckBalance as Le,sendTransaction as Me}from"./embedded-wallets/rpc/index.mjs";import{PrivyClientError as Fe,formatApiError as xe,formatPrivyError as je,PrivyErrorCode as Be,PrivyNotReadyError as Ve,PrivyConnectorError as He,PrivyError as Ke}from"./errors.mjs";import{signSolanaTransaction as Ge,sendSolanaTransaction as ze}from"./embedded-wallets/solana/transaction.mjs";import{extractChainIdFromCAIP2 as qe}from"./lib/caip2.mjs";import{USE_BROADCAST_CHANNEL_EVENT_TYPE as $e,isPrivyTheOAuthProvider as Ye,CROSS_APP_BROADCAST_CHANNEL_NAME as Xe}from"./lib/cross-app/index.mjs";import{getCrossAppAuthorizationUrl as Qe,authenticateCrossAppAccount as Je,getProviderAppMetadata as Ze}from"./lib/cross-app/authFlow.mjs";import{popupCrossAppAuthFlow as et}from"./lib/cross-app/popupCrossAppAuthFlow.mjs";import{sendCrossAppRequest as tt}from"./lib/cross-app/sendCrossAppRequest.mjs";import{getRecoveryAuthorizationUrl as rt,authenticateRecovery as at,embeddedWalletRecoveryScreen as nt,toEmbeddedWalletSetRecoveryScreen as it}from"./lib/embeddedWalletRecovery.mjs";import{FUNDING_SCREENS as ot,fundingScreenMethodMap as st}from"./lib/funding/index.mjs";import{isFundingEnabled as lt}from"./lib/funding/isFundingEnabled.mjs";import ct from"./lib/isEmbeddedWebview.mjs";import{triggerPopup as dt}from"./lib/popup/triggerPopup.mjs";import{popupOAuthFlow as ut}from"./lib/popupOAuthFlow.mjs";import{prepareSiweMessageWithNonce as ht}from"./lib/siwe.mjs";import{decodeSolanaTransaction as pt,createSolanaTransactionReceipt as wt}from"./lib/solana/transaction.mjs";import{toDisplayFromAccountType as mt}from"./lib/toDisplayFromAccountType.mjs";import{transformResponseToSnakeCase as yt}from"./passkeys/transformResponseToSnakeCase.mjs";import{PrivyPluginProvider as ft,usePlugins as gt}from"./plugins/context/PrivyPluginContext.mjs";import{SOLANA_FUNDING_PLUGIN_ID as Et}from"./plugins/solana-funding/id.mjs";import{RecentlyUsedAccountProvider as _t}from"./recent-login/context.mjs";import{ModalScreen as At}from"./screens/index.mjs";import{Hide as Tt}from"./screens/LandingScreen/styles.mjs";import{GlobalStyle as vt}from"./styles.mjs";import{notImplemented as Ct}from"./hooks/index.mjs";import{CaptchaProvider as It}from"./hooks/captcha-context.mjs";import{privyEventsDefault as Wt,emitPrivyEvent as kt,PrivyEventsContext as Nt}from"./hooks/events-context.mjs";import{InternalPrivyContext as bt}from"./hooks/internal-context.mjs";import{ModalProvider as Ut}from"./hooks/modal-context.mjs";import{PrivyContext as Ot}from"./hooks/privy-context.mjs";import{UseWalletsContext as St}from"./hooks/useWallets.mjs";import{prepareSolanaFundingModalData as Rt,prepareFundingModalData as Pt}from"./lib/funding/prepareFundingModalData.mjs";import{detectCompletingOAuthFlow as Dt}from"./auth-flows/oauth/detectCompletingOAuthFlow.mjs";import{OAuthFlow as Lt}from"./auth-flows/oauth/OAuthFlow.mjs";import{getRpcTimeout as Mt}from"./connectors/getRpcTimeout.mjs";import{EmbeddedProviderError as Ft}from"./connectors/providerTypes.mjs";import{isEthereumWalletConnector as xt}from"./connectors/ethereum/index.mjs";import{LegacyInjectedWalletConnector as jt,Injected6963WalletConnector as Bt}from"./connectors/injected.mjs";import{MetamaskWalletConnector as Vt}from"./connectors/metamask.mjs";import{PhantomEthereumNullWalletConnector as Ht}from"./connectors/phantom.mjs";import{PhantomSolanaNullWalletConnector as Kt}from"./connectors/phantom-solana.mjs";import{Http as Gt}from"./http.mjs";import{getPaymasterContext as zt}from"./lib/smart-wallet-helpers.mjs";import{transformOptionsToCamelCase as qt}from"./passkeys/transformOptionsToCamelCase.mjs";import{mfaPasswordlessSmsInitPath as $t,mfaPasskeyInitPath as Yt,acceptTermsPath as Xt,unlinkEmailPath as Qt,unlinkPhonePath as Jt,unlinkWalletPath as Zt,siwsUnlinkWalletPath as er,unlinkOAuthPath as tr,unlinkFarcasterPath as rr,telegramAccountUnlinkPath as ar,unlinkPasskeyPath as nr,delegatedActionsRevokePath as ir,analyticsEventsPath as or,moonpayPluginOnRampPath as sr,coinbaseOnRampInitPath as lr,coinbaseOnRampStatusPath as cr,siweInitPath as dr,siweAuthenticatePath as ur,siweLinkPath as hr,smartWalletLinkPath as pr,siwsInitPath as wr,siwsAuthenticatePath as mr,transferOAuthPath as yr,telegramAccountTransferPath as fr,transferFarcasterPath as gr,transferWalletPath as Er,transferPhonePath as _r,transferEmailPath as Ar,siwsLinkPath as Tr}from"./paths.mjs";import{AccessTokenTypes as vr,Session as Cr}from"./session.mjs";class Ir extends V{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new Ft(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Vr()||!this.address)throw new Ft("Disconnected",4900);return(await Gr(t,void 0,void 0,this.address)).hash}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new Ft(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new Ft(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.provider=ne(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],r=e.params[1];return await Hr(t,void 0,r)}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],r="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1];return await Kr(ie(r),void 0,t)}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:oe(this.chainId)};try{return await this.provider.send("eth_estimateGas",[t])}catch(e){console.warn(`Gas estimation failed with error: ${e}. Retrying gas estimation by omitting the 'from' address`);try{return delete t.from,await this.provider.send("eth_estimateGas",[t])}catch(t){throw console.warn(`Gas estimation failed with error: ${t} when omitting the 'from' address`),e}}}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return oe(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!ue(e.method))return this.provider.send(e.method,e.params);{let t=await Vr();if(await zr(),!t||!this.address)throw new Ft("Disconnected",4900);try{return(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:{method:e.method,params:e.params}})).response.data}catch(e){throw console.error(e),new Ft("Disconnected",4900)}}}constructor({walletProxy:e,address:t,entropyId:r,entropyIdVerifier:a,rpcConfig:n,chains:i,appId:o,chainId:s=1,walletIndex:l}){super(),this.walletProxy=e,this.address=t,this.entropyId=r,this.entropyIdVerifier=a,this.chainId=s,this.rpcConfig=n,this.chains=i,this.provider=ne(s,this.chains,n,{appId:o}),this.rpcTimeoutDuration=Mt(n,"privy"),this.appId=o,this.walletIndex=l}}class Wr extends V{get wallets(){let e=new Set,t=this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let r=`${t.address}${t.walletClientType}${t.connectorType}`;return!e.has(r)&&(e.add(r),!0)})),r=t.findIndex((e=>e.address===(this.activeWallet?this.activeWallet:"unknown")));return r>=0&&t.unshift(t.splice(r,1)[0]),t}async initialize(){if(this.initialized)return;re.get(H)&&(re.getKeys().forEach((e=>{e.startsWith("walletconnect")&&re.del(e)})),re.del(H));let e=se({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:r})=>{this.createEthereumWalletConnector("injected",e,{eip6963InjectedProvider:t,legacyInjectedProvider:r})}))}));this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector("coinbase_wallet","coinbase_wallet"),!Ae()&&this.walletList.includes("phantom")&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&this.createEthereumWalletConnector("phantom","phantom"),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&this.addWalletConnector(new Kt)),this.externalWalletConfig.walletConnect.enabled&&this.createEthereumWalletConnector("wallet_connect_v2","unknown"),this.externalWalletConfig.solana.connectors?.get().forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{e?.forEach(this.addSolanaWalletConnector)})),await e,this.initialized=!0}findWalletConnector(e,t){return"wallet_connect_v2"===e?this.walletConnectors.filter(xt).find((t=>t.connectorType===e))??null:this.walletConnectors.filter(xt).find((r=>r.connectorType===e&&r.walletClientType===t))??null}findSolanaWalletConnector(e,t){return this.walletConnectors.filter(We).find((r=>r.connectorType===e&&r.walletClientType===t))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&t.walletClientType===e.walletClientType));t&&(e.connectedAt=t.connectedAt)})),this.saveConnectionHistory(),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&(this.saveConnectionHistory(),this.emit("walletsUpdated"))}addEmbeddedWalletConnectors({walletProxy:e,rootWallet:t,embeddedWallets:r,defaultChain:a,appId:n}){for(let i of r){let r=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===i.walletIndex));if(r&&xt(r))r.proxyProvider.walletProxy=e;else{let{entropyId:r,entropyIdVerifier:o}=k(t),s=new de({provider:new Ir({walletProxy:e,address:i.address,entropyId:r,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:n,chainId:a.id,walletIndex:i.walletIndex}),chains:this.chains,defaultChain:a,rpcConfig:this.rpcConfig,imported:!1,walletIndex:i.walletIndex});this.addWalletConnector(s)}}}addImportedWalletConnector(e,t,r,a){let n=this.findWalletConnector("embedded_imported","privy");if(n&&xt(n))n.proxyProvider.walletProxy=e;else{let n=new de({provider:new Ir({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:a,chainId:r.id}),chains:this.chains,walletIndex:0,defaultChain:r,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(n)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.saveConnectionHistory(),this.storedConnections=kr(),this.emit("walletsUpdated")}removeImportedWalletConnector(){let e=this.findWalletConnector("embedded_imported","privy");if(e){let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1),this.saveConnectionHistory(),this.storedConnections=kr(),this.emit("walletsUpdated")}}async createEthereumWalletConnector(e,t,r){let a=this.findWalletConnector(e,t);if(a&&xt(a))return a instanceof Ne&&a.resetConnection(t),a;let n=(()=>"injected"!==e?"coinbase_wallet"===e?new ce(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig,this.privyAppName,this.privyAppLogo):"phantom"===e?new Ht(this.defaultChain):new Ne(this.walletConnectCloudProjectId,this.rpcConfig,this.chains,this.defaultChain,this.shouldEnforceDefaultChainOnConnect,this.privyAppId,this.privyAppName,t):"metamask"===t&&r?.eip6963InjectedProvider?new Vt(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,"metamask"):"metamask"===t&&r?.legacyInjectedProvider?new jt(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"metamask"):"phantom"===t&&r?.legacyInjectedProvider?new jt(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"phantom"):r?.legacyInjectedProvider&&"unknown_browser_extension"===t?new jt(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider):r?.eip6963InjectedProvider?new Bt(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,t):void 0)();return n&&this.addWalletConnector(n),n||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}saveConnectionHistory(){let e=this.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt})));re.put(K,e)}async activeWalletSign(e){let t=this.wallets,r=t.length>0?t[0]:null;return r&&Te(r)?r.sign(e):null}setActiveWallet(e){this.activeWallet=r(e),this.emit("walletsUpdated")}constructor(e,t,r,a,n,i,o,s,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{this.findSolanaWalletConnector("solana_adapter",e.walletClientType)||this.addWalletConnector(e)},this.getEthereumProvider=()=>{let e=this.wallets[0],t=this.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new ve},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=r,this.chains=a,this.defaultChain=n,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=o,this.shouldEnforceDefaultChainOnConnect=s,this.externalWalletConfig=l,this.privyAppName=c,this.privyAppLogo=d,this.walletChainType=u||"ethereum-only",this.storedConnections=kr()}}const kr=()=>{let e=re.get(K);return e&&Array.isArray(e)&&e.map((e=>(e=>e&&"string"==typeof e.address&&"string"==typeof e.connectorType&&"string"==typeof e.walletClientType&&"number"==typeof e.connectedAt)(e))).every(Boolean)?e:[]};let Nr;var br=0,Ur="__private_"+br+++"__getOrGenerateClientAnalyticsId";class Or{initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:r,defaultChain:a,store:n,walletList:i,shouldEnforceDefaultChainOnConnect:o,externalWalletConfig:s,appName:l,walletChainType:c}){this.connectors||(this.connectors=new Wr(this.appId,e,t,r,a,n,i,o,s,l,void 0,c))}generateApi(){let e=new Gt({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new Fe("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new Fe("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post($t,{action:"verify"})}catch(e){throw xe(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(Yt,{});return qt(e.options)}catch(e){throw xe(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(Xt,{});return N(e)}catch(e){throw je(e)}}async unlinkEmail(e){try{let t=await this.api.post(Qt,{address:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkPhone(e){try{let t=await this.api.post(Jt,{phoneNumber:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(Zt,{address:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(er,{address:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkOAuth(e,t){try{let r=await this.api.post(tr,{provider:e,subject:t});return await this.getAuthenticatedUser()??N(r)}catch(e){throw je(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(rr,{fid:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkTelegram(e){try{let t=await this.api.post(ar,{telegram_user_id:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkPasskey(e){try{let t=await this.api.post(nr,{credential_id:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async revokeDelegatedWallet(){try{await this.api.post(ir,{})}catch(e){throw je(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:r,options:a}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(or,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:r?r.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:a?.keepAlive??!1})}catch(e){}}async signMoonpayOnRampUrl(e){try{return this.api.post(sr,e)}catch(e){throw je(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(lr,e)}catch(e){throw je(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${cr}?partnerUserId=${e}`)}catch(e){throw je(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()||this.session.hasRecoveryCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(vr.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(vr.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?W.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getSmartWalletsConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let r=await this.api.get(`/api/v1/apps/${this.appId}/smart_wallets`,{baseURL:this.fallbackApiUrl,headers:e});return r.enabled?{enabled:r.enabled,smartWalletType:r.smart_wallet_type,configuredNetworks:r.configured_networks.map((e=>({chainId:e.chain_id,bundlerUrl:e.bundler_url,paymasterUrl:e.paymaster_url,paymasterContext:zt(e.paymaster_url,e.paymaster_context)})))}:{enabled:r.enabled}}catch(e){throw je(e)}}async getServerConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let r=await this.api.get(`/api/v1/apps/${this.appId}`,{baseURL:this.fallbackApiUrl,headers:e}),a=r.telegram_auth_config?{botId:r.telegram_auth_config.bot_id,botName:r.telegram_auth_config.bot_name,linkEnabled:r.telegram_auth_config.link_enabled,seamlessAuthEnabled:r.telegram_auth_config.seamless_auth_enabled}:void 0,n=r.funding_config?{methods:r.funding_config.methods,options:r.funding_config.options,defaultRecommendedAmount:r.funding_config.default_recommended_amount,defaultRecommendedCurrency:r.funding_config.default_recommended_currency,promptFundingOnWalletCreation:r.funding_config.prompt_funding_on_wallet_creation,crossChainBridgingEnabled:r.funding_config.cross_chain_bridging_enabled}:void 0;return{id:r.id,name:r.name,verificationKey:r.verification_key,logoUrl:r.logo_url||void 0,accentColor:r.accent_color||void 0,showWalletLoginFirst:r.show_wallet_login_first,allowlistConfig:{errorTitle:r.allowlist_config.error_title,errorDetail:r.allowlist_config.error_detail,errorCtaText:r.allowlist_config.cta_text,errorCtaLink:r.allowlist_config.cta_link},walletAuth:r.wallet_auth,solanaWalletAuth:r.solana_wallet_auth,emailAuth:r.email_auth,smsAuth:r.sms_auth,googleOAuth:r.google_oauth,twitterOAuth:r.twitter_oauth,discordOAuth:r.discord_oauth,githubOAuth:r.github_oauth,spotifyOAuth:r.spotify_oauth,instagramOAuth:r.instagram_oauth,tiktokOAuth:r.tiktok_oauth,linkedinOAuth:r.linkedin_oauth,appleOAuth:r.apple_oauth,farcasterAuth:r.farcaster_auth,passkeyAuth:r.passkey_auth,telegramAuth:r.telegram_auth,disablePlusEmails:r.disable_plus_emails,termsAndConditionsUrl:r.terms_and_conditions_url,embeddedWalletConfig:{createOnLogin:r.embedded_wallet_config?.create_on_login,userOwnedRecoveryOptions:r.embedded_wallet_config.user_owned_recovery_options,requireUserOwnedRecoveryOnCreate:r.embedded_wallet_config.require_user_owned_recovery_on_create},privacyPolicyUrl:r.privacy_policy_url,requireUsersAcceptTerms:r.require_users_accept_terms,customApiUrl:r.custom_api_url,walletConnectCloudProjectId:r.wallet_connect_cloud_project_id,fiatOnRampEnabled:r.fiat_on_ramp_enabled,captchaEnabled:r.captcha_enabled,captchaSiteKey:r.captcha_site_key,createdAt:new Date(1e3*r.created_at),updatedAt:new Date(1e3*r.updated_at),mfaMethods:r.mfa_methods,enforceWalletUis:r.enforce_wallet_uis,legacyWalletUiConfig:r.legacy_wallet_ui_config,telegramAuthConfiguration:a,fundingConfig:n}}catch(e){throw je(e)}}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async forkSession(){return await this.session.forkSession()}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(dr,{address:e,token:t})).nonce}catch(e){throw je(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n,mode:i}){return await this.api.post(ur,{message:e,signature:t,chainId:r,walletClientType:a,connectorType:n,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}){return await this.api.post(hr,{message:e,signature:t,chainId:r,walletClientType:a,connectorType:n})}async linkSmartWallet({message:e,signature:t,smartWalletType:r}){try{let a=await this.api.post(pr,{message:e,signature:t,smart_wallet_type:r});return N(a)}catch(e){throw je(e)}}async linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n});return N(i)}catch(e){throw je(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(wr,{address:e,token:t})).nonce}catch(e){throw je(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a,mode:n}){return await this.api.post(mr,{message:e,signature:t,walletClientType:r,connectorType:a,mode:n})}async sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o}){try{let s,l;switch(r){case"email":s=Ar,l={nonce:e,email:t};break;case"sms":s=_r,l={nonce:e,phoneNumber:t};break;case"siwe":if(s=Er,!a)throw Error("Wallet parameters must be defined");l={nonce:e,address:t,...a};break;case"farcaster":s=gr,l={nonce:e,farcaster_id:t,farcaster_embedded_address:i};break;case"telegram":s=fr,l={nonce:e,telegram_auth_result:n};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:s=yr,l={nonce:e,userInfo:o}}let c=await this.api.post(s,l);return await this.getAuthenticatedUser()??N(c)}catch(e){throw je(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a}){return await this.api.post(Tr,{message:e,signature:t,walletClientType:r,connectorType:a})}async linkWithSiws({message:e,signature:t,walletClientType:r,connectorType:a}){try{let n=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a});return N(n)}catch(e){throw je(e)}}constructor({apiUrl:e=G,appId:t,appClientId:r,timeout:a=z}){Object.defineProperty(this,Ur,{value:Sr}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==G&&e.startsWith("https://privy."),this.timeout=a,this.appId=t,this.appClientId=r,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Ur)[Ur](),Nr||(Nr=new Cr),this.session=Nr,this.api=this.generateApi(),this.session.client=this}}function Sr(){if("undefined"==typeof window)return null;try{let e=re.get(q);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=I();try{return re.put(q,e),e}catch(t){return e}}class Rr{async handleSignMessage(e){if(!e.params||"string"!=typeof e.params.message)throw Error("Message must be provided as a string for Solana signMessage RPC");return await $r({message:e.params.message,address:this.address})}async request(e){if(console.debug("EmbeddedSolanaProvider.request() called with args",e),!await Vr())throw Error("User must be authenticated to use embedded Solana wallet");if(!await qr())throw new Fe("Unable to connect to Solana embedded wallet");if("signMessage"===e.method)return await this.handleSignMessage(e);throw Error("Embedded Solana provider does not yet support this RPC method.")}constructor(e,t){this.walletProxy=e,this.address=t}}let Pr,Dr,Lr,Mr,Fr,xr,jr;function Br(){return Pr?Pr.getCustomerAccessToken():Promise.resolve(re.get($)||null)}async function Vr(){return Pr?Pr.getAccessToken():Promise.resolve(re.get(Y)||re.get($)||null)}const Hr=(e,t,r)=>Dr(e,t,r),Kr=(e,t,r)=>Lr(e,t,r),Gr=(e,t,r,a)=>Mr(e,t,r,a),zr=()=>Fr(),qr=()=>xr(),$r=({message:e,address:t})=>jr({message:e,address:t});const Yr=({config:t,...r})=>{var a;if("undefined"!=typeof window&&0>["localhost","127.0.0.1"].indexOf(window.location.hostname)&&0>["https:","chrome-extension:","file:"].indexOf(window.location.protocol))throw new Fe("Embedded wallet is only available over HTTPS/CHROME-EXTENSION/FILE");if("string"!=typeof(a=r.appId)||25!==a.length)throw new Fe("Cannot initialize the Privy provider with an invalid Privy app ID");Pr||(Pr=new Or({appId:r.appId,appClientId:r.clientId,apiUrl:r.apiUrl}));let n=Object.assign({},t);return void 0!==r.createPrivyWalletOnLogin&&void 0===n.embeddedWallets?.createOnLogin&&(n.embeddedWallets||(n.embeddedWallets={}),n.embeddedWallets.createOnLogin=r.createPrivyWalletOnLogin?"users-without-wallets":"off"),void 0!==r.createPrivyWalletOnLogin&&t?.embeddedWallets?.createOnLogin&&console.warn("Both `createPrivyWalletOnLogin` and `config.embeddedWallets.createOnLogin` are set. `createPrivyWalletOnLogin` is deprecated and should be removed."),/*#__PURE__*/e(me,{client:Pr,clientConfig:n,legacyCreateEmbeddedWalletFlag:r.createPrivyWalletOnLogin,children:/*#__PURE__*/e(ft,{children:/*#__PURE__*/e(Xr,{...r,client:Pr})})})};let Xr=I=>{let W=I.client,N=gt(),[V,H]=i(!1),[K,z]=i(!1),[$,Y]=i(!1),[se,ce]=i(null),[de,ue]=i([]),[me,We]=i([]),[xe,je]=i([]),ft=o(de),[Mt,Ft]=i(!1),[xt,jt]=i(null),[Bt,Vt]=i(!1),[Ht,Kt]=i({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:Ct}),[Gt,zt]=i({status:"initial"}),[qt,$t]=i({status:"initial"}),[Yt,Xt]=i({status:"initial"}),[Qt,Jt]=i({status:"initial"}),[Zt,er]=i({status:"initial"}),[tr,rr]=i(null),ar=ye(),nr=fe(),[ir,or]=i(!0),[sr,lr]=i({}),[cr,dr]=i(null),[ur,hr]=i(null),[pr,wr]=i(!1),[mr,yr]=i(!1),[fr,gr]=i(ar.customAuth?.enabled?{status:"initial"}:{status:"not-enabled"}),Er=o(null),_r=o(null),Ar=o(Wt),[Tr,vr]=i(!1);W.onStoreCustomerAccessToken=e=>{e&&kt(Ar,"accessToken","onAccessTokenGranted",e)},W.onDeleteCustomerAccessToken=()=>{ce(null),Y(!1),kt(Ar,"accessToken","onAccessTokenRemoved")};let Cr=o(null),Ir=o(null),Wr=o(!1),kr=({showWalletUIs:e,typedData:t})=>Wr.current?Wr.current:void 0!==e?!e:void 0!==ar.embeddedWallets.showWalletUIs?!ar.embeddedWallets.showWalletUIs:t?ar.embeddedWallets.noPromptOnSignature||(ar.legacyWalletUiConfig??!1):!!ar.embeddedWallets.noPromptOnSignature,Nr=e=>{jt(e),setTimeout((()=>{H(!0)}),15),W.createAnalyticsEvent({eventName:"modal_open",payload:{initialScreen:e}})},br=e=>{"off"!==ar.embeddedWallets.createOnLogin&&or(!0),Nr(e)};s((()=>{let e=[...b(se),U(se)].filter((e=>!!e));tr&&je(e.map((e=>({type:"solana",imported:e.imported,address:e.address,connectedAt:Date.now(),walletClientType:"privy",connectorType:"embedded",walletIndex:e.walletIndex??void 0,meta:{name:"Privy Wallet",icon:void 0,id:"io.privy.solana.wallet"},linked:!0,fund(){throw new Fe("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:()=>{throw new Fe("Cannot unlink an embedded Solana wallet")},getProvider:async()=>new Rr(tr,e.address),async signMessage(t){let r=await Vr();if(!r||!tr)throw new Fe("Must have valid access token and Privy wallet to send transaction",Be.MUST_BE_AUTHENTICATED);let a=e.imported?U(se):O(se);if(!a)throw new Fe("Attempting to sign a transaction without a root wallet");let{entropyId:n,entropyIdVerifier:i}=k(a);if(!await ua.recoverPrimaryWallet().catch((()=>!1)))throw new Fe("Wallet couldn't be connected",Be.UNKNOWN_CONNECT_WALLET_ERROR);if(!se)throw new Fe("Attempting to sign a transaction with no user initialized");let{response:o}=await tr.rpc({accessToken:r,entropyId:n,entropyIdVerifier:i,chainType:"solana",hdWalletIndex:this.walletIndex??0,request:{method:"signMessage",params:{message:Buffer.from(t).toString("base64")}}});return Buffer.from(o.data.signature,"base64")},async sendTransaction(e,t,r){let{signature:a}=await na({transaction:e,connection:t,transactionOptions:r,wallet:this});return a},async signTransaction(t){let r=await Vr();if(!r||!tr)throw new Fe("Must have valid access token and Privy wallet to send transaction",Be.MUST_BE_AUTHENTICATED);if(!await ua.recoverPrimaryWallet().catch((()=>!1)))throw new Fe("Wallet couldn't be connected",Be.UNKNOWN_CONNECT_WALLET_ERROR);let{entropyId:a,entropyIdVerifier:n}=k(e);return await Ge({tx:t,accessToken:r,walletProxy:tr,entropyId:a,entropyIdVerifier:n,transactingWalletAddress:this.address,transactingWalletIndex:this.walletIndex??0}),t},loginOrLink:async()=>{throw new Fe("Cannot login or link with an embedded Solana wallet")},disconnect:()=>{},isConnected:async()=>!0}))))}),[tr,se]),s((()=>{if(!se)return void W.connectors?.removeEmbeddedWalletConnectors();let e=S(se),t=R(se),r=P(se);e&&t.length||W.connectors?.removeEmbeddedWalletConnectors(),r||W.connectors?.removeImportedWalletConnector(),W.connectors?tr?(e&&W.connectors.addEmbeddedWalletConnectors({walletProxy:tr,rootWallet:e,embeddedWallets:t,defaultChain:ar.defaultChain,appId:I.appId}),r&&W.connectors.addImportedWalletConnector(tr,r.address,ar.defaultChain,I.appId)):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[tr,se]),s((()=>{tr&&ur?.(tr)}),[tr]);let Ur=o();s((()=>{(async()=>{if(!ar.customAuth?.enabled)return void gr({status:"not-enabled"});or(!0);let{getCustomAccessToken:e,isLoading:t}=ar.customAuth;if(K&&!t&&"loading"!==fr.status){gr({status:"loading"});try{let t=await e();if(t===Ur.current)return void gr({status:"done"});if(!t&&$)return Ur.current=t,await da.logout(),gr({status:"done"}),void kt(Ar,"customAuth","onUnauthenticated");if(!t)return Ur.current=t,void gr({status:"done"});W.startAuthFlow(new p(t));let{user:r,isNewUser:a}=await W.authenticate();if(!r)return await da.logout(),gr({status:"error",error:new Fe("Failed to sync with custom auth provider")}),void kt(Ar,"customAuth","onUnauthenticated");void 0!==a&&kt(Ar,"login","onComplete",r,a,!1,"custom",null),Ur.current=t,kt(Ar,"customAuth","onAuthenticated",{user:r}),gr({status:"done"}),ce(r||null),Ft(a||!1),Y(!0),yr(!0)}catch(e){if(console.warn(e),await da.logout(),kt(Ar,"customAuth","onUnauthenticated"),"User already exists with provided custom JWT account."===e.message)return void gr({status:"initial"});kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),gr({status:"error",error:e})}}})()}),["initial"===fr.status,ar.customAuth?.enabled,ar.customAuth?.getCustomAccessToken,ar.customAuth?.isLoading,K,$]),s((()=>{mr&&tr&&se&&D(se,ar.embeddedWallets.createOnLogin)&&(yr(!1),Jr(se,ee).catch(console.error))}),[mr&&tr&&se]),s((()=>{if(ar.externalWallets.solana.connectors)return ar.externalWallets.solana.connectors.onMount(),()=>ar.externalWallets.solana.connectors?.onUnmount()}),[ar.externalWallets.solana.connectors]),s((()=>{!K&&nr&&async function(){let e,t=Or(),r=Sr();(()=>{let e=new URLSearchParams(window.location.search).get("privy_token");if(!e)return;re.put(te,e);let t=new URL(window.location.href);t.searchParams.delete("privy_token"),window.history.pushState({},"",t)})();let a=n();W.initializeConnectorManager({walletConnectCloudProjectId:ar.walletConnectCloudProjectId,rpcConfig:ar.rpcConfig,chains:ar.chains,defaultChain:ar.defaultChain,store:a,walletList:ar.appearance.walletList,shouldEnforceDefaultChainOnConnect:ar.shouldEnforceDefaultChainOnConnect,externalWalletConfig:ar.externalWallets,appName:ar.name??"Privy",walletChainType:ar.appearance.walletChainType}),W.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=W.connectors.walletConnectors.length,r=W.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);r===t?vr(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:r,expected:t}),vr(!0)}),1500)})),W.connectors?.initialize().then((()=>{zr()}));let i=await W.getAuthenticatedUser(),o=!!i;ar.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await W.logout(),ua.setReadyToTrue(!0),kt(Ar,"logout","onSuccess")):(ar.customAuth?.enabled||(Y(!!i),i&&kt(Ar,"login","onComplete",i,!1,!0,null,null),ce(i)),t?Ir.current=o?"link":"login":r&&!o?(Ir.current="login",lr({telegramAuthModalData:{seamlessAuth:!0}}),br(At.TELEGRAM_AUTH_SCREEN)):ua.setReadyToTrue(!!i))}()}),[W,cr,K,nr]),s((()=>{if(K){if(!se||!se.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void wr(!0);wr(!!de.find((e=>"privy"===e.walletClientType)))}}),[K,se,de]);let Or=()=>{let e=Dt();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&Ye(e.provider)&&!e.popupFlow&&(new BroadcastChannel(Xe).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(W.startAuthFlow(new Lt(e)),br(At.AWAITING_OAUTH_SCREEN),!0))},Sr=()=>{let e=C();if(!e||!ar.loginMethods.telegram||!ar.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new v;return W.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},Br=async(e,t,r,a)=>{Hr(await(W.connectors?.createEthereumWalletConnector(e,t))||null,t,r,a)};async function Hr(e,t,r,a){if(!e)return Kt({status:"disconnected",connectedWallet:null,connectError:new He("Unable to connect to wallet."),connector:null,connectRetry:Ct}),a?.(null,r);Kt({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:Ct}),e instanceof Ne&&t&&await e.resetConnection(t),Kt({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>Hr(e,t,r,a)});try{let t=await e.connect({showPrompt:!0});if((!t||Te(t))&&ar.shouldEnforceDefaultChainOnConnect&&!ar.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){Kt((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:Ct})));try{await(t?.switchChain(ar.defaultChain.id)),t&&(t.chainId=le(oe(ar.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${ar.defaultChain.id}`)}}return Kt((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:Ct}))),t&&kt(Ar,"connectWallet","onSuccess",(e.chainType,t)),a?.(t,r)}catch(e){return e instanceof Ke?(console.warn(e.cause?e.cause:e.message),kt(Ar,"connectWallet","onError",e.privyErrorCode||Be.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),kt(Ar,"connectWallet","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR)),Kt((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),a?.(null,r)}}let Kr=async(e,t,r)=>{if(null===e||!Te(e))return;let a=new E(e,W,t,r);W.startAuthFlow(a)},Gr=async(e,t)=>{if(null===e||!ke(e))return;let r=new _(e,W,t);W.startAuthFlow(r)},zr=()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),r=e.get("privy_wallet_client");if(!t||!r)return;if("phantom"!==r||Ae()||br(At.LOGIN_FAILED_SCREEN),!W.connectors)throw new Fe("Connector not initialized");Nr(At.AWAITING_CONNECTION);let a=new URL(window.location.href);a.searchParams.delete("privy_connector"),a.searchParams.delete("privy_wallet_client"),window.history.pushState({},"",a),Br(t,r,void 0,Kr)};s((()=>{K&&$&&null===se&&W.getAuthenticatedUser().then(ce)}),[K,$,se,W]);let qr=e=>{if(!$)throw kt(Ar,"linkAccount","onError",Be.MUST_BE_AUTHENTICATED,{linkMethod:e}),new Fe("User must be authenticated before linking an account.")},$r=()=>{qr("siwe"),Cr.current="siwe",Ir.current="link",Nr(At.LINK_WALLET_SCREEN)},Yr=e=>{if(!$||!se)return!1;if("privy"===e.walletClientType)return!0;for(let t of se.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},Xr=async e=>{let t;if(!W.connectors)throw new Fe("Connector not initialized");t="ethereum"===e.type?W.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:W.connectors.findSolanaWalletConnector(e.connectorType,e.walletClientType)||null,Kt((r=>({...r,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:Ct}))),ar.captchaEnabled&&!$?(lr({captchaModalData:{callback:t=>Te(e)?Kr(e,t):Gr(e,t),userIntentRequired:!1,onSuccessNavigateTo:At.AWAITING_CONNECTION,onErrorNavigateTo:At.ERROR_SCREEN}}),br(At.CAPTCHA_SCREEN)):(Te(e)?await Kr(e):await Gr(e),br(At.AWAITING_CONNECTION))},Qr=()=>{ue((e=>{let t=W.connectors?.wallets.filter(Te).map((e=>({...e,linked:Yr(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Fe("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot link or login with embedded wallet");Xr(e)},fund:async t=>{await ua.fundWallet(e.address,t)},unlink:async()=>{if(!$)throw new Fe("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot unlink an embedded wallet");ce(await W.unlinkEthereumWallet(e.address))}})))||[];return ge(e,t)?e:t})),We((e=>{let t=(W.connectors?.wallets??[]).concat(xe).filter(ke).map((e=>({...e,linked:Yr(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Fe("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot link or login with embedded wallet");Xr(e)},fund:async()=>{throw new Fe("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:async()=>{if(!$)throw new Fe("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot unlink an embedded wallet");ce(await W.unlinkSolanaWallet(e.address))}})));return ge(e,t)?e:t}))};s((()=>{Qr()}),[se?.linkedAccounts,$,K,xe]),s((()=>{if(K){if(!W.connectors)throw new Fe("Connector not initialized");Qr(),W.connectors.on("walletsUpdated",Qr)}}),[K]),s((()=>{[...ar.loginMethodsAndOrder?.primary??[],...ar.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>W.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!W]),s((()=>{let e;if(!de[0])return;let t=de[0],r=ft.current.find((e=>e.address===t.address));if(e="privy"===t.walletClientType?se?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"===e.walletClientType)):se?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"!==e.walletClientType)),!r&&e){let t=Object.assign({},se);t.wallet=e&&{address:e.address,chainType:e.chainType,chainId:e.chainId,walletClient:e.walletClient,walletClientType:e.walletClientType,connectorType:e.connectorType,imported:e.imported,delegated:e.delegated,walletIndex:e.walletIndex},ce(t)}ft.current=de}),[de]);let Jr=async(e,t,r)=>{let a=S(e),n=L(e);if(r&&"walletIndex"in r)return ea(e,t,r.walletIndex,a,n);let i=r&&"createAdditional"in r&&r.createAdditional;if(a&&!i)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");let[o,s]=await Promise.all([ua.initializeWalletProxy(t),Vr()]);if(!o&&ar.customAuth?.enabled)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!o||!s||ar.embeddedWallets?.requireUserOwnedRecoveryOnCreate)return Zr();if(!a)return await o.create({accessToken:s,solanaAddress:n?.address}),ra(0,"ethereum");{let t=(M(e)?.walletIndex??0)+1,{entropyId:r,entropyIdVerifier:a}=k(O(e));return await ua.recoverPrimaryWallet(),await o.addWallet({accessToken:s,entropyId:r,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:t}),ra(t,"ethereum")}},Zr=async()=>new Promise(((e,t)=>{or(!0),lr({createWallet:{onSuccess:t=>{kt(Ar,"createWallet","onSuccess",t),e(t)},onFailure:e=>{kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),t(e)},callAuthOnSuccessOnClose:!1}}),Nr(At.EMBEDDED_WALLET_ON_ACCOUNT_CREATE_SCREEN)})),ea=async(e,t,r,a,n)=>{if(r<0)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${r}) is invalid.`);let[i,o]=await Promise.all([ua.initializeWalletProxy(t),Vr()]);if(!i&&ar.customAuth?.enabled)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!i||!o||ar.embeddedWallets?.requireUserOwnedRecoveryOnCreate){if(0==r)return Zr();throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Create wallet UI can only be displayed when walletIndex is 0.")}if(0==r){if(a)return a;await i.create({accessToken:o,solanaAddress:n?.address})}else{if(!a)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error("A user must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let t=R(e).find((e=>e.walletIndex===r));if(t)return t;let{entropyId:n,entropyIdVerifier:s}=k(O(e));await ua.recoverPrimaryWallet(),await i.addWallet({accessToken:o,entropyId:n,entropyIdVerifier:s,chainType:"ethereum",hdWalletIndex:r})}return ra(r,"ethereum")},ta=async({user:e,wp:t,accessToken:r,walletIndex:a,ethereumWallet:n})=>{let i=b(e).find((e=>e.walletIndex===a));if(i)return i;if(0===a)await t.createSolana({accessToken:r,ethereumAddress:n?.address});else{let n=O(e);if(!n)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error("User must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let{entropyId:i,entropyIdVerifier:o}=k(n);await ua.recoverPrimaryWallet(),await t.addWallet({accessToken:r,entropyId:i,entropyIdVerifier:o,chainType:"solana",hdWalletIndex:a})}return ra(a,"solana")},ra=async(e,t)=>{let r=await ua.refreshUser(),a=("ethereum"===t?R(r):b(r)).find((t=>t.walletIndex===e));if(!a)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");return kt(Ar,"createWallet","onSuccess",a),a},aa=(e,t,a,n)=>new Promise((async(i,o)=>{let{requesterAppId:s}=t||{};if(!$||!se)return kt(Ar,"sendTransaction","onError",Be.MUST_BE_AUTHENTICATED),void o(Error("User must be authenticated before signing with a Privy wallet"));let l=n??S(se)?.address;if(!l)throw new Fe("User must have an embedded wallet to send a transaction.");let{signingWallet:c,rootWallet:p}=x(se,l);if(!p||!c)return kt(Ar,"sendTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have a Privy wallet before signing"));or(!0);let w=ha.wallets.find((e=>"privy"===e.walletClientType&&r(e.address)===r(c.address))),m=await(w?.getEthereumProvider());if(!w||!m)throw new Fe(`Cannot sendTransaction before embedded wallet ${c.address} is connected`);let y=e.chainId?Number(e.chainId):qe(w.chainId);(e=>{if(!ar.chains.map((e=>e.id)).includes(e))throw new He(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,Be.UNSUPPORTED_CHAIN_ID)})(y);let f=Object.assign({},e,{chainId:y});if(kr({showWalletUIs:t?.showWalletUIs}))(async()=>{let e=await Vr();if(!e||!tr)return kt(Ar,"sendTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have valid access token and Privy wallet to send transaction"));try{if(!await ua.recoverPrimaryWallet())return kt(Ar,"sendTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),void o(Error("Unable to connect to wallet"));let r=ne(f.chainId,ar.chains,ar.rpcConfig,{appId:I.appId}),a=await d(c.address,f,r);if(kr({showWalletUIs:t?.showWalletUIs})){let{totalGasEstimate:e}=await u(a,r),{hasSufficientFunds:t}=await Le(c.address,a,e,r);if(!t)throw new Ee(new _e("Wallet has insufficient funds for this transaction.",h.E32603_DEFAULT_INTERNAL_ERROR.eipCode))}let{entropyId:n,entropyIdVerifier:l}=k(p),w=await Me({accessToken:e,entropyId:n,entropyIdVerifier:l,transactingWallet:c,walletProxy:tr,transactionRequest:a,provider:r,requesterAppId:s});kt(Ar,"sendTransaction","onSuccess",w),i(w)}catch(e){kt(Ar,"sendTransaction","onError",Be.TRANSACTION_FAILURE),o(e)}})();else{let{entropyId:e,entropyIdVerifier:r}=k(p),n={entropyId:e,entropyIdVerifier:r,onCompleteNavigateTo:At.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:e=>{kt(Ar,"sendTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),o(e)}},l=lt(ar)?Pt({address:c.address,appConfig:ar,fundWalletConfig:a,methodScreen:At.FUNDING_METHOD_SELECTION_SCREEN,chainIdOverride:f.chainId,comingFromSendTransactionScreen:!0}):void 0;lr({connectWallet:n,sendTransaction:{transactionRequest:f,transactingWallet:c,entropyId:e,entropyIdVerifier:r,onSuccess:e=>{kt(Ar,"sendTransaction","onSuccess",e),i(e)},onFailure:e=>{kt(Ar,"sendTransaction","onError",Be.TRANSACTION_FAILURE),o(e)},uiOptions:t||{},fundWalletConfig:a,requesterAppId:s},funding:l}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),na=({transaction:e,connection:t,transactionOptions:r,fundWalletConfig:a,uiOptions:n,wallet:i})=>new Promise((async(o,s)=>{let{requesterAppId:l}=n||{};if(!$||!se)return kt(Ar,"sendSolanaTransaction","onError",Be.MUST_BE_AUTHENTICATED),void s(new Fe("User must be authenticated before signing with a Privy wallet",Be.MUST_BE_AUTHENTICATED));let c=i?se.linkedAccounts.find((e=>"wallet"===e.type&&e.address===i.address)):L(se);if(!c)return kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void s(new Fe("Must have a Privy wallet before signing",Be.EMBEDDED_WALLET_NOT_FOUND));or(!0);let{rootWallet:d}=F(se,c.address);if(!await ua.recoverPrimaryWallet().catch((()=>!1))||!d)throw kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),new Fe(`Cannot sendSolanaTransaction before embedded wallet ${c.address} is connected`,Be.EMBEDDED_WALLET_NOT_FOUND);if(kr({showWalletUIs:n?.showWalletUIs}))(async()=>{let a=await Vr();if(!a||!tr)return kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void s(new Fe("Must have valid access token and Privy wallet to send transaction",Be.EMBEDDED_WALLET_NOT_FOUND));try{if(!await ua.recoverPrimaryWallet())return kt(Ar,"sendSolanaTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),void s(new Fe("Unable to connect to wallet",Be.UNKNOWN_CONNECT_WALLET_ERROR));if(kr({showWalletUIs:n?.showWalletUIs})){let{instructions:r}=await pt(e,t);r.every((e=>e.hasFunds))||(kt(Ar,"sendSolanaTransaction","onError",Be.INSUFFICIENT_BALANCE),s(new Fe("Solana wallet has insufficient funds for this transaction.",Be.INSUFFICIENT_BALANCE)))}let{entropyId:i,entropyIdVerifier:l}=B(se),{signature:d,receipt:u}=await ze({accessToken:a,tx:e,connection:t,walletProxy:tr,transactionOptions:r,entropyId:i,entropyIdVerifier:l,transactingWalletAddress:c.address,transactingWalletIndex:c.walletIndex??0}),h=wt(d,u);kt(Ar,"sendSolanaTransaction","onSuccess",h),o(h)}catch(e){kt(Ar,"sendSolanaTransaction","onError",Be.TRANSACTION_FAILURE),s(e)}})();else{let{entropyId:i,entropyIdVerifier:u}=k(d),h={entropyId:i,entropyIdVerifier:u,onCompleteNavigateTo:At.EMBEDDED_WALLET_SEND_SOLANA_TRANSACTION_SCREEN,onFailure:e=>{kt(Ar,"sendSolanaTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}},p=lt(ar)?Rt({address:c.address,appConfig:ar,methodScreen:At.FUNDING_METHOD_SELECTION_SCREEN,fundWalletConfig:a,comingFromSendTransactionScreen:!0}):void 0;lr({connectWallet:h,sendSolanaTransaction:{transactionRequest:e,connection:t,transactionOptions:r,transactingWallet:c,onSuccess:e=>{kt(Ar,"sendSolanaTransaction","onSuccess",e),o(e)},onFailure:e=>{kt(Ar,"sendSolanaTransaction","onError",Be.TRANSACTION_FAILURE),s(e)},uiOptions:n||{},requesterAppId:l},funding:p}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}}));function ia(){return new Promise((async(e,t)=>{let r=await Vr();if(!r||!tr)throw Error("Must have valid access token to enroll in MFA");try{await tr.verifyMfa({accessToken:r}),e()}catch(e){t(e)}}))}let oa=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],sa=e=>{let t=se?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:r,loginMethod:a}=mt(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw kt(Ar,"linkAccount","onError",Be.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:a}),new Fe(`User already has an account of type ${r} linked.`)};async function la({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){jt(null);let r=t?"setWalletPassword":"setWalletRecovery";if(!$||!se)throw kt(Ar,r,"onError",Be.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let a=O(se);if(!a||!tr)throw kt(Ar,r,"onError",Be.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");try{await ia()}catch(e){throw kt(Ar,r,"onError",Be.MISSING_MFA_CREDENTIALS),e}return new Promise(((n,i)=>{or(!0);let o={onSuccess:e=>{kt(Ar,r,"onSuccess","user-passcode",e),n(e)},onFailure:e=>{kt(Ar,r,"onError",Be.USER_EXITED_SET_PASSWORD_FLOW),i(e)},callAuthOnSuccessOnClose:!1},s="user-passcode"===a.recoveryMethod,l=it({walletAction:"update",availableRecoveryMethods:ar.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:s,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:d}=k(a);lr({setWalletPassword:o,recoverWallet:{entropyId:c,entropyIdVerifier:d,onFailure:i},createWallet:o,connectWallet:{onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,entropyIdVerifier:d,onFailure:e=>{kt(Ar,r,"onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}},recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:s}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}))}async function ca({appId:e,action:t}){let r=await Vr();if("link"===t&&!r)throw kt(Ar,"linkAccount","onError",Be.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new Fe("User must be authenticated before linking an account.");if("login"===t&&r)throw kt(Ar,"login","onError",Be.UNKNOWN_AUTH_ERROR),new Fe("Attempted to log in, but user is already logged in. Use a `link` helper instead.");Cr.current=`privy:${e}`,Ir.current=t;let a=dt();return W.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(r,n)=>{let{name:i,logoUrl:o}=await Ze({api:W.api,providerAppId:e,requesterAppId:ar.id});lr({crossAppAuth:{appId:e,name:i,logoUrl:o,action:t,popup:a,onSuccess:r,onError:n}}),br(At.CROSS_APP_AUTH_SCREEN)}))}let da={ready:K,authenticated:$,user:se,walletConnectors:W.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),lr({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,suggestedAddress:e?.suggestedAddress}}),Nr($?At.CONNECT_ONLY_AUTHENTICATED_SCREEN:At.CONNECT_ONLY_LANDING_SCREEN)},linkWallet:$r,startCrossAppAuthFlow:ca,linkEmail:()=>{qr("email"),sa("email"),Cr.current="email",Ir.current="link",Nr(At.LINK_EMAIL_SCREEN)},linkPhone:()=>{qr("sms"),sa("phone"),Cr.current="sms",Ir.current="link",Nr(At.LINK_PHONE_SCREEN)},linkGoogle:async()=>{qr("google"),sa("google_oauth"),Ir.current="link",await ua.initLoginWithOAuth("google")},linkTwitter:async()=>{qr("twitter"),sa("twitter_oauth"),Ir.current="link",await ua.initLoginWithOAuth("twitter")},linkDiscord:async()=>{qr("discord"),sa("discord_oauth"),Ir.current="link",await ua.initLoginWithOAuth("discord")},linkGithub:async()=>{qr("github"),sa("github_oauth"),Ir.current="link",await ua.initLoginWithOAuth("github")},linkSpotify:async()=>{qr("spotify"),sa("spotify_oauth"),Ir.current="link",await ua.initLoginWithOAuth("spotify")},linkInstagram:async()=>{qr("instagram"),sa("instagram_oauth"),Ir.current="link",await ua.initLoginWithOAuth("instagram")},linkTiktok:async()=>{qr("tiktok"),sa("tiktok_oauth"),Ir.current="link",await ua.initLoginWithOAuth("tiktok")},linkLinkedIn:async()=>{qr("linkedin"),sa("linkedin_oauth"),Ir.current="link",await ua.initLoginWithOAuth("linkedin")},linkApple:async()=>{qr("apple"),sa("apple_oauth"),Ir.current="link",await ua.initLoginWithOAuth("apple")},linkPasskey:async()=>{qr("passkey"),sa("passkey"),await ua.initLinkWithPasskey(),Nr(At.LINK_PASSKEY_SCREEN)},linkTelegram:async()=>{qr("telegram"),sa("telegram"),Ir.current="link",Cr.current="telegram",await ua.initLoginWithTelegram(),Nr(At.TELEGRAM_AUTH_SCREEN)},linkFarcaster:async()=>{qr("farcaster"),sa("farcaster"),await ua.initLoginWithFarcaster(),Ir.current="link",Cr.current="farcaster",Nr(At.AWAITING_FARCASTER_CONNECTION)},updateEmail:()=>{if(qr("email"),!se?.email)throw new Fe("User does not have an email linked to their account.");Ir.current="update",Cr.current="email",Nr(At.UPDATE_EMAIL_SCREEN)},updatePhone:()=>{if(qr("sms"),!se?.phone)throw new Fe("User does not have a phone number linked to their account.");Ir.current="update",Cr.current="sms",Nr(At.UPDATE_PHONE_SCREEN)},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!K){let e=await new Promise((e=>{dr((t=>e.bind(t)))}));if(dr(null),e)return void console.warn(t)}!se||se.isGuest?(Ir.current="login",lr({login:e}),br(At.LANDING)):console.warn(t)},connectOrCreateWallet:async()=>{K||(await new Promise((e=>{dr((()=>e))})),dr(null)),$?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(Ir.current="login",br(At.CONNECT_OR_CREATE))},logout:async()=>{if(Ir.current=null,Cr.current=null,se&&W.clearProviderAcccessTokens(se),jt(null),await W.logout(),se&&tr)try{await tr.clearMfa({userId:se.id})}catch(e){}ce(null),Y(!1),kt(Ar,"logout","onSuccess"),H(!1),re.del(q),re.del(X(ar.id))},getAccessToken:()=>W.getCustomerAccessToken(),getEthereumProvider:()=>{if(!se||!se.wallet)return new ve;let e=de.find((e=>se.wallet&&e.address===se.wallet.address)),t=W.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new ve},getEthersProvider:()=>{if(!se||!se.wallet)return new a(new Ce(new ve));let e=de.find((e=>se.wallet&&e.address===se.wallet.address)),t=W.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new a(new Ce(e&&t?t.proxyProvider:new ve))},getWeb3jsProvider:()=>{if(!se||!se.wallet)return new Ie(new ve);let e=de.find((e=>se.wallet&&e.address===se.wallet.address)),t=W.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new Ie(e&&t?t.proxyProvider:new ve)},unlinkWallet:async e=>{let t;return ce(t=e.startsWith("0x")?await W.unlinkEthereumWallet(e):await W.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await W.unlinkEmail(e);return ce(t),t},unlinkPhone:async e=>{let t=await W.unlinkPhone(e);return ce(t),t},unlinkGoogle:async e=>{let t=await W.unlinkOAuth("google",e);return ce(t),t},unlinkTwitter:async e=>{let t=await W.unlinkOAuth("twitter",e);return ce(t),t},unlinkDiscord:async e=>{let t=await W.unlinkOAuth("discord",e);return ce(t),t},unlinkGithub:async e=>{let t=await W.unlinkOAuth("github",e);return ce(t),t},unlinkSpotify:async e=>{let t=await W.unlinkOAuth("spotify",e);return ce(t),t},unlinkInstagram:async e=>{let t=await W.unlinkOAuth("instagram",e);return ce(t),t},unlinkTiktok:async e=>{let t=await W.unlinkOAuth("tiktok",e);return ce(t),t},unlinkLinkedIn:async e=>{let t=await W.unlinkOAuth("linkedin",e);return ce(t),t},unlinkApple:async e=>{let t=await W.unlinkOAuth("apple",e);return ce(t),t},unlinkFarcaster:async e=>{let t=await W.unlinkFarcaster(e);return ce(t),t},unlinkTelegram:async e=>{let t=await W.unlinkTelegram(e);return ce(t),t},unlinkPasskey:async e=>{let t=await W.unlinkPasskey(e);return ce(t),t},unlinkCrossAppAccount:async({subject:e})=>{let t=se?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new Fe("Invalid subject");W.storeProviderAccessToken(t.id,null);let r=await W.unlinkOAuth(`privy:${t.id}`,e);return ce(r),r},setActiveWallet:async e=>{let t=de.find((t=>r(t.address)===r(e))),a=se?.linkedAccounts.find((t=>"wallet"===t.type&&r(t.address)===r(e)));if(t&&await t.isConnected())if(t.linked){let e=Object.assign({},se);e.wallet=a&&{address:a.address,chainType:a.chainType,chainId:a.chainId,walletClient:a.walletClient,walletClientType:a.walletClientType,connectorType:a.connectorType,imported:a.imported,delegated:a.delegated,walletIndex:a.walletIndex},ce(e)}else t.loginOrLink();else lr({externalConnectWallet:{suggestedAddress:e}}),$r()},forkSession:()=>W.forkSession(),createWallet:async e=>{if(e&&"target"in e&&e&&(e=void 0),!$||!se)throw kt(Ar,"createWallet","onError",Be.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return Jr(se,15e3,e)},setWalletRecovery:async e=>la({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>la({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t,r)=>new Promise((async(a,n)=>{let{requesterAppId:i}=t||{};if(!$||!se)return kt(Ar,"signMessage","onError",Be.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=r??S(se)?.address;if(!o)throw new Fe("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=x(se,o);if(!s||!l)return kt(Ar,"signMessage","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return kt(Ar,"signMessage","onError",Be.INVALID_MESSAGE),void n(Error("Message must be a non-empty string"));or(!0);let c=async()=>{if(!$)throw Error("User must be authenticated before signing with a Privy wallet");let t=await Vr();if(!tr||!t||!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:r,entropyIdVerifier:a}=k(l),{response:n}=await tr.rpc({accessToken:t,entropyId:r,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"personal_sign",params:[e,s.address]}}),o=n.data;return W.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:s.address,requesterAppId:i}}),o};if(kr({showWalletUIs:t?.showWalletUIs}))try{let e=await c();kt(Ar,"signMessage","onSuccess",e),a(e)}catch(e){kt(Ar,"signMessage","onError",Be.UNABLE_TO_SIGN),n(e??new Ee("Unable to sign message"))}else{let{entropyId:r,entropyIdVerifier:i}=k(l);lr({signMessage:{method:"personal_sign",data:e,confirmAndSign:c,onSuccess:e=>{kt(Ar,"signMessage","onSuccess",e),a(e)},onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:r,entropyIdVerifier:i,onCompleteNavigateTo:At.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),signTypedData:(e,t,r)=>new Promise((async(a,n)=>{let{requesterAppId:i}=t||{};if(!$||!se)return kt(Ar,"signTypedData","onError",Be.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=r??S(se)?.address;if(!o)throw new Fe("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=x(se,o);if(!l||!s)return kt(Ar,"signTypedData","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));or(!0);let c=ie(e),d=async()=>{if(!$)throw Error("User must be authenticated before signing with a Privy wallet");let e=await Vr();if(!tr||!e||!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:t,entropyIdVerifier:r}=k(l),{response:a}=await tr.rpc({accessToken:e,entropyId:t,entropyIdVerifier:r,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"eth_signTypedData_v4",params:[s.address,c]}}),n=a.data;return W.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:s.address,requesterAppId:i}}),n};if(kr({showWalletUIs:t?.showWalletUIs,typedData:!0}))try{let e=await d();kt(Ar,"signTypedData","onSuccess",e),a(e)}catch(e){kt(Ar,"signTypedData","onError",Be.UNABLE_TO_SIGN),n(e??new Ee("Unable to sign message"))}else{let{entropyId:e,entropyIdVerifier:r}=k(l);lr({signMessage:{method:"eth_signTypedData_v4",data:c,confirmAndSign:d,onSuccess:e=>{kt(Ar,"signTypedData","onSuccess",e),a(e)},onFailure:e=>{kt(Ar,"signTypedData","onError",Be.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:e,entropyIdVerifier:r,onCompleteNavigateTo:At.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),sendTransaction:async(e,t,r,a)=>{let n=await aa(e,t,r,a);return De(await n.wait())},sendSolanaTransaction:async(e,t,r,a,n,i)=>{let o=i?me.find((({address:e})=>e===i)):me.slice().sort(((e,t)=>(e.walletIndex??0)-(t.walletIndex??0)))[0];if(!o)throw kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),new Fe("Embedded wallet not found",Be.EMBEDDED_WALLET_NOT_FOUND);return await na({transaction:e,connection:t,transactionOptions:a,uiOptions:r,fundWalletConfig:n,wallet:o})},exportWallet:e=>new Promise((async(t,r)=>{if(!$||!se)return void r(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let a=e?.address??S(se)?.address;if(!a)return void r(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));let{signingWallet:n,rootWallet:i}=x(se,a);if(!n||!i)return void r(Error("Must have a Privy wallet before exporting"));or(!0);let{entropyId:o,entropyIdVerifier:s}=k(i),l={entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:At.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:r,shouldForceMFA:!0};lr(sr),await Vr()&&tr?tr?(lr({keyExport:{appId:I.appId,appClientId:I.clientId,origin:W.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:r},connectWallet:l}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)):r(Error("Must have a Privy wallet before exporting")):r(Error("Must have valid access token to enroll in MFA"))})),promptMfa:ia,async init(e){switch(e){case"sms":return void await W.initMfaSmsVerification();case"passkey":return await W.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new Fe("Invalid MFA code");Er.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{_r.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new Fe("Invalid authenticator response");let r=await import("@simplewebauthn/browser"),a=yt(await r.startAuthentication(t));Er.current?.resolve({mfaMethod:e,mfaCode:a,relyingParty:window.origin}),await new Promise(((e,t)=>{_r.current={resolve:e,reject:t}}));break;default:throw Er.current?.reject(new Fe("Unsupported MFA method")),new Fe(`Unsupported MFA method: ${e}`)}},cancel(){Er.current?.reject(new Fe("MFA canceled"))},async initEnrollmentWithSms(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,r)=>{if(!e)return ua.closePrivyModal(),void t();ar.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),lr({mfaEnrollmentFlow:{mfaMethods:ar.mfa.methods,onSuccess:t,onFailure:r}}),Nr(At.MFA_ENROLLMENT_FLOW_SCREEN)})),async initEnrollmentWithTotp(){let e=await Vr();if(!e||!tr)throw Error("Must have valid access token to enroll in MFA");let t=await tr.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),ce(await W.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),ce(await W.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e}){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:e}),ce(await W.getAuthenticatedUser())},async unenroll(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to remove MFA");"passkey"===e?await tr.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:[]}):await tr.unenrollMfa({method:e,accessToken:t}),ce(await W.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await Vr(),t=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");let r=await tr.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===r.status&&ce(await W.getAuthenticatedUser()||se||null),lr({farcasterSigner:r}),Nr(At.AWAITING_FARCASTER_SIGNER)},getFarcasterSignerPublicKey:async()=>{let e,t=await Vr(),r=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!se.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=se.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await Vr(),r=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!se.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let a=await import("@simplewebauthn/browser"),n=await tr.signFarcasterMessage({address:r.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:a.bufferToBase64URLString(e)},fid:BigInt(se.farcaster.fid),relyingParty:window.origin});return new Uint8Array(a.base64URLStringToBuffer(n.signature))},createGuestAccount:async()=>{if(se&&!se.isGuest)throw Error("User cannot already be authenticated to create a guest account");return se?.isGuest?se:ua.loginWithGuestAccountFlow()},signMessageWithCrossAppWallet(e,{address:t}){let r=se?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return tt({user:se,client:W,address:t,requesterAppId:ar.id,request:{method:r?"privy_signSmartWalletMessage":"personal_sign",params:[e,t]},reconnect:ca})},signTypedDataWithCrossAppWallet(e,{address:t}){let r=se?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),a=ie(e);return tt({user:se,client:W,address:t,requesterAppId:ar.id,request:{method:r?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,a]},reconnect:ca})},sendTransactionWithCrossAppWallet(e,{address:t}){let r=se?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return tt({user:se,client:W,address:t,requesterAppId:ar.id,request:{method:r?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e]},reconnect:ca})},isModalOpen:V,mfaMethods:ar.mfa.methods};Dr=da.signMessage,Lr=da.signTypedData,Mr=async(...e)=>{let t=await aa(...e);return ar.embeddedWallets.waitForTransactionConfirmation&&await t.wait(),t};let ua={setAuthenticated:Y,setUser:ce,isNewUserThisSession:Mt,pendingTransaction:null,walletConnectionStatus:Ht,connectors:W.connectors?.walletConnectors??[],solanaWallets:me,rpcConfig:ar.rpcConfig,chains:ar.chains,appId:I.appId,showFiatPrices:"native-token"!==ar.embeddedWallets.priceDisplay.primary,clientAnalyticsId:W.clientAnalyticsId,customAuthStatus:fr,noPromptOnSignature:Wr,emailOtpState:qt,setEmailOtpState:$t,smsOtpState:Yt,setSmsOtpState:Xt,oAuthState:Zt,setOAuthState:er,siweState:Qt,setSiweState:Jt,isHeadlessOAuthLoading:Bt,nativeTokenSymbolForChainId:e=>ar.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(tr)return tr;let t=new Promise((e=>{hr((()=>t=>e(t)))})),r=new Promise((t=>setTimeout((()=>t(null)),e))),a=await Promise.race([t,r]);return hr(null),a},getAuthFlow:()=>W.authFlow,getAuthMeta:()=>W.authFlow?.meta,client:W,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,r=K&&$&&se;r&&Cr.current&&(t=oa(se)),"login"===Ir.current?e.shouldCallAuthOnSuccess&&r&&Cr.current?(kt(Ar,"login","onComplete",se,Mt,!1,Cr.current,t??null),I.onSuccess?.(se,Mt)):kt(Ar,"login","onError",Be.USER_EXITED_AUTH_FLOW):"link"===Ir.current&&t?e.isSuccess&&r&&Cr.current?kt(Ar,"linkAccount","onSuccess",se,Cr.current,t):Cr.current&&kt(Ar,"linkAccount","onError",Be.USER_EXITED_LINK_FLOW,{linkMethod:Cr.current}):"update"===Ir.current&&t&&(e.isSuccess&&r&&Cr.current?kt(Ar,"update","onSuccess",se,Cr.current,t):Cr.current&&kt(Ar,"update","onError",Be.USER_EXITED_UPDATE_FLOW,{linkMethod:Cr.current}));let a=xt&&ot.includes(xt),n=xt===At.ERROR_SCREEN&&sr.errorModalData&&ot.includes(sr.errorModalData.previousScreen);if((a||n)&&sr.funding){let e,t=st[xt]??null;if("solana"===sr.funding.chainType){let r=N(Et);if(!r)return void console.warn("Unable to load solana plugin, skipping balance");try{e=BigInt(await r.getBalance({address:sr.funding.address,cluster:sr.funding.cluster}))}catch{console.error("Unable to pull wallet balance")}kt(Ar,"fundSolanaWallet","onUserExited",{address:sr.funding.address,cluster:sr.funding.cluster,fundingMethod:t,balance:e})}else{let r=ne(sr.funding.chain.id,ar.chains,ar.rpcConfig,{appId:I.appId});try{e=(await r.getBalance(sr.funding.address)).toBigInt()}catch{console.error("Unable to pull wallet balance")}kt(Ar,"fundWallet","onUserExited",{address:sr.funding.address,chain:sr.funding.chain,fundingMethod:t,balance:e})}}lr({...sr,externalConnectWallet:{suggestedAddress:void 0}}),Ir.current=null,Cr.current=null,Ft(!1),H(!1),setTimeout((()=>{W.authFlow=void 0}),200),W.createAnalyticsEvent({eventName:"modal_closed"})},solanaSignMessage:({message:e,address:t})=>new Promise((async(r,a)=>{if(!$||!se)return kt(Ar,"signMessage","onError",Be.MUST_BE_AUTHENTICATED),void a(Error("User must be authenticated before signing with a Privy wallet"));let n=t??L(se)?.address;if(!n)throw new Fe("User must have an embedded wallet to sign a message.");let{signingWallet:i,rootWallet:o}=F(se,n);if(!i||!o)return kt(Ar,"signMessage","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void a(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return kt(Ar,"signMessage","onError",Be.INVALID_MESSAGE),void a(Error("Message must be a non-empty string"));or(!0);let s=async()=>{if(!$)throw Error("User must be authenticated before signing with a Privy wallet");let t=await W.getAccessToken();if(!t)throw Error("User must be authenticated to use their embedded wallet.");let r=ua.walletProxy??await ua.initializeWalletProxy(15e3);if(!r)throw Error("Failed to initialize embedded wallet proxy.");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!o)throw Error("No root wallet for signing wallet found");let{entropyId:a,entropyIdVerifier:n}=k(o),{response:s}=await r.rpc({accessToken:t,entropyId:a,entropyIdVerifier:n,chainType:"solana",hdWalletIndex:i.walletIndex??0,request:{method:"signMessage",params:{message:e}}});return s.data.signature};if(kr({showWalletUIs:void 0}))try{let e=await s();r({signature:e})}catch(e){a(e)}else{let{entropyId:t,entropyIdVerifier:n}=k(o);lr({signMessage:{method:"solana_signMessage",data:e,confirmAndSign:s,onSuccess:e=>{r({signature:e})},onFailure:e=>{a(e)},uiOptions:{}},connectWallet:{entropyId:t,entropyIdVerifier:n,onCompleteNavigateTo:At.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),a(e)}}}),br(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),openPrivyModal:Nr,connectWallet:Hr,initLoginWithWallet:async(e,t,r)=>{Te(e)?(Cr.current="siwe",Kr(e,t,r)):(Cr.current="siws",Gr(e,t))},loginWithWallet:async()=>{let e,t,r;if(!K)throw new Ve;if(W.authFlow instanceof E?e="siwe":W.authFlow instanceof _&&(e="siws"),!e)throw new Fe("Must initialize SIWE/SIWS flow first.");if(null!==await W.getAccessToken())try{({user:t}=await W.link()),Cr.current=e}catch(t){throw kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:r}=await W.authenticate()),Cr.current=e}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.GENERIC_CONNECT_WALLET_ERROR),e}ce(t||se||null),Ft(r||!1),Y(!0)},delegateWallet:async({address:e,chainType:t})=>new Promise((async(r,a)=>{let n=await Vr();if(!$||!se||!n)throw new Fe("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new Fe("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let i=ua.walletProxy??await ua.initializeWalletProxy(15e3);if(!i)throw new Fe("Wallet proxy not initialized.");if(Ue({address:e,chainType:t,user:se}))return r();let o=Oe({address:e,user:se}),s=Se({address:e,user:se});await ua.recoverPrimaryWallet(),lr({delegatedActions:{consent:{address:e,onDelegate:async()=>{await i.createDelegatedAction({accessToken:n,rootWallet:s,delegatedWallets:[o]}),await ua.refreshUser()},onSuccess:async()=>{r()},onError:async e=>{a(e)}}}}),Nr(At.EMBEDDED_WALLET_DELEGATED_ACTIONS_CONSENT_SCREEN)})),revokeDelegatedWallets:async()=>new Promise((async(e,t)=>{if(!$||!se)throw new Fe("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");if(0===Re(se).length)throw new Fe("User has no delegated wallets to revoke.");lr({delegatedActions:{revoke:{onRevoke:async()=>{await W.revokeDelegatedWallet(),await ua.refreshUser()},onSuccess:async()=>{e()},onError:async e=>{t(e)}}}}),Nr(At.EMBEDDED_WALLET_DELEGATED_ACTIONS_REVOKE_SCREEN)})),initLoginWithFarcaster:async(e,t)=>{let r=new y(e,t);W.startAuthFlow(r);try{Cr.current="farcaster",await r.initializeFarcasterConnect()}catch(e){throw"login"===Ir.current?kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!K)throw new Ve;if(!(W.authFlow instanceof y))throw new Fe("Must initialize Farcaster flow first.");if(null!==await W.getAccessToken())try{({user:e}=await W.link()),Cr.current="farcaster"}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await W.authenticate()),Cr.current="farcaster"}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}ce(e||null),Ft(t||!1),Y(!0)},async loginWithGuestAccountFlow(){let e=new f(this.appId);W.startAuthFlow(e);try{Ir.current="login",Cr.current="guest";let{user:e,isNewUser:t}=await W.authenticate();if(t=t||!1,!e)throw new Fe("Unable to authenticate guest account");if(D(e,ar.embeddedWallets.createOnLogin))try{await Jr(e,15e3),e=await ua.refreshUser()}catch(t){ce(e),console.warn("Unable to create embedded wallet for guest account")}else ce(e);return Ft(t),Y(!0),kt(Ar,"login","onComplete",e,t,!1,"guest",null),e}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}},async crossAppAuthFlow({appId:e,popup:t,action:r}){let a=`privy:${e}`;Cr.current=a;let{url:n,stateCode:i,codeVerifier:o}=await Qe({api:W.api,appId:e});if(!n)throw W.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new Fe("No authorization URL returned for cross-app auth.");try{let s=await et({url:n,popup:t,provider:a}),l=s.stateCode,c=s.authorizationCode;if(l!==i)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:a,storedStateCode:i??"",returnedStateCode:l??""}}),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED);let d=await Je({appId:e,codeVerifier:o,stateCode:l,authorizationCode:c,action:r,client:W});d&&W.storeProviderAccessToken(e,d);let u=await ua.refreshUser();if(!u)throw new Fe("Unable to update user");return W.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),u}catch(e){throw W.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:a}}),e}},async initLoginWithOAuth(e,t,r){if(Cr.current=e,!ae())return void br(At.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);if("google"===e&&ct(window.navigator.userAgent))return void br(At.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);"twitter"===e&&window.opener&&window.opener.postMessage({type:$e},"*"),re.del(Q),re.del(J);let a=new Lt({provider:e,disableSignup:!!r,withPrivyUi:!0});t&&a.addCaptchaToken(t),W.startAuthFlow(a);let n=await W.authFlow.getAuthorizationUrl();n&&n.url&&("twitter"===e&&c&&(n.url=n.url.replace("x.com","twitter.com")),window.location.assign(n.url))},async initLoginWithTelegram(e,t){if(!K)throw new Ve;Cr.current="telegram";let r=new v(e,t);W.startAuthFlow(r),r.meta.telegramWebAppData=void 0,r.meta.telegramAuthResult=await new Promise(((e,t)=>ar.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:ar.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(r=>r?e(r):t(new Fe("Telegram auth failed or was canceled by the client")))):t(new Fe("Telegram was not initialized")):t(new Fe("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,r;if(!(W.authFlow instanceof v))throw new Fe("Must initialize Telegram flow before calling loginWithTelegram");if(W.authFlow.meta.captchaToken||=e,"login"===Ir.current)try{let e=await W.authenticate();t=e.user,r=e.isNewUser,Cr.current="telegram"}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}else{if("link"!==Ir.current)throw new Fe("Unknown auth intent");try{t=(await W.link()).user,Cr.current="telegram"}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}ce(t),Ft(r||!1),Y(!0)},async recoveryOAuthFlow(e,t,r){let a,n;function i(t){if(!t)throw W.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:e}}),new Fe("Recovery OAuth failed")}switch(e){case"google-drive":{let t,o,{url:s,codeVerifier:l,stateCode:c}=await rt({api:Pr.api,provider:e});i(s);try{let a=await ut({url:s,popup:r,provider:e});if(t=a.stateCode,o=a.authorizationCode,t!==c)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:c??"",returnedStateCode:t??""}}),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED)}catch(t){throw W.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:t.toString(),provider:e}}),new Fe("Recovery OAuth failed")}[a,n]=await Promise.all([Vr(),at({api:Pr.api,provider:e,codeVerifier:l,stateCode:t,authorizationCode:o})]);break}case"icloud":{let{url:t}=await rt({api:Pr.api,provider:e});i(t);let{ckWebAuthToken:o}=await ut({url:t,popup:r,provider:e});n=o,a=await Vr()}}if(!tr)throw new Fe("Cannot connect to wallet proxy");if(!a)throw new Fe("Unable to authorize user");switch(t){case"recover":{let t=sr.recoverWallet?.entropyId,r=sr.recoverWallet?.entropyIdVerifier;if(!t||!r)throw new Fe("Recovery OAuth failed");W.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:t,recoveryMethod:e}}),await tr.recover({accessToken:a,entropyId:t,entropyIdVerifier:r,recoveryAccessToken:n}),W.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:t,recoveryMethod:e}});break}case"create-wallet":{W.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),await tr.create({accessToken:a,recoveryAccessToken:n,recoveryMethod:e});let t=S(await ua.refreshUser());if(!t)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:t.address}}),kt(Ar,"createWallet","onSuccess",t);break}case"set-recovery":{let t=O(se);if(!t)throw kt(Ar,"setWalletRecovery","onError",Be.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");W.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}});let{entropyId:r,entropyIdVerifier:i}=k(t);await tr.setRecovery({accessToken:a,entropyId:r,entropyIdVerifier:i,recoveryMethod:e,recoveryAccessToken:n});let o=O(await ua.refreshUser());if(!o)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}}),kt(Ar,"setWalletRecovery","onSuccess",e,o);break}default:throw new Fe("Unsupported recovery action")}},async loginWithOAuth(e){let t,r,a;if(!(W.authFlow instanceof Lt))throw new Fe("Must initialize OAuth flow before calling loginWithOAuth");let n=re.get(Z),i=W.authFlow.meta.stateCode;if(n!==i)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:n??"",returnedStateCode:i??""}}),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED);if(null!==await W.getAccessToken())try{let r=await W.link();t=r.user,a=r.oAuthTokens,Cr.current=e}catch(t){throw kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let n=await W.authenticate();t=n.user,r=n.isNewUser,a=n.oAuthTokens,Cr.current=e}catch(t){throw"login"===Ir.current?kt(Ar,"login","onError",t.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return ce(t),Ft(r||!1),Y(!0),a&&t&&kt(Ar,"oAuthAuthorization","onOAuthTokenGrant",a,{user:t}),a},passkeyAuthState:Gt,setPasskeyAuthState:zt,async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let r=new g({captchaToken:e,setPasskeyAuthState:zt});W.startAuthFlow(r),Ir.current="login";try{Cr.current="passkey",zt({status:"generating-challenge"}),await r.initAuthenticationFlow(t),zt({status:"awaiting-passkey"})}catch(e){throw zt({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(){let e,t;if(!K)throw new Ve;if(!(W.authFlow instanceof g))throw new Fe("Must initialize Passkey flow first.");if("passkey"!==Cr.current){let e=new Fe("Must init login with Passkey flow first.");throw zt({status:"error",error:e}),e}let r=await Vr();try{Cr.current="passkey",zt({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await W.authenticate())}catch(e){throw zt({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}ce(e),Ft(t||!1),Y(!0),zt({status:"done"});let a=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!r,loginAccount:a}},async initLinkWithPasskey(e){let t=new g({captchaToken:e});W.startAuthFlow(t),Ir.current="link",Cr.current="passkey",zt({status:"generating-challenge"});try{await t.initLinkFlow(),zt({status:"awaiting-passkey"})}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),zt({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!K)throw new Ve;if(!(W.authFlow instanceof g))throw new Fe("Must initialize Passkey flow first.");if("passkey"!==Cr.current)throw new Fe("Must init login with Passkey flow first.");try{Cr.current="passkey",({user:e}=await W.link())}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return ce(e||se||null),zt({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,r){if(!ae())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&ct(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let a=new Lt({provider:e,withPrivyUi:!1,disableSignup:r??!1});t&&a.addCaptchaToken(t),er({status:"loading"});let n=await W.startAuthFlow(a).getAuthorizationUrl();n?.url&&window.location.assign(n.url)},async loginWithHeadlessOAuth(e){let t,r,a;Vt(!0),er({status:"loading"}),W.startAuthFlow(new Lt(e));let n=re.get(Z),i=e.stateCode;if(n!==i)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:n??"",returnedStateCode:i??""}}),Vt(!1),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED);if(null!==await W.getAccessToken())try{({user:t,oAuthTokens:a}=await W.link()),Cr.current=e.provider;let r=oa(t);t&&r&&kt(Ar,"linkAccount","onSuccess",t,Cr.current,r)}catch(t){throw Vt(!1),kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:r,oAuthTokens:a}=await W.authenticate()),Cr.current=e.provider;let n=oa(t);t&&n&&void 0!==r&&kt(Ar,"login","onComplete",t,r,!1,Cr.current,n)}catch(e){throw Vt(!1),er({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}return ce(t),Ft(r||!1),Y(!0),Vt(!1),er({status:"done"}),a&&t&&kt(Ar,"oAuthAuthorization","onOAuthTokenGrant",a,{user:t}),t??void 0},initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:r,withPrivyUi:a})=>{let n=new m({email:e,captchaToken:t,disableSignup:r});W.startAuthFlow(n);try{Cr.current="email",$t({status:"sending-code"}),await n.sendCodeEmail({withPrivyUi:a}),$t({status:"awaiting-code-input"})}catch(e){throw $t({status:"error",error:e}),"login"===Ir.current?kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async(e,t,r)=>{let a=new w(e,t,r);W.startAuthFlow(a);try{await a.sendCodeEmail({withPrivyUi:!0})}catch(e){kt(Ar,"update","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:Cr.current})}},initUpdatePhone:async(e,t,r)=>{let a=new A(e,t,r);W.startAuthFlow(a);try{await a.sendSmsCode({withPrivyUi:!0})}catch(e){kt(Ar,"update","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:Cr.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:r,withPrivyUi:a})=>{Xt({status:"sending-code"});let n=new T({phoneNumber:e,captchaToken:t,disableSignup:r});W.startAuthFlow(n);try{Cr.current="sms",await n.sendSmsCode({withPrivyUi:a}),Xt({status:"awaiting-code-input"})}catch(e){throw Xt({status:"error",error:e}),"login"===Ir.current?kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(W.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(W.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,r;function a(e){W.authFlow instanceof m?$t(e):W.authFlow instanceof T&&Xt(e)}if(a({status:"submitting-code"}),!K){let e=new Ve;throw a({status:"error",error:e}),e}if(W.authFlow instanceof m)W.authFlow.meta.emailCode=e.trim();else{if(!(W.authFlow instanceof T)){let e=new Fe("Must initialize a passwordless code flow first");throw a({status:"error",error:e}),e}W.authFlow.meta.smsCode=e.trim()}let n=await Vr();if("link"===Ir.current)try{({user:t}=await W.link())}catch(e){throw a({status:"error",error:e}),kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:Cr.current}),e}else if("update"===Ir.current)try{({user:t}=await W.link())}catch(e){throw a({status:"error",error:e}),kt(Ar,"update","onError",e.privyErrorCode||Be.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:Cr.current}),e}else try{({user:t,isNewUser:r}=await W.authenticate())}catch(e){throw a({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}let i=t||se;ce(i||null),Ft(r||!1),Y(!0),a({status:"done"});let o=null;return W.authFlow instanceof m?o=i?.linkedAccounts.find((({type:e})=>"email"===e))||null:W.authFlow instanceof T&&(o=i?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:i,isNewUser:r||!1,wasAlreadyAuthenticated:!!n,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:r})=>{Ir.current="link",Cr.current="siwe",Jt({status:"generating-message"});let a=await W.generateSiweNonce({address:e,captchaToken:r});return Jt({status:"awaiting-signature"}),ht({address:e,chainId:t.replace("eip155:",""),nonce:a})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let r=await W.generateSiweNonce({address:e});return ht({address:e,chainId:t.replace("eip155:",""),nonce:r})},linkSmartWallet:async({message:e,signature:t,smartWalletType:r})=>{let a;a=await W.linkSmartWallet({message:e,signature:t,smartWalletType:r}),ce((a=await ua.refreshUser()??a)||se||null)},linkWithSiwe:async({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n})=>{let i;qr("siwe");let o=null;try{Jt({status:"submitting-signature"}),i=await W.linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}),i=await ua.refreshUser()??i,Jt({status:"done"}),(o=oa(i)||null)&&kt(Ar,"linkAccount","onSuccess",i,"siwe",o)}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),Ir.current=null,Cr.current=null,Jt({status:"error",error:e}),e}let s=i||se;return ce(s||null),Ir.current=null,Cr.current=null,{user:s,linkedAccount:o}},refreshUser:async()=>{let e=await W.getAuthenticatedUser();return Y(!!e),ce(e),e},walletProxy:tr,createAnalyticsEvent:({eventName:e,payload:t,timestamp:r})=>W.createAnalyticsEvent({eventName:e,payload:t,timestamp:r}),acceptTerms:async()=>{let e=await W.acceptTerms();return ce(e),e},getUsdTokenPrice:e=>W.getUsdTokenPrice(e),getUsdPriceForSol:()=>W.getUsdPriceForSol(),recoverPrimaryWallet:async e=>new Promise((async(t,r)=>{let a=O(e?.user??se)||P(e?.user??se)||U(e?.user??se),n=await Vr();if(!n||!tr||!a)return void r(Error("Must have valid access token and Privy wallet to recover wallet"));or(!0);let{entropyId:i,entropyIdVerifier:o}=k(a);try{await tr.connect({accessToken:n,entropyId:i,entropyIdVerifier:o}),t(!0)}catch(e){Pe(e)&&"privy"===a.recoveryMethod?(W.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:a.address}}),(await tr.recover({entropyId:i,entropyIdVerifier:o,accessToken:n})).entropyId||r(Error("Unable to recover wallet")),W.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:a.address}}),t(!0)):Pe(e)&&"privy"!==a.recoveryMethod?(lr({recoverWallet:{entropyId:i,entropyIdVerifier:o,onFailure:r,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:a.recoveryMethod,action:"recover"}}),Nr(nt(a.recoveryMethod))):r(e)}})),createEmbeddedSolanaWallet:async e=>{if(e&&"target"in e&&(e=void 0),!$||!se)throw kt(Ar,"createWallet","onError",Be.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return(async(e,t,r)=>{let a=S(e),n=L(e),i=r&&"createAdditional"in r&&r.createAdditional,o=r&&"walletIndex"in r?r.walletIndex:void 0,s=(j(e)?.walletIndex??-1)+1;if(n&&!i&&"number"!=typeof o)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");if("number"==typeof o&&o<0)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${o}) is invalid.`);let[l,c]=await Promise.all([ua.initializeWalletProxy(t),Vr()]);if(!l||!c)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return await ta({user:e,wp:l,accessToken:c,walletIndex:o??s,ethereumWallet:a})})(se,15e3,e)},exportSolanaWallet:e=>new Promise((async(t,r)=>{if(!$||!se)return void r(Error("User must be authenticated before exporting their Privy wallet"));let a=e?.address??L(se)?.address;if(!a)return void r(Error("User does not have an HD Solana wallet."));let{signingWallet:n,rootWallet:i}=F(se,a);if(!n||!i)return void r(Error("Must have a Privy wallet before exporting"));if(or(!0),!await Vr()||!tr)return void r(Error("Must have valid access token to enroll in MFA"));if(!tr)return void r(Error("Must have a Privy wallet before exporting"));let{entropyId:o,entropyIdVerifier:s}=k(i);lr({connectWallet:{entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:At.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:r,shouldForceMFA:!0},keyExport:{appId:I.appId,appClientId:I.clientId,origin:W.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:r}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)})),setReadyToTrue:e=>{z(!0),cr?.(e)},updateWallets:()=>Qr(),fundWallet:async(e,t)=>{let r=At.FUNDING_METHOD_SELECTION_SCREEN;lr({funding:Pt({address:e,appConfig:ar,fundWalletConfig:t,methodScreen:r})}),Nr(r)},openModal:Nr,requestFarcasterSignerStatus:async e=>{let t=await Vr(),r=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let a=await W.requestFarcasterSignerStatus(e);return"approved"===a.status&&ce(await W.getAuthenticatedUser()||se||null),a},connectCoinbaseSmartWallet:async()=>{ar.externalWallets.coinbaseWallet.connectionOptions="smartWalletOnly";let e=W.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||W.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),Hr(e);await Br("coinbase_wallet","coinbase_smart_wallet")},initiateAccountTransfer:async({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o})=>{let s=await W.sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o});return ce(s),s}};Fr=ua.recoverPrimaryWallet,xr=ua.recoverPrimaryWallet,jr=ua.solanaSignMessage;let ha=l((()=>({wallets:de,ready:pr&&Tr})),[de,pr,Tr]),pa=W.authFlow instanceof v,wa=!ar.headless&&ar.captchaEnabled&&!$&&(K||pa);/*#__PURE__*/return e(Ot.Provider,{value:da,children:/*#__PURE__*/e(Nt.Provider,{value:Ar,children:/*#__PURE__*/e(St.Provider,{value:ha,children:/*#__PURE__*/e(It,{...ar,children:/*#__PURE__*/t(bt.Provider,{value:ua,children:[/*#__PURE__*/e(_t,{children:/*#__PURE__*/t(Ut,{data:sr,setModalData:lr,setInitialScreen:jt,initialScreen:xt,authenticated:$,open:V,children:[I.children,wa&&/*#__PURE__*/e(he,{delayedExecution:!1}),/*#__PURE__*/e(vt,{theme:{...ar.appearance.palette||{}}}),!ar.render.standalone&&/*#__PURE__*/e(pe,{open:V})]})}),ir&&nr?/*#__PURE__*/e(be,{appId:I.appId,appClientId:I.clientId,clientAnalyticsId:W.clientAnalyticsId,origin:W.apiUrl,mfaMethods:se?.mfaMethods,mfaPromise:Er,mfaSubmitPromise:_r,onLoad:rr,onLoadFailed:()=>null}):null,ar.loginConfig.telegramAuthConfiguration&&
 /*#__PURE__*/e(Tt,{$if:!0,children:/*#__PURE__*/e(we,{scriptHost:I.apiUrl||G,botUsername:ar.loginConfig.telegramAuthConfiguration.botName})})]})})})})})};export{Wr as C,Ir as E,Yr as P,Or as a,Rr as b,Vr as c,Hr as d,Kr as e,Gr as f,Br as g,zr as h,qr as i,$r as j,kr as l};
diff --git a/node_modules/@privy-io/react-auth/dist/esm/svg/protected-by-privy.mjs b/node_modules/@privy-io/react-auth/dist/esm/svg/protected-by-privy.mjs
index a9ff591..a70467c 100644
--- a/node_modules/@privy-io/react-auth/dist/esm/svg/protected-by-privy.mjs
+++ b/node_modules/@privy-io/react-auth/dist/esm/svg/protected-by-privy.mjs
@@ -1 +1 @@
-import{jsx as c}from"react/jsx-runtime";function a(a){/*#__PURE__*/return c("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 460 40",...a,children:/*#__PURE__*/c("g",{fill:a.color||"var(--privy-color-foreground)",children:/*#__PURE__*/c("path",{d:"M0 15.4v15.38h4.64V19.96h3.58c2.47 0 3.63-.01 3.77-.02 1-.08 1.49-.15 2.18-.3a9.45 9.45 0 0 0 4.6-2.37c1.66-1.57 2.64-3.87 2.81-6.56.02-.3.02-1.19 0-1.49-.1-1.77-.56-3.35-1.36-4.72A8.84 8.84 0 0 0 15.14.57c-.93-.3-1.75-.43-3.09-.54C11.9.02 10.2 0 5.93 0H0ZM10.85 4c1.85.05 3.1.45 4.16 1.3.22.17.54.49.69.68a5.97 5.97 0 0 1 1.19 3.13c.04.35.04 1.36 0 1.71-.08.68-.23 1.3-.44 1.85a4.8 4.8 0 0 1-1.09 1.68A5.63 5.63 0 0 1 12 15.92c-.6.08-.4.08-4.01.09H4.64V3.98h2.9c1.6 0 3.08 0 3.31.02ZM187.65 5.71v5.72h-.27l-.09-.14a15.9 15.9 0 0 0-1.21-1.73c-.43-.5-1-.95-1.7-1.36-.54-.3-1.05-.5-1.73-.63a8.98 8.98 0 0 0-1.7-.17 8.84 8.84 0 0 0-7.8 4.03 12.95 12.95 0 0 0-2.03 6.39c-.07.98-.06 2.15.02 3.13.2 2.47.87 4.53 2.02 6.25a8.98 8.98 0 0 0 10.22 3.65 6.5 6.5 0 0 0 2.8-1.93c.41-.51.84-1.1 1.1-1.55l.1-.17h.37v3.58h4.38V0h-4.48Zm-5.24 5.54c1.3.14 2.3.6 3.17 1.48.9.9 1.5 2.09 1.85 3.64.36 1.6.39 3.72.06 5.43a8.13 8.13 0 0 1-1.54 3.62 5.1 5.1 0 0 1-3.93 1.96 6.13 6.13 0 0 1-2.32-.31 5.87 5.87 0 0 1-3.33-3.5c-.39-1-.62-2.05-.72-3.32-.03-.32-.04-1.35-.02-1.73.08-1.56.4-2.91.96-4.05a6.2 6.2 0 0 1 1.06-1.58 5.08 5.08 0 0 1 3.6-1.66c.25-.02.9 0 1.16.02ZM210.07 15.39l.01 15.38h4.38l.01-3.57h.37l.09.15c.24.44.84 1.26 1.21 1.7a6.79 6.79 0 0 0 2.57 1.75 9.3 9.3 0 0 0 6.86-.49 9.28 9.28 0 0 0 4.05-4.07A13.05 13.05 0 0 0 231 21.6c.21-1.73.18-3.7-.09-5.32a13.03 13.03 0 0 0-1.5-4.3 9.1 9.1 0 0 0-3.75-3.63 9.15 9.15 0 0 0-4.43-.96 7.46 7.46 0 0 0-2.8.5A7.07 7.07 0 0 0 216 9.7c-.4.52-.82 1.12-1.1 1.59l-.07.14h-.27V0h-4.5Zm11.13-4.14c1.07.1 1.94.44 2.7 1.04a6.1 6.1 0 0 1 1.64 1.98c.43.84.78 2 .94 3.11.15 1.16.16 2.4.02 3.54a9.34 9.34 0 0 1-1.39 4.03 5.33 5.33 0 0 1-2.69 2.15c-.9.3-2.04.38-3.06.2a5.14 5.14 0 0 1-3.45-2.37 6.03 6.03 0 0 1-.45-.8c-.5-1.03-.8-2.2-.92-3.58-.04-.49-.06-.89-.05-1.53.01-.76.05-1.23.13-1.85.38-2.53 1.47-4.38 3.15-5.31a5.46 5.46 0 0 1 2.3-.63 10 10 0 0 1 1.13.02ZM69.05 2.17l-.01 2.77V7.7h-3.36v3.6h3.36v6.8l.01 7.15c.06 1.4.4 2.44 1.1 3.37a5.8 5.8 0 0 0 2.97 2.07c.91.3 1.83.42 2.9.38a8.71 8.71 0 0 0 2.66-.48l-.8-3.7-.38.06a4.96 4.96 0 0 1-2.43-.06c-.33-.1-.56-.25-.8-.49-.4-.41-.6-.88-.7-1.67-.02-.2-.02-.62-.03-6.82v-6.6h4.73V7.7h-4.73V2.16h-4.49ZM133.34 2.17V7.7h-3.39v3.6h3.38v6.9l.01 7.17a5.66 5.66 0 0 0 2.36 4.49c.85.6 2.03 1.03 3.26 1.17.85.1 2.03.05 2.81-.1.3-.06.75-.18 1-.26l.2-.06v-.05l-.81-3.67-.37.06a4.99 4.99 0 0 1-1.8.09c-.85-.13-1.32-.4-1.7-.97a2.63 2.63 0 0 1-.39-1.04c-.06-.4-.06 0-.06-7.1V11.3h4.7V7.7h-4.7l-.01-2.77V2.16h-4.49ZM293.41 2.36a14.56 14.56 0 0 0-13.7 16.07 14.59 14.59 0 0 0 21.86 11.08 14.5 14.5 0 0 0 7.11-14.07 14.61 14.61 0 0 0-6.53-10.73 14.49 14.49 0 0 0-8.74-2.35ZM350.8 2.36a10.17 10.17 0 0 0-7.56 4.2c-.16.2-.45.63-.58.83l-.05.1h-.47l-.01-4.36h-7.36v36.4h7.82V27.27h.49l.05.07a11.3 11.3 0 0 0 7.49 4.15 10.52 10.52 0 0 0 9.38-4.1c1.66-2.1 2.73-4.9 3.07-8.06.1-.87.13-1.4.13-2.37 0-.8 0-1.1-.07-1.76a15.95 15.95 0 0 0-3.23-8.72 12.8 12.8 0 0 0-1.85-1.84 10.49 10.49 0 0 0-7.26-2.28Zm-.94 6.05c1.27.15 2.33.65 3.2 1.5.98.96 1.67 2.31 2.03 4 .34 1.57.38 3.68.12 5.39a9.78 9.78 0 0 1-1.04 3.25c-.14.25-.44.69-.6.89a5.35 5.35 0 0 1-4.31 2.07 5.25 5.25 0 0 1-4.41-1.9 7.35 7.35 0 0 1-1.26-2.32 14.09 14.09 0 0 1-.62-4.83c.05-1.98.38-3.53 1.02-4.85a5.63 5.63 0 0 1 2.5-2.65c.66-.34 1.3-.5 2.14-.58.18-.02 1.04 0 1.23.03ZM363.63 3.1l-.01 3.2v3.16h1.43c1.26.01 1.44.02 1.54.04.42.09.66.28.79.62.08.23.08.08.08 2.96a911.57 911.57 0 0 1 .03 10.18v7.54h7.82v-7.4l.01-7.83c.03-.94.11-1.63.27-2.28.46-1.9 1.54-2.93 3.35-3.23.52-.08.2-.08 5-.08h4.4V3.08h-3.1c-3.48 0-3.91.01-4.67.1-1.83.2-3.04.79-3.96 1.88-.5.6-.9 1.32-1.26 2.26l-.06.17h-.46V3.09h-5.6c-4.46 0-5.6 0-5.6.02ZM390.8 16.95V30.8h3.87l3.86-.01V3.09h-7.73ZM400.6 3.1l-.01.4v.38l4.66 13.4 4.69 13.47.02.05h10.3l.03-.05 4.67-13.45 4.67-13.4V3.1h-7.43l-6.7 19.26h-.5l-3.28-9.5-3.31-9.64-.05-.12h-3.88l-3.88.01ZM430.98 3.1c-.01 0-.02.19-.02.4v.39l5.08 14.59c2.8 8.02 5.08 14.6 5.08 14.61.01.02-.22.02-4.8.02h-4.82v6.42h4.95c5.09 0 5.23 0 5.87-.06 3.15-.28 5.29-1.63 6.63-4.15.28-.55.44-.95.87-2.16L459 6.78l1-2.89v-.8h-7.43l-6.69 19.26h-.5l-3.27-9.46-3.31-9.64-.06-.16h-3.88l-3.88.01ZM36.57 7.36c-1.36.1-2.6.6-3.62 1.45a5.65 5.65 0 0 0-1.67 2.42l-.05.13H31V7.7h-4.35v23.08h4.5v-7.3c0-8 0-7.34.08-7.82a4.89 4.89 0 0 1 2.06-3.18c.83-.58 1.74-.89 2.87-.98a11.87 11.87 0 0 1 2.8.25H39v-4.3l-.21-.02c-.61-.07-1.74-.1-2.22-.07ZM51.08 7.41c-2.33.12-4.3.84-5.95 2.16a9.89 9.89 0 0 0-2.03 2.2 12.5 12.5 0 0 0-2 5.78 18.04 18.04 0 0 0 0 3.65 12.13 12.13 0 0 0 2.26 6.05 9.74 9.74 0 0 0 5 3.52c2.11.64 4.7.64 6.8 0a9.78 9.78 0 0 0 4.88-3.37c1.38-1.78 2.19-4 2.4-6.58.13-1.46.06-3.06-.18-4.42a11.24 11.24 0 0 0-3.58-6.6 10 10 0 0 0-5.75-2.35c-.56-.06-1.31-.07-1.85-.04Zm1.42 3.78c.88.1 1.62.34 2.28.75a6.13 6.13 0 0 1 1.99 2.15 10.31 10.31 0 0 1 1.2 5c.02 1.23-.12 2.44-.42 3.51a7.14 7.14 0 0 1-1.81 3.32c-.61.6-1.2.98-1.95 1.24a6 6 0 0 1-2 .3 5.7 5.7 0 0 1-2.72-.6 5 5 0 0 1-1.28-.94A7.1 7.1 0 0 1 46 22.73c-.57-1.99-.6-4.46-.08-6.5a7.24 7.24 0 0 1 2.03-3.67 5.13 5.13 0 0 1 3.35-1.4 11 11 0 0 1 1.2.03ZM92.05 7.4c-.96.06-1.56.15-2.3.33a9.62 9.62 0 0 0-6.09 4.66 13.5 13.5 0 0 0-1.71 7c0 .83 0 1.04.06 1.6.16 1.77.58 3.32 1.29 4.7A9.72 9.72 0 0 0 90.28 31c1.84.37 4.08.32 5.85-.13a9.07 9.07 0 0 0 5.02-3.1A7.64 7.64 0 0 0 102.5 25l-2.11-.39-2.11-.38-.08.13a4.72 4.72 0 0 1-2.35 2.55 6.3 6.3 0 0 1-2.23.58c-.29.03-1.13.03-1.44 0a6.35 6.35 0 0 1-3.02-1.04 5.93 5.93 0 0 1-2.02-2.43 8.44 8.44 0 0 1-.72-3.18v-.26h16.38v-.81c0-1.83-.06-2.76-.25-3.87-.2-1.22-.53-2.24-1.05-3.28a8.9 8.9 0 0 0-2.66-3.26 10.1 10.1 0 0 0-5.34-1.94 18.3 18.3 0 0 0-1.46-.03Zm1.3 3.75c1.2.13 2.19.55 3.05 1.3a5.8 5.8 0 0 1 1.78 2.96c.13.51.21 1.17.21 1.66v.15H86.43v-.12c.08-.97.3-1.78.72-2.61.5-1 1.2-1.8 2.14-2.42a5.32 5.32 0 0 1 2.9-.95c.2-.01.97 0 1.17.03ZM116.79 7.41c-2 .1-3.73.65-5.22 1.65a10.7 10.7 0 0 0-4.25 6.06 16.1 16.1 0 0 0-.5 5.8c.2 2.17.84 4.13 1.88 5.76.58.9 1.32 1.73 2.15 2.4a9.37 9.37 0 0 0 3.6 1.8 12.06 12.06 0 0 0 3.92.34 10.2 10.2 0 0 0 3.84-.95 8.31 8.31 0 0 0 4.76-6.75l.01-.04h-4.37l-.05.16a4.87 4.87 0 0 1-4.24 3.75c-.59.07-1.32.06-1.93-.05a5.47 5.47 0 0 1-3.5-2.27c-.56-.75-1-1.73-1.26-2.79a13.8 13.8 0 0 1-.16-5.24 7.77 7.77 0 0 1 2.1-4.3 5.48 5.48 0 0 1 2.15-1.3 6.4 6.4 0 0 1 3.89.1c.59.21 1.03.5 1.5.96a5.32 5.32 0 0 1 1.46 2.5l.04.15h4.37v-.06a8.22 8.22 0 0 0-5.31-6.94 10.98 10.98 0 0 0-4.88-.74ZM156.2 7.41a9.87 9.87 0 0 0-6 2.29 11.02 11.02 0 0 0-3.41 5.43c-.52 1.78-.68 3.9-.48 5.97.17 1.8.63 3.38 1.37 4.8a9.68 9.68 0 0 0 5.91 4.86c1.65.48 3.63.61 5.53.36 3.72-.49 6.55-2.62 7.56-5.69.12-.39.13-.42.1-.43-.02 0-4.13-.75-4.19-.75-.03 0-.04 0-.1.16-.18.42-.45.9-.72 1.22-.16.2-.49.53-.7.7-.67.54-1.5.9-2.43 1.08-.48.08-.83.11-1.41.11-.64 0-1.07-.04-1.6-.15a5.76 5.76 0 0 1-3.93-2.83 8 8 0 0 1-.99-3.79v-.16h16.38v-1.11l-.02-1.43c-.1-2.25-.53-4-1.35-5.59a9.24 9.24 0 0 0-6.18-4.75c-1.04-.26-2.2-.36-3.33-.3Zm1.45 3.74a5.35 5.35 0 0 1 3.66 1.94 6.1 6.1 0 0 1 1.38 4.01v.12h-11.97v-.06c0-.02 0-.14.02-.25a6.6 6.6 0 0 1 2.15-4.32 5.73 5.73 0 0 1 3.5-1.46c.25-.02 1 0 1.26.02ZM233.58 7.82l8.37 23.22a49.22 49.22 0 0 1-.67 1.9 5.36 5.36 0 0 1-1.14 1.8c-.41.4-.82.58-1.48.69-.27.04-1.03.03-1.35 0a8.05 8.05 0 0 1-1.1-.23l-1.08 3.67c0 .02.32.14.66.22.83.21 1.57.29 2.56.28.56-.01.8-.03 1.24-.1 2.71-.4 4.66-2.09 5.86-5.08l9.64-26.44c0-.02-4.82-.06-4.83-.05l-2.93 8.96-2.91 8.94h-.24l-.22-.65-2.91-8.95-2.7-8.3H233.53ZM293.05 35.8c-1.18.04-1.93.09-2.8.16-2.52.24-4.53.69-5.43 1.23-.7.41-.76.86-.2 1.28.88.66 3.29 1.19 6.36 1.4a48.55 48.55 0 0 0 5.75.05c3.47-.19 6.24-.78 7.11-1.5.22-.19.3-.34.3-.53 0-.1 0-.12-.04-.22-.35-.69-2.32-1.3-5.25-1.63a41.09 41.09 0 0 0-5.8-.24Zm0 0"})})})}export{a as ProtectedByPrivy};
+import{jsx as c}from"react/jsx-runtime";function a(a){/*#__PURE__*/return c("div",{...a})}export{a as ProtectedByPrivy};
